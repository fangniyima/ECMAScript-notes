## 10.2 ECMAScript Function Objects
ECMAScriptå‡½æ•°å¯¹è±¡å°è£…åœ¨è¯æ³•ç¯å¢ƒä¸­å…³é—­çš„å‚æ•°åŒ–ECMAScriptä»£ç ï¼Œå¹¶æ”¯æŒè¯¥ä»£ç çš„åŠ¨æ€è®¡ç®—ã€‚ECMAScriptå‡½æ•°å¯¹è±¡æ˜¯ä¸€ä¸ªæ™®é€šå¯¹è±¡ï¼Œä¸å…¶ä»–æ™®é€šå¯¹è±¡å…·æœ‰ç›¸åŒçš„å†…éƒ¨æ§½å’Œç›¸åŒçš„å†…éƒ¨æ–¹æ³•ã€‚ECMAScriptå‡½æ•°å¯¹è±¡çš„ä»£ç å¯ä»¥æ˜¯ä¸¥æ ¼æ¨¡å¼ä»£ç ï¼ˆ11.2.2ï¼‰æˆ–éä¸¥æ ¼ä»£ç ã€‚ä»£ç ä¸ºstrictæ¨¡å¼ä»£ç çš„ECMAScriptå‡½æ•°å¯¹è±¡ç§°ä¸ºstrictå‡½æ•°ã€‚ä»£ç ä¸æ˜¯ä¸¥æ ¼æ¨¡å¼ä»£ç çš„å‡½æ•°ç§°ä¸ºéä¸¥æ ¼å‡½æ•°ã€‚
é™¤äº†[[Extensible]]å’Œ[[Prototype]]ï¼ŒECMAScriptå‡½æ•°å¯¹è±¡è¿˜å…·æœ‰è¡¨29ä¸­åˆ—å‡ºçš„å†…éƒ¨æ’æ§½ã€‚

Table 29: Internal Slots of ECMAScript Function Objects

|   Internal Slot	           |    Type       	    |   Description |
|  ----  | ----  | ----  |
|[[Environment]]|	Environment Record	|functionè¢«å…³é—­çš„ç¯å¢ƒè®°å½•ã€‚ åœ¨è¯„ä¼°å‡½æ•°çš„ä»£ç æ—¶ç”¨ä½œå¤–éƒ¨ç¯å¢ƒã€‚
|[[FormalParameters]]|	Parse Node|	å®šä¹‰å‡½æ•°å½¢å¼å‚æ•°åˆ—è¡¨çš„æºæ–‡æœ¬çš„æ ¹è§£æèŠ‚ç‚¹ã€‚
|[[ECMAScriptCode]]|	Parse Node|	å®šä¹‰å‡½æ•°ä¸»ä½“çš„æºæ–‡æœ¬çš„æ ¹è§£æèŠ‚ç‚¹ã€‚
[[ConstructorKind]]	base | derived|	è¯¥å‡½æ•°æ˜¯å¦æ˜¯æ´¾ç”Ÿç±»æ„é€ å‡½æ•°ã€‚
|[[Realm]]|	Realm Record	|åœ¨å…¶ä¸­åˆ›å»ºå‡½æ•°å¹¶æä¾›åœ¨è¯„ä¼°å‡½æ•°æ—¶è®¿é—®çš„ä»»ä½•å†…éƒ¨å¯¹è±¡çš„realmã€‚
|[[ScriptOrModule]]	|Script Record or Module Record	|åœ¨å…¶ä¸­åˆ›å»ºå‡½æ•°çš„è„šæœ¬æˆ–æ¨¡å—ã€‚
|[[ThisMode]]	|lexical  strict  global|å®šä¹‰å¦‚ä½•åœ¨å‡½æ•°çš„å½¢å¼å‚æ•°å’Œä»£ç ä¸»ä½“ä¸­è§£é‡Šthiså¼•ç”¨ã€‚ è¯æ³•æ„å‘³ç€ this æŒ‡çš„æ˜¯è¯æ³•å°é—­å‡½æ•°çš„ this å€¼ã€‚ strict è¡¨ç¤º this å€¼å®Œå…¨æŒ‰ç…§å‡½æ•°è°ƒç”¨æä¾›çš„æ–¹å¼ä½¿ç”¨ã€‚ global æ„å‘³ç€ this å€¼ä¸º undefined æˆ– null è¢«è§£é‡Šä¸ºå¯¹å…¨å±€å¯¹è±¡çš„å¼•ç”¨ï¼Œä»»ä½•å…¶ä»– this å€¼é¦–å…ˆä¼ é€’ç»™ ToObjectã€‚
|[[Strict]]|	Boolean|å¦‚æœè¿™æ˜¯ä¸€ä¸ªä¸¥æ ¼å‡½æ•°ï¼Œåˆ™ä¸º trueï¼›å¦‚æœè¿™æ˜¯ä¸€ä¸ªéä¸¥æ ¼å‡½æ•°ï¼Œåˆ™ä¸º falseã€‚
|[[HomeObject]]	|Object|å¦‚æœå‡½æ•°ä½¿ç”¨ superï¼Œåˆ™ this æ˜¯å…¶ [[GetPrototypeOf]] æä¾›superå±æ€§æŸ¥æ‰¾å¼€å§‹çš„å¯¹è±¡çš„å¯¹è±¡ã€‚
|[[SourceText]]	|sequence of Unicode code points|å®šä¹‰å‡½æ•°çš„æºæ–‡æœ¬ã€‚
|[[Fields]]|a List of ClassFieldDefinition Records|å¦‚æœè¯¥å‡½æ•°æ˜¯ä¸€ä¸ªç±»ï¼Œåˆ™è¿™æ˜¯ä¸€ä¸ª Records åˆ—è¡¨ï¼Œè¡¨ç¤ºè¯¥ç±»çš„éé™æ€å­—æ®µå’Œç›¸åº”çš„åˆå§‹å€¼è®¾å®šé¡¹ã€‚|
|[[PrivateMethods]]|a List of PrivateElements|å¦‚æœè¯¥å‡½æ•°æ˜¯ä¸€ä¸ªç±»ï¼Œåˆ™è¿™æ˜¯ä¸€ä¸ªè¡¨ç¤ºè¯¥ç±»çš„éé™æ€ç§æœ‰æ–¹æ³•å’Œè®¿é—®å™¨çš„åˆ—è¡¨ã€‚|
|[[ClassFieldInitializerName]]|a String, a Symbol, a Private Name, or empty|å¦‚æœè¯¥å‡½æ•°æ˜¯ä½œä¸ºç±»å­—æ®µçš„åˆå§‹å€¼è®¾å®šé¡¹åˆ›å»ºçš„ï¼Œåˆ™ä¸ºè¯¥å­—æ®µçš„ NamedEvaluation ä½¿ç”¨çš„åç§°ï¼› å¦åˆ™ä¸ºç©ºã€‚|
|[[IsClassConstructor]]	|Boolean|æŒ‡ç¤ºå‡½æ•°æ˜¯å¦ä¸ºç±»æ„é€ å‡½æ•°ã€‚ ï¼ˆå¦‚æœä¸ºçœŸï¼Œè°ƒç”¨å‡½æ•°çš„ [[Call]] å°†ç«‹å³æŠ›å‡º TypeError å¼‚å¸¸ã€‚ï¼‰

æ‰€æœ‰ECMAScriptå‡½æ•°å¯¹è±¡éƒ½å…·æœ‰æ­¤å¤„å®šä¹‰çš„[[Call]]å†…éƒ¨æ–¹æ³•ã€‚ ECMAScriptå‡½æ•°ä¹Ÿæ˜¯æ„é€ å‡½æ•°ï¼Œå¦å¤–è¿˜å…·æœ‰[[Construct]]å†…éƒ¨æ–¹æ³•ã€‚

### 10.2.1 [[Call]]ï¼ˆthisArgumentï¼ŒargumentsListï¼‰

ECMAScript å‡½æ•°å¯¹è±¡ F çš„ [[Call]] å†…éƒ¨æ–¹æ³•æ¥å—å‚æ•° thisArgumentï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å’Œ argumentsListï¼ˆECMAScript è¯­è¨€å€¼åˆ—è¡¨ï¼‰å¹¶è¿”å›åŒ…å« ECMAScript è¯­è¨€å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let callerContext be the running execution context.
2. Let calleeContext be PrepareForOrdinaryCall(F, undefined).
3. Assert: calleeContext is now the running execution context.
4. If F.[[IsClassConstructor]] is true, then
    - Let error be a newly created TypeError object.
    - NOTE: error is created in calleeContext with F's associated Realm Record.
    - Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
    - Return ThrowCompletion(error).
5. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).
6. Let result be Completion(OrdinaryCallEvaluateBody(F, argumentsList)).
7. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
8. If result.[[Type]] is return, return result.[[Value]].
9. ReturnIfAbrupt(result).
10. Return undefined.

>NOTE åœ¨æ­¥éª¤ä¸­ä»æ‰§è¡Œä¸Šä¸‹æ–‡å †æ ˆä¸­ç§»é™¤calleeContextæ—¶ï¼Œå¦‚æœå®ƒè¢«æŒ‚èµ·å¹¶ä¿ç•™ä»¥ä¾›ä»¥åç”±å¯è®¿é—®çš„ç”Ÿæˆå™¨å¯¹è±¡æ¢å¤ï¼Œåˆ™ä¸èƒ½é”€æ¯å®ƒã€‚

#### 10.2.1.1 PrepareForOrdinaryCall ( F, newTarget )

æŠ½è±¡æ“ä½œ PrepareForOrdinaryCall æ¥å—å‚æ•° Fï¼ˆa function objectï¼‰å’Œ newTargetï¼ˆobject or nullï¼‰å¹¶è¿”å›æ‰§è¡Œä¸Šä¸‹æ–‡ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let callerContext be the running execution context.
2. Let calleeContext be a new ECMAScript code execution context.
3. Set the Function of calleeContext to F.
4. Let calleeRealm be F.[[Realm]].
5. Set the Realm of calleeContext to calleeRealm.
6. Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].
7. Let localEnv be NewFunctionEnvironment(F, newTarget).
8. Set the LexicalEnvironment of calleeContext to localEnv.
9. Set the VariableEnvironment of calleeContext to localEnv.
10. Set the PrivateEnvironment of calleeContext to F.[[PrivateEnvironment]].
11. If callerContext is not already suspended, suspend callerContext.
12. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.
13. NOTE: Any exception objects produced after this point are associated with calleeRealm.
14. Return calleeContext.

```
//ç¬¬äºŒæ­¥åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ECMAScript code execution context.
//ç¬¬ä¸‰æ­¥å°†è¿™ä¸ªcalleeContextçš„Functionè®¾ä¸ºF
//ç¬¬å››æ­¥å°†F.realmè®¾ä¸ºäº†calleeRealm
//ç¬¬äº”æ­¥å°†è¿™ä¸ªcalleeRealmè®¾ä¸ºäº†calleeContextçš„realm
//ä¹Ÿå°±æ˜¯è¯´åœ¨ä¸¤ä¸ªä¸åŒçš„åŸŸçš„ä»£ç æ‰§è¡Œä¸­ï¼Œè°ƒç”¨è€…çš„åŸŸå°†æ”¹å˜è¢«è°ƒç”¨è€…çš„åŸŸ

//index
<iframe id="gg" name="once" src="./child.html">
	
</iframe>


<script type="text/javascript">
let iframeDom = document.getElementById("gg")
let a = 1
iframeDom.onload = function () {
    Object.prototype.toString = function (){
        return 1
    }
    iframeDom.contentWindow.test({name:1})
}
</script>

//child
<script type="text/javascript">
Object.prototype.toString = function (){
    return 2
}
let a = 2
let obj = {age:2}
function test(p) {
    console.log(obj instanceof Object)
    console.log(p instanceof Object)
    console.log(a)
}
</script>
```

#### 10.2.1.2 OrdinaryCallBindThis ( F, calleeContext, thisArgument )

æŠ½è±¡æ“ä½œ OrdinaryCallBindThis æ¥å—å‚æ•° Fï¼ˆå‡½æ•°å¯¹è±¡ï¼‰ã€calleeContextï¼ˆæ‰§è¡Œä¸Šä¸‹æ–‡ï¼‰å’Œ thisArgumentï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å¹¶è¿”å›æœªä½¿ç”¨çš„å€¼ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let thisMode be F.[[ThisMode]].
2. If thisMode is lexical, return unused.
3. Let calleeRealm be F.[[Realm]].
4. Let localEnv be the LexicalEnvironment of calleeContext.
5. If thisMode is strict, let thisValue be thisArgument.
6. Else,
    - If thisArgument is undefined or null, then
        - Let globalEnv be calleeRealm.[[GlobalEnv]].
        - Assert: globalEnv is a Global Environment Record.
        - Let thisValue be globalEnv.[[GlobalThisValue]].
    b. Else,
        - Let thisValue be ! ToObject(thisArgument).
        - NOTE: ToObject produces wrapper objects using calleeRealm.
7. Assert: localEnv is a Function Environment Record.
8. Assert: The next step never returns an abrupt completion because localEnv.[[ThisBindingStatus]] is not initialized.
9. Perform ! localEnv.BindThisValue(thisValue).
10. Return unused.

#### 10.2.1.3 Runtime Semantics: EvaluateBody

è¯­æ³•åˆ¶å¯¼çš„æ“ä½œ EvaluateBody æ¥å—å‚æ•° functionObjectï¼ˆå‡½æ•°å¯¹è±¡ï¼‰å’Œ argumentsListï¼ˆECMAScript è¯­è¨€å€¼åˆ—è¡¨ï¼‰å¹¶è¿”å›åŒ…å« ECMAScript è¯­è¨€å€¼çš„æ­£å¸¸å®Œæˆæˆ–çªç„¶å®Œæˆã€‚ å®ƒæ˜¯åœ¨ä»¥ä¸‹äº§ç”Ÿå¼ä¸Šåˆ†æ®µå®šä¹‰çš„ï¼š

FunctionBody : FunctionStatementList
1. Return ? EvaluateFunctionBody of FunctionBody with arguments functionObject and argumentsList.

ConciseBody : ExpressionBody
1. Return ? EvaluateConciseBody of ConciseBody with arguments functionObject and argumentsList.

GeneratorBody : FunctionBody
1. Return ? EvaluateGeneratorBody of GeneratorBody with arguments functionObject and argumentsList.

AsyncGeneratorBody : FunctionBody
1. Return ? EvaluateAsyncGeneratorBody of AsyncGeneratorBody with arguments functionObject and argumentsList.

AsyncFunctionBody : FunctionBody
1. Return ? EvaluateAsyncFunctionBody of AsyncFunctionBody with arguments functionObject and argumentsList.

AsyncConciseBody : ExpressionBody
1. Return ? EvaluateAsyncConciseBody of AsyncConciseBody with arguments functionObject and argumentsList.

Initializer :

    = AssignmentExpression

1. Assert: argumentsList is empty.
2. Assert: functionObject.[[ClassFieldInitializerName]] is not empty.
3. If IsAnonymousFunctionDefinition(AssignmentExpression) is true, then
    - Let value be ? NamedEvaluation of Initializer with argument functionObject.[[ClassFieldInitializerName]].
4. Else,
    - Let rhs be ? Evaluation of AssignmentExpression.
    - Let value be ? GetValue(rhs).
5. Return Completion Record { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.

>NOTE å³ä½¿å­—æ®µåˆå§‹å€¼è®¾å®šé¡¹æ„æˆå‡½æ•°è¾¹ç•Œï¼Œè°ƒç”¨ FunctionDeclarationInstantiation ä¹Ÿæ²¡æœ‰ä»»ä½•å¯è§‚å¯Ÿåˆ°çš„æ•ˆæœï¼Œå› æ­¤è¢«çœç•¥ã€‚

1. Assert: argumentsList is empty.
2. Return ? EvaluateClassStaticBlockBody of ClassStaticBlockBody with argument functionObject.

#### 10.2.1.4 OrdinaryCallEvaluateBody ( F, argumentsList )

æŠ½è±¡æ“ä½œ OrdinaryCallEvaluateBody æ¥å—å‚æ•° Fï¼ˆå‡½æ•°å¯¹è±¡ï¼‰å’Œ argumentsListï¼ˆECMAScript è¯­è¨€å€¼åˆ—è¡¨ï¼‰å¹¶è¿”å›åŒ…å« ECMAScript è¯­è¨€å€¼çš„æ­£å¸¸å®Œæˆæˆ–çªç„¶å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Return ? EvaluateBody of F.[[ECMAScriptCode]] with arguments F and argumentsList.

### 10.2.2 [[Construct]]ï¼ˆargumentsListï¼ŒnewTargetï¼‰

ECMAScript å‡½æ•°å¯¹è±¡ F çš„ [[Construct]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° argumentsListï¼ˆECMAScript è¯­è¨€å€¼åˆ—è¡¨ï¼‰å’Œ newTargetï¼ˆæ„é€ å‡½æ•°ï¼‰å¹¶è¿”å›åŒ…å« Object çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let callerContext be the running execution context.
2. Let kind be F.[[ConstructorKind]].
3. If kind is base, then
    - Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, "%Object.prototype%").
4. Let calleeContext be PrepareForOrdinaryCall(F, newTarget).
5. Assert: calleeContext is now the running execution context.
6. If kind is base, then
    - Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).
    - Let initializeResult be Completion(InitializeInstanceElements(thisArgument, F)).
    - If initializeResult is an abrupt completion, then
        - Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
        - Return ? initializeResult.
7. Let constructorEnv be the LexicalEnvironment of calleeContext.
8. Let result be Completion(OrdinaryCallEvaluateBody(F, argumentsList)).
9. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
10. If result.[[Type]] is return, then
    - If result.[[Value]] is an Object, return result.[[Value]].
    - If kind is base, return thisArgument.
    - If result.[[Value]] is not undefined, throw a TypeError exception.
11. Else, ReturnIfAbrupt(result).
12. Let thisBinding be ? constructorEnv.GetThisBinding().
13. Assert: thisBinding is an Object.
14. Return thisBinding.

### 10.2.3 OrdinaryFunctionCreateï¼ˆfunctionPrototypeï¼ŒsourceTextï¼ŒParameterListï¼ŒBodyï¼ŒthisModeï¼ŒScopeï¼‰

æŠ½è±¡æ“ä½œ OrdinaryFunctionCreate é‡‡ç”¨å‚æ•° functionPrototypeï¼ˆå¯¹è±¡ï¼‰ã€sourceTextï¼ˆUnicode ä»£ç ç‚¹åºåˆ—ï¼‰ã€ParameterListï¼ˆè§£æèŠ‚ç‚¹ï¼‰ã€Bodyï¼ˆè§£æèŠ‚ç‚¹ï¼‰ã€thisModeï¼ˆè¯æ³•-this æˆ–éè¯æ³•-thisï¼‰ã€env ï¼ˆä¸€ä¸ªç¯å¢ƒè®°å½•ï¼‰å’Œ privateEnvï¼ˆä¸€ä¸ª PrivateEnvironment Record æˆ– nullï¼‰å¹¶è¿”å›ä¸€ä¸ªå‡½æ•°å¯¹è±¡ã€‚ å®ƒç”¨äºæŒ‡å®šè¿è¡Œæ—¶åˆ›å»ºå…·æœ‰é»˜è®¤ [[Call]] å†…éƒ¨æ–¹æ³•ä¸”æ²¡æœ‰ [[Construct]] å†…éƒ¨æ–¹æ³•çš„æ–°å‡½æ•°ï¼ˆå°½ç®¡éšåå¯èƒ½ä¼šé€šè¿‡ MakeConstructor ç­‰æ“ä½œæ·»åŠ ï¼‰ã€‚ sourceText æ˜¯è¦åˆ›å»ºçš„å‡½æ•°çš„å¥æ³•å®šä¹‰çš„æºæ–‡æœ¬ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

Let internalSlotsList be the internal slots listed in Table 30.
2. Let F be OrdinaryObjectCreate(functionPrototype, internalSlotsList).
3. Set F.[[Call]] to the definition specified in 10.2.1.
4. Set F.[[SourceText]] to sourceText.
5. Set F.[[FormalParameters]] to ParameterList.
6. Set F.[[ECMAScriptCode]] to Body.
7. If the source text matched by Body is strict mode code, let Strict be true; else let Strict be false.
8. Set F.[[Strict]] to Strict.
9. If thisMode is lexical-this, set F.[[ThisMode]] to lexical.
10. Else if Strict is true, set F.[[ThisMode]] to strict.
11. Else, set F.[[ThisMode]] to global.
12. Set F.[[IsClassConstructor]] to false.
13. Set F.[[Environment]] to env.
14. Set F.[[PrivateEnvironment]] to privateEnv.
15. Set F.[[ScriptOrModule]] to GetActiveScriptOrModule().
16. Set F.[[Realm]] to the current Realm Record.
17. Set F.[[HomeObject]] to undefined.
18. Set F.[[Fields]] to a new empty List.
19. Set F.[[PrivateMethods]] to a new empty List.
20. Set F.[[ClassFieldInitializerName]] to empty.
21. Let len be the ExpectedArgumentCount of ParameterList.
22. Perform SetFunctionLength(F, len).
23. Return F.

### 10.2.4 æ·»åŠ å—é™å‡½æ•°å±æ€§-AddRestrictedFunctionProperties ( F, realm )

æŠ½è±¡æ“ä½œ AddRestrictedFunctionProperties æ¥å—å‚æ•° Fï¼ˆå‡½æ•°å¯¹è±¡ï¼‰å’Œé¢†åŸŸï¼ˆé¢†åŸŸè®°å½•ï¼‰å¹¶è¿”å›unusedã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Assert: realm.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.
2. Let thrower be realm.[[Intrinsics]].[[%ThrowTypeError%]].
3. Perform ! DefinePropertyOrThrow(F, "caller", PropertyDescriptor { [[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true }).
4. Perform ! DefinePropertyOrThrow(F, "arguments", PropertyDescriptor { [[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true }).
5. Return unused.

#### 10.2.4.1 %ThrowTypeError% ( )

æ­¤å‡½æ•°æ˜¯ %ThrowTypeError% å†…éƒ¨å¯¹è±¡ã€‚

å®ƒæ˜¯ä¸€ä¸ªåŒ¿åçš„å†…ç½®å‡½æ•°å¯¹è±¡ï¼Œä¸ºæ¯ä¸ªé¢†åŸŸå®šä¹‰ä¸€æ¬¡ã€‚

å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Throw a TypeError exception.

æ­¤å‡½æ•°çš„ [[Extensible]] å†…éƒ¨æ’æ§½çš„å€¼ä¸º falseã€‚

æ­¤å‡½æ•°çš„â€œé•¿åº¦â€å±æ€§å…·æœ‰å±æ€§ { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }ã€‚

æ­¤å‡½æ•°çš„â€œåç§°â€å±æ€§å…·æœ‰å±æ€§ { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }ã€‚


### 10.2.5 MakeConstructor ( F [ , writablePrototype [ , prototype ] ] )

æŠ½è±¡æ“ä½œ MakeConstructor æ¥å—å‚æ•° Fï¼ˆECMAScript å‡½æ•°å¯¹è±¡æˆ–å†…ç½®å‡½æ•°å¯¹è±¡ï¼‰å’Œå¯é€‰å‚æ•° writablePrototypeï¼ˆå¸ƒå°”å€¼ï¼‰å’ŒåŸå‹ï¼ˆå¯¹è±¡ï¼‰å¹¶è¿”å›æœªä½¿ç”¨çš„ã€‚ å®ƒå°† F è½¬æ¢ä¸ºæ„é€ å‡½æ•°ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If F is an ECMAScript function object, then
    - Assert: IsConstructor(F) is false.
    - Assert: F is an extensible object that does not have a "prototype" own property.
    - Set F.[[Construct]] to the definition specified in 10.2.2.
2. Else,
    - Set F.[[Construct]] to the definition specified in 10.3.2.
3. Set F.[[ConstructorKind]] to base.
4. If writablePrototype is not present, set writablePrototype to true.
5. If prototype is not present, then
    - Set prototype to OrdinaryObjectCreate(%Object.prototype%).
    - Perform ! DefinePropertyOrThrow(prototype, "constructor", PropertyDescriptor { [[Value]]: F, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: true }).
6. Perform ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: false }).
7. Return unused.

### 10.2.6 MakeClassConstructor ( F )

æŠ½è±¡æ“ä½œ MakeClassConstructor æ¥å—å‚æ•° Fï¼ˆä¸€ä¸ª ECMAScript å‡½æ•°å¯¹è±¡ï¼‰å¹¶è¿”å›unusedã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Assert: F.[[IsClassConstructor]] is false.
2. Set F.[[IsClassConstructor]] to true.
3. Return unused.

### 10.2.7 MakeMethod ( F, homeObject )

æŠ½è±¡æ“ä½œ MakeMethod æ¥å—å‚æ•° Fï¼ˆä¸€ä¸ª ECMAScript å‡½æ•°å¯¹è±¡ï¼‰å’Œ homeObjectï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰å¹¶è¿”å›æœªä½¿ç”¨çš„ã€‚ å®ƒå°† F é…ç½®ä¸ºä¸€ç§æ–¹æ³•ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Set F.[[HomeObject]] to homeObject.
2. Return unused.

### 10.2.8 DefineMethodProperty ( homeObject, key, closure, enumerable )

æŠ½è±¡æ“ä½œ DefineMethodProperty æ¥å—å‚æ•° homeObjectï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰ã€keyï¼ˆä¸€ä¸ªå±æ€§é”®æˆ–ç§æœ‰åç§°ï¼‰ã€closureï¼ˆä¸€ä¸ªå‡½æ•°å¯¹è±¡ï¼‰å’Œ enumerableï¼ˆä¸€ä¸ªå¸ƒå°”å€¼ï¼‰å¹¶è¿”å›ä¸€ä¸ª PrivateElement æˆ–æœªä½¿ç”¨çš„ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Assert: homeObject is an ordinary, extensible object with no non-configurable properties.
2. If key is a Private Name, then
    - Return PrivateElement { [[Key]]: key, [[Kind]]: method, [[Value]]: closure }.
3. Else,
    - Let desc be the PropertyDescriptor { [[Value]]: closure, [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true }.
    - Perform ! DefinePropertyOrThrow(homeObject, key, desc).
    - Return unused.

### 10.2.9 SetFunctionName ( F, name [ , prefix ] )

æŠ½è±¡æ“ä½œ SetFunctionName æ¥å—å‚æ•° Fï¼ˆå‡½æ•°å¯¹è±¡ï¼‰å’Œåç§°ï¼ˆå±æ€§é”®æˆ–ç§æœ‰åç§°ï¼‰å’Œå¯é€‰å‚æ•°å‰ç¼€ï¼ˆå­—ç¬¦ä¸²ï¼‰å¹¶è¿”å›unusedã€‚ å®ƒå‘ F æ·»åŠ ä¸€ä¸ªâ€œåç§°â€å±æ€§ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Assert: F is an extensible object that does not have a "name" own property.
2. If name is a Symbol, then
    - Let description be name's [[Description]] value.
    - If description is undefined, set name to the empty String.
    - Else, set name to the string-concatenation of "[", description, and "]".
3. Else if name is a Private Name, then
    - Set name to name.[[Description]].
4. If F has an [[InitialName]] internal slot, then
    - Set F.[[InitialName]] to name.
5. If prefix is present, then
    - Set name to the string-concatenation of prefix, the code unit 0x0020 (SPACE), and name.
    - If F has an [[InitialName]] internal slot, then
        - Optionally, set F.[[InitialName]] to name.
6. Perform ! DefinePropertyOrThrow(F, "name", PropertyDescriptor { [[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }).
7. Return unused.

### 10.2.10 SetFunctionLength ( F, length )

æŠ½è±¡æ“ä½œ SetFunctionLength æ¥å—å‚æ•° Fï¼ˆå‡½æ•°å¯¹è±¡ï¼‰å’Œé•¿åº¦ï¼ˆéè´Ÿæ•´æ•°æˆ– +âˆï¼‰å¹¶è¿”å›æœªä½¿ç”¨çš„å€¼ã€‚ å®ƒå‘ F æ·»åŠ ä¸€ä¸ªâ€œé•¿åº¦â€å±æ€§ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Assert: F is an extensible object that does not have a "length" own property.
2. Perform ! DefinePropertyOrThrow(F, "length", PropertyDescriptor { [[Value]]: ğ”½(length), [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }).
3. Return unused.

### 9.2.11 FunctionDeclarationInstantiation ( func, argumentsList )

æŠ½è±¡æ“ä½œ FunctionDeclarationInstantiation æ¥å—å‚æ•° funcï¼ˆå‡½æ•°å¯¹è±¡ï¼‰å’Œ argumentsListï¼ˆECMAScript è¯­è¨€å€¼åˆ—è¡¨ï¼‰å¹¶è¿”å›åŒ…å«unusedæ­£å¸¸å®Œæˆæˆ–çªç„¶å®Œæˆã€‚ func æ˜¯ä¸ºå…¶å»ºç«‹æ‰§è¡Œä¸Šä¸‹æ–‡çš„å‡½æ•°å¯¹è±¡ã€‚

>NOTE å½“å»ºç«‹æ‰§è¡Œä¸Šä¸‹æ–‡ä»¥è¯„ä¼° ECMAScript å‡½æ•°æ—¶ï¼Œå°†åˆ›å»ºä¸€ä¸ªæ–°çš„å‡½æ•°ç¯å¢ƒè®°å½•ï¼Œå¹¶åœ¨è¯¥ç¯å¢ƒè®°å½•ä¸­å®ä¾‹åŒ–æ¯ä¸ªå½¢å¼å‚æ•°çš„ç»‘å®šã€‚ å‡½æ•°ä½“ä¸­çš„æ¯ä¸ªå£°æ˜ä¹Ÿè¢«å®ä¾‹åŒ–ã€‚ å¦‚æœå‡½æ•°çš„å½¢å¼å‚æ•°ä¸åŒ…å«ä»»ä½•é»˜è®¤å€¼åˆå§‹å€¼è®¾å®šé¡¹ï¼Œåˆ™ä¸»ä½“å£°æ˜å°†åœ¨ä¸å‚æ•°ç›¸åŒçš„ç¯å¢ƒè®°å½•ä¸­å®ä¾‹åŒ–ã€‚ å¦‚æœå­˜åœ¨é»˜è®¤å€¼å‚æ•°åˆå§‹å€¼è®¾å®šé¡¹ï¼Œåˆ™ä¸ºä¸»ä½“å£°æ˜åˆ›å»ºç¬¬äºŒä¸ªç¯å¢ƒè®°å½•ã€‚ å½¢å¼å‚æ•°å’Œå‡½æ•°è¢«åˆå§‹åŒ–ä¸º FunctionDeclarationInstantiation çš„ä¸€éƒ¨åˆ†ã€‚ æ‰€æœ‰å…¶ä»–ç»‘å®šéƒ½åœ¨å‡½æ•°ä½“çš„è¯„ä¼°æœŸé—´åˆå§‹åŒ–ã€‚

1. Let calleeContext be the running execution context.
2. Let code be func.[[ECMAScriptCode]].
3. Let strict be func.[[Strict]].
4. Let formals be func.[[FormalParameters]].
5. Let parameterNames be the BoundNames of formals.
6. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.
7. Let simpleParameterList be IsSimpleParameterList of formals.
8. Let hasParameterExpressions be ContainsExpression of formals.
9. Let varNames be the VarDeclaredNames of code.
10. Let varDeclarations be the VarScopedDeclarations of code.
11. Let lexicalNames be the LexicallyDeclaredNames of code.
12. Let functionNames be a new empty List.
13. Let functionsToInitialize be a new empty List.
14. For each element d of varDeclarations, in reverse List order, do
    - If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then
        1. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration.
        2. Let fn be the sole element of the BoundNames of d.
        3. If fn is not an element of functionNames, then
            - Insert fn as the first element of functionNames.
            - NOTE: If there are multiple function declarations for the same name, the last declaration is used.
            - Insert d as the first element of functionsToInitialize.
15. Let argumentsObjectNeeded be true.
16. If func.[[ThisMode]] is lexical, then
    - NOTE: Arrow functions never have an arguments object.
    - Set argumentsObjectNeeded to false.
17. Else if "arguments" is an element of parameterNames, then
    - Set argumentsObjectNeeded to false.
18. Else if hasParameterExpressions is false, then
    - If "arguments" is an element of functionNames or if "arguments" is an element of lexicalNames, then
i. Set argumentsObjectNeeded to false.
19. If strict is true or if hasParameterExpressions is false, then
    - NOTE: Only a single Environment Record is needed for the parameters, since calls to eval in strict mode code cannot create new bindings which are visible outside of the eval.
    - Let env be the LexicalEnvironment of calleeContext.
20. Else,
    - NOTE: A separate Environment Record is needed to ensure that bindings created by direct eval calls in the formal parameter list are outside the environment where parameters are declared.
    - Let calleeEnv be the LexicalEnvironment of calleeContext.
    - Let env be NewDeclarativeEnvironment(calleeEnv).
    - Assert: The VariableEnvironment of calleeContext is calleeEnv.
    - Set the LexicalEnvironment of calleeContext to env.
21. For each String paramName of parameterNames, do
    - Let alreadyDeclared be ! env.HasBinding(paramName).
    - NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.
    - If alreadyDeclared is false, then
        1. Perform ! env.CreateMutableBinding(paramName, false).
        2. If hasDuplicates is true, then
            - Perform ! env.InitializeBinding(paramName, undefined).
22. If argumentsObjectNeeded is true, then
    - If strict is true or if simpleParameterList is false, then
        1. Let ao be CreateUnmappedArgumentsObject(argumentsList).
    - Else,
        1. NOTE: A mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.
        2. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, env).
    - If strict is true, then
        1. Perform ! env.CreateImmutableBinding("arguments", false).
        2. NOTE: In strict mode code early errors prevent attempting to assign to this binding, so its mutability is not observable.
    - Else,
        1. Perform ! env.CreateMutableBinding("arguments", false).
    - Perform ! env.InitializeBinding("arguments", ao).
    - Let parameterBindings be the list-concatenation of parameterNames and Â« "arguments" Â».
23. Else,
    - Let parameterBindings be parameterNames.
24. Let iteratorRecord be CreateListIteratorRecord(argumentsList).
25. If hasDuplicates is true, then
    - Perform ? IteratorBindingInitialization of formals with arguments iteratorRecord and undefined.
26. Else,
    - Perform ? IteratorBindingInitialization of formals with arguments iteratorRecord and env.
27. If hasParameterExpressions is false, then
    - NOTE: Only a single Environment Record is needed for the parameters and top-level vars.
    - Let instantiatedVarNames be a copy of the List parameterBindings.
    - For each element n of varNames, do
        1. If n is not an element of instantiatedVarNames, then
            - Append n to instantiatedVarNames.
            - Perform ! env.CreateMutableBinding(n, false).
            - Perform ! env.InitializeBinding(n, undefined).
    - Let varEnv be env.
28. Else,
    - NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.
    - Let varEnv be NewDeclarativeEnvironment(env).
    - Set the VariableEnvironment of calleeContext to varEnv.
    - Let instantiatedVarNames be a new empty List.
    - For each element n of varNames, do
        1. If n is not an element of instantiatedVarNames, then
            - Append n to instantiatedVarNames.
            - Perform ! varEnv.CreateMutableBinding(n, false).
            - If n is not an element of parameterBindings or if n is an element of functionNames, let initialValue be undefined.
            - Else,
                1 Let initialValue be ! env.GetBindingValue(n, false).
            - Perform ! varEnv.InitializeBinding(n, initialValue).
            - NOTE: A var with the same name as a formal parameter initially has the same value as the corresponding initialized parameter.
29. NOTE: Annex B.3.2.1 adds additional steps at this point.
30. If strict is false, then
    - Let lexEnv be NewDeclarativeEnvironment(varEnv).
    - NOTE: Non-strict functions use a separate Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.
31. Else, let lexEnv be varEnv.
32. Set the LexicalEnvironment of calleeContext to lexEnv.
33. Let lexDeclarations be the LexicallyScopedDeclarations of code.
34. For each element d of lexDeclarations, do
    - NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.
    - For each element dn of the BoundNames of d, do
        1. If IsConstantDeclaration of d is true, then
            - Perform ! lexEnv.CreateImmutableBinding(dn, true).
        2. Else,
            - Perform ! lexEnv.CreateMutableBinding(dn, false).
35. Let privateEnv be the PrivateEnvironment of calleeContext.
36. For each Parse Node f of functionsToInitialize, do
    - Let fn be the sole element of the BoundNames of f.
    - Let fo be InstantiateFunctionObject of f with arguments lexEnv and privateEnv.
    - Perform ! varEnv.SetMutableBinding(fn, fo, false).
37. Return unused.


```
//ä¸éœ€è¦argumentsçš„æƒ…å†µ
function f(arguments, a){console.log(arguments)}


//argumentsçš„å‚æ•°å€¼å—å®å‚å½±å“å’Œå½¢å‚æ— å…³æ‰€ä»¥f1()æ‰“å°ä¸å‡ºæ¥æ•°æ®

function f(p1,p2){arguments[1] = 3; console.log(arguments) }
f(1, 2)
//å¯¹äºå¤æ‚å‚æ•°ä¹Ÿå°±ç›¸å½“äºä¸¥æ ¼æ¨¡å¼ï¼Œé€šè¿‡ CreateUnmappedArgumentsObjectè¿”å›ä¸€ä¸ªæ™®é€šå¯¹è±¡è€Œä¸æ˜¯CreateMappedArgumentsObjectçš„å¼‚è´¨å¯¹è±¡
function f1(p1=1,p2=2){arguments[1] = 3; console.log(arguments) }
f1()        
f1(3,4)
```
