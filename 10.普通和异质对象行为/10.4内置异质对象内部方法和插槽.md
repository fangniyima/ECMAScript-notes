## 10.4å†…ç½®å¼‚è´¨å¯¹è±¡å†…éƒ¨æ–¹æ³•å’Œæ’æ§½

æ­¤è§„èŒƒå®šä¹‰äº†å‡ ç§å†…ç½®çš„å¼‚è´¨å¯¹è±¡ã€‚é™¤äº†ä¸€äº›ç‰¹æ®Šæƒ…å†µå¤–ï¼Œè¿™äº›å¯¹è±¡çš„è¡Œä¸ºé€šå¸¸ä¸æ™®é€šå¯¹è±¡ç›¸ä¼¼ã€‚ä»¥ä¸‹å¼‚è´¨å¯¹è±¡ä½¿ç”¨æ™®é€šå¯¹è±¡å†…éƒ¨æ–¹æ³•ï¼Œé™¤éä¸‹é¢å¦æœ‰æ˜ç¡®è§„å®šï¼š

### 10.4.1 Bound Function Exotic Objects

ç»‘å®šå‡½æ•°å¼‚è´¨å¯¹è±¡æ˜¯åŒ…è£…å¦ä¸€ä¸ªå‡½æ•°å¯¹è±¡çš„å¼‚è´¨å¯¹è±¡ã€‚ç»‘å®šå‡½æ•°å¼‚è´¨å¯¹è±¡æ˜¯å¯è°ƒç”¨çš„ï¼ˆå®ƒæœ‰ä¸€ä¸ª[[Call]]å†…éƒ¨æ–¹æ³•ï¼Œä¹Ÿå¯èƒ½æœ‰ä¸€ä¸ª[[Construct]]å†…éƒ¨æ–¹æ³•ï¼‰ã€‚è°ƒç”¨ç»‘å®šå‡½æ•°å¼‚è´¨å¯¹è±¡é€šå¸¸ä¼šå¯¼è‡´è°ƒç”¨å…¶åŒ…è£…å‡½æ•°ã€‚

å¦‚æœä¸€ä¸ªå¯¹è±¡çš„[[Call]]å’Œï¼ˆå¦‚æœé€‚ç”¨ï¼‰[[Construct]]å†…éƒ¨æ–¹æ³•ä½¿ç”¨ä»¥ä¸‹å®ç°ï¼Œå¹¶ä¸”å…¶å…¶ä»–åŸºæœ¬å†…éƒ¨æ–¹æ³•ä½¿ç”¨10.1ä¸­çš„å®šä¹‰ï¼Œåˆ™è¯¥å¯¹è±¡å°±æ˜¯ç»‘å®šå‡½æ•°å¼‚è´¨å¯¹è±¡ã€‚è¿™äº›æ–¹æ³•å®‰è£…åœ¨BoundFunctionCreateä¸­ã€‚

ç»‘å®šå‡½æ•°å¼‚è´¨å¯¹è±¡æ²¡æœ‰è¡¨30ä¸­åˆ—å‡ºçš„ECMAScriptå‡½æ•°å¯¹è±¡çš„å†…éƒ¨æ§½ã€‚ç›¸åï¼Œé™¤äº†[[Prototype]]å’Œ[[Extensible]]ä¹‹å¤–ï¼Œå®ƒä»¬è¿˜æœ‰è¡¨31ä¸­åˆ—å‡ºçš„å†…éƒ¨æ’æ§½ã€‚

Table 31: Internal Slots of Bound Function Exotic Objects

|Internal Slot|	Type|	Description|
|----|----|----|
[[BoundTargetFunction]]	|Callable Object|åŒ…è£…çš„å‡½æ•°å¯¹è±¡ã€‚
[[BoundThis]]|	Any	|è°ƒç”¨åŒ…è£…å‡½æ•°æ—¶å§‹ç»ˆä½œä¸º this å€¼ä¼ é€’çš„å€¼ã€‚
[[BoundArguments]]|	List of Any|ä¸€ä¸ªå€¼åˆ—è¡¨ï¼Œå…¶å…ƒç´ ç”¨ä½œå¯¹åŒ…è£…å‡½æ•°çš„ä»»ä½•è°ƒç”¨çš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚

#### 10.4.1.1 [[Call]] ( thisArgument, argumentsList )

ç»‘å®šå‡½æ•°å¼‚è´¨å¯¹è±¡ F çš„ [[Call]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° thisArgumentï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å’Œ argumentsListï¼ˆECMAScript è¯­è¨€å€¼åˆ—è¡¨ï¼‰å¹¶è¿”å›åŒ…å« ECMAScript è¯­è¨€å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let target be F.[[BoundTargetFunction]].
2. Let boundThis be F.[[BoundThis]].
3. Let boundArgs be F.[[BoundArguments]].
4. Let args be the list-concatenation of boundArgs and argumentsList.
5. Return ? Call(target, boundThis, args).

#### 10.4.1.2 [[Construct]] ( argumentsList, newTarget )

ç»‘å®šå‡½æ•°å¼‚è´¨å¯¹è±¡ F çš„ [[Construct]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° argumentsListï¼ˆECMAScript è¯­è¨€å€¼åˆ—è¡¨ï¼‰å’Œ newTargetï¼ˆæ„é€ å‡½æ•°ï¼‰å¹¶è¿”å›åŒ…å« Object çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let target be F.[[BoundTargetFunction]].
2. Assert: IsConstructor(target) is true.
3. Let boundArgs be F.[[BoundArguments]].
4. Let args be the list-concatenation of boundArgs and argumentsList.
5. If SameValue(F, newTarget) is true, set newTarget to target.
6. Return ? Construct(target, args, newTarget).

#### 10.4.1.3 BoundFunctionCreate ( targetFunction, boundThis, boundArgs )

æŠ½è±¡æ“ä½œ BoundFunctionCreate é‡‡ç”¨å‚æ•° targetFunctionï¼ˆä¸€ä¸ªå‡½æ•°å¯¹è±¡ï¼‰ã€boundThisï¼ˆä¸€ä¸ª ECMAScript è¯­è¨€å€¼ï¼‰å’Œ boundArgsï¼ˆä¸€ä¸ª ECMAScript è¯­è¨€å€¼åˆ—è¡¨ï¼‰å¹¶è¿”å›åŒ…å«å‡½æ•°å¯¹è±¡çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒç”¨äºæŒ‡å®šæ–°ç»‘å®šå‡½æ•°å¼‚è´¨å¯¹è±¡çš„åˆ›å»ºã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let proto be ? targetFunction.[[GetPrototypeOf]]().
2. Let internalSlotsList be the list-concatenation of Â« [[Prototype]], [[Extensible]] Â» and the internal slots listed in Table 31.
3. Let obj be MakeBasicObject(internalSlotsList).
4. Set obj.[[Prototype]] to proto.
5. Set obj.[[Call]] as described in 10.4.1.1.
6. If IsConstructor(targetFunction) is true, then
    - Set obj.[[Construct]] as described in 10.4.1.2.
7. Set obj.[[BoundTargetFunction]] to targetFunction.
8. Set obj.[[BoundThis]] to boundThis.
9. Set obj.[[BoundArguments]] to boundArgs.
10. Return obj.

### 10.4.2 Array Exotic Objects

æ•°ç»„å¯¹è±¡æ˜¯å¯¹æ•°ç»„ç´¢å¼•å±æ€§é”®è¿›è¡Œç‰¹æ®Šå¤„ç†çš„å¼‚è´¨å¯¹è±¡ï¼ˆè§6.1.7ï¼‰ã€‚å±æ€§åä¸ºæ•°ç»„ç´¢å¼•çš„å±æ€§ä¹Ÿç§°ä¸ºå…ƒç´ ã€‚æ¯ä¸ªæ•°ç»„å¯¹è±¡éƒ½æœ‰ä¸€ä¸ªä¸å¯é…ç½®çš„â€œlengthâ€å±æ€§ï¼Œå…¶å€¼å§‹ç»ˆæ˜¯æ•°å­¦å€¼å°äº2<sup>32</sup>çš„éè´Ÿæ•´æ•°ã€‚â€œlengthâ€å±æ€§çš„å€¼åœ¨æ•°å€¼ä¸Šå¤§äºåç§°ä¸ºæ•°ç»„ç´¢å¼•çš„æ¯ä¸ªè‡ªèº«å±æ€§çš„åç§°ï¼›æ¯å½“åˆ›å»ºæˆ–æ›´æ”¹æ•°ç»„å¯¹è±¡çš„è‡ªèº«å±æ€§æ—¶ï¼Œå…¶ä»–å±æ€§éƒ½ä¼šæ ¹æ®éœ€è¦è¿›è¡Œè°ƒæ•´ä»¥ä¿æŒæ­¤ä¸å˜é‡ã€‚å…·ä½“åœ°è¯´ï¼Œæ¯å½“æ·»åŠ ä¸€ä¸ªåä¸ºæ•°ç»„ç´¢å¼•çš„è‡ªèº«å±æ€§æ—¶ï¼Œâ€œlengthâ€å±æ€§çš„å€¼å°†æ›´æ”¹ä¸ºæ¯”è¯¥æ•°ç»„ç´¢å¼•çš„æ•°å€¼å¤š1ä¸ªå€¼ï¼›æ¯å½“â€œlengthâ€å±æ€§çš„å€¼å‘ç”Ÿæ›´æ”¹æ—¶ï¼Œå°†åˆ é™¤åç§°ä¸ºæ•°ç»„ç´¢å¼•ä¸”å…¶å€¼ä¸å°äºæ–°é•¿åº¦çš„æ¯ä¸ªè‡ªå·±çš„å±æ€§ã€‚æ­¤çº¦æŸä»…é€‚ç”¨äºæ•°ç»„å¯¹è±¡çš„è‡ªèº«å±æ€§ï¼Œä¸å—å¯èƒ½ä»å…¶åŸå‹ç»§æ‰¿çš„â€œlengthâ€æˆ–æ•°ç»„ç´¢å¼•å±æ€§çš„å½±å“ã€‚

>NOTE å½“ä¸”ä»…å½“ToStringï¼ˆToUint32ï¼ˆPï¼‰ï¼‰ç­‰äºPä¸”ToUint32ï¼ˆPï¼‰ä¸ğ”½ï¼ˆ2<sup>32</sup>-1ï¼‰çš„å€¼ä¸åŒæ—¶ï¼Œå­—ç¬¦ä¸²å±æ€§åPæ˜¯æ•°ç»„ç´¢å¼•ã€‚

å¦‚æœä¸€ä¸ªå¯¹è±¡çš„[[DefineOwnProperty]]å†…éƒ¨æ–¹æ³•ä½¿ç”¨ä»¥ä¸‹å®ç°ï¼Œè€Œå®ƒçš„å…¶ä»–åŸºæœ¬å†…éƒ¨æ–¹æ³•ä½¿ç”¨10.1ä¸­çš„å®šä¹‰ï¼Œåˆ™è¯¥å¯¹è±¡å°±æ˜¯æ•°ç»„å¼‚è´¨å¯¹è±¡ï¼ˆæˆ–ç®€å•åœ°è¯´ï¼Œæ•°ç»„å¯¹è±¡ï¼‰ã€‚è¿™äº›æ–¹æ³•å®‰è£…åœ¨ArrayCreateä¸­ã€‚

#### 10.4.2.1 [[DefineOwnProperty]] ( P, Desc )

å¥‡å¼‚æ•°ç»„å¯¹è±¡ A çš„ [[DefineOwnProperty]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å’Œ Descï¼ˆå±æ€§æè¿°ç¬¦ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is "length", then
    - Return ? ArraySetLength(A, Desc).
2. Else if P is an array index, then
    - Let lengthDesc be OrdinaryGetOwnProperty(A, "length").
    - Assert: IsDataDescriptor(lengthDesc) is true.
    - Assert: lengthDesc.[[Configurable]] is false.
    - Let length be lengthDesc.[[Value]].
    - Assert: length is a non-negative integral Number.
    - Let index be ! ToUint32(P).
    - If index â‰¥ length and lengthDesc.[[Writable]] is false, return false.
    - Let succeeded be ! OrdinaryDefineOwnProperty(A, P, Desc).
        1. If succeeded is false, return false.
    - If index â‰¥ length, then
        1. Set lengthDesc.[[Value]] to index + 1ğ”½.
        2. Set succeeded to ! OrdinaryDefineOwnProperty(A, "length", lengthDesc).
        3. Assert: succeeded is true.
    - Return true.
3. Return ? OrdinaryDefineOwnProperty(A, P, Desc).

```
let arr = []
arr.age =18
```

#### 10.4.2.2 ArrayCreate ( length [ , proto ] )

æŠ½è±¡æ“ä½œ ArrayCreate æ¥å—å‚æ•° lengthï¼ˆä¸€ä¸ªéè´Ÿæ•´æ•°ï¼‰å’Œå¯é€‰å‚æ•° protoï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰ï¼Œå¹¶è¿”å›ä¸€ä¸ªåŒ…å« Array å¥‡å¼‚å¯¹è±¡çš„æ­£å¸¸å®Œæˆæˆ–ä¸€ä¸ª throw å®Œæˆã€‚ å®ƒç”¨äºæŒ‡å®šåˆ›å»ºæ–°æ•°ç»„ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If length > 2<sup>32</sup> - 1, throw a RangeError exception.
2. If proto is not present, set proto to %Array.prototype%.
3. Let A be MakeBasicObject(Â« [[Prototype]], [[Extensible]] Â»).
4. Set A.[[Prototype]] to proto.
5. Set A.[[DefineOwnProperty]] as specified in 10.4.2.1.
6. Perform ! OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor { [[Value]]: ğ”½(length), [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
7. Return A.

#### 10.4.2.3 ArraySpeciesCreate ( originalArray, length )

æŠ½è±¡æ“ä½œ ArraySpeciesCreate é‡‡ç”¨å‚æ•° originalArrayï¼ˆå¯¹è±¡ï¼‰å’Œé•¿åº¦ï¼ˆéè´Ÿæ•´æ•°ï¼‰å¹¶è¿”å›åŒ…å«å¯¹è±¡çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒç”¨äºæŒ‡å®šä½¿ç”¨ä» originalArray æ´¾ç”Ÿçš„æ„é€ å‡½æ•°åˆ›å»ºæ–°æ•°ç»„æˆ–ç±»ä¼¼å¯¹è±¡ã€‚ å®ƒä¸å¼ºåˆ¶æ„é€ å‡½æ•°è¿”å›æ•°ç»„ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let isArray be ? IsArray(originalArray).
2. If isArray is false, return ? ArrayCreate(length).
3. Let C be ? Get(originalArray, "constructor").
4. If IsConstructor(C) is true, then
    - Let thisRealm be the current Realm Record.
    - Let realmC be ? GetFunctionRealm(C).
    - If thisRealm and realmC are not the same Realm Record, then
        1. If SameValue(C, realmC.[[Intrinsics]].[[%Array%]]) is true, set C to undefined.
5. If C is an Object, then
    - Set C to ? Get(C, @@species).
    - If C is null, set C to undefined.
6. If C is undefined, return ? ArrayCreate(length).
7. If IsConstructor(C) is false, throw a TypeError exception.
8. Return ? Construct(C, Â« ğ”½(length) Â»).

>NOTE å¦‚æœ originalArray æ˜¯ä½¿ç”¨æ ‡å‡†å†…ç½® Array æ„é€ å‡½æ•°ä¸ºä¸æ˜¯æ­£åœ¨è¿è¡Œçš„æ‰§è¡Œä¸Šä¸‹æ–‡é¢†åŸŸçš„é¢†åŸŸåˆ›å»ºçš„ï¼Œé‚£ä¹ˆå°†ä½¿ç”¨æ­£åœ¨è¿è¡Œçš„æ‰§è¡Œä¸Šä¸‹æ–‡é¢†åŸŸåˆ›å»ºä¸€ä¸ªæ–°æ•°ç»„ã€‚ è¿™ä¿æŒäº†ä¸ Web æµè§ˆå™¨çš„å…¼å®¹æ€§ï¼Œè¿™äº›æµè§ˆå™¨åœ¨å†å²ä¸Šå¯¹ç°åœ¨ä½¿ç”¨ ArraySpeciesCreate å®šä¹‰çš„ Array.prototype æ–¹æ³•å…·æœ‰è¿™ç§è¡Œä¸ºã€‚

#### 10.4.2.4 ArraySetLength ( A, Desc )

æŠ½è±¡æ“ä½œ ArraySetLength æ¥å—å‚æ•° Aï¼ˆæ•°ç»„ï¼‰å’Œ Descï¼ˆå±æ€§æè¿°ç¬¦ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If Desc does not have a [[Value]] field, then
    - Return ! OrdinaryDefineOwnProperty(A, "length", Desc).
2. Let newLenDesc be a copy of Desc.
3. Let newLen be ? ToUint32(Desc.[[Value]]).
4. Let numberLen be ? ToNumber(Desc.[[Value]]).
5. If SameValueZero(newLen, numberLen) is false, throw a RangeError exception.
6. Set newLenDesc.[[Value]] to newLen.
7. Let oldLenDesc be OrdinaryGetOwnProperty(A, "length").
8. Assert: IsDataDescriptor(oldLenDesc) is true.
9. Assert: oldLenDesc.[[Configurable]] is false.
10. Let oldLen be oldLenDesc.[[Value]].
11. If newLen â‰¥ oldLen, then
    - Return ! OrdinaryDefineOwnProperty(A, "length", newLenDesc).
12. If oldLenDesc.[[Writable]] is false, return false.
13. If newLenDesc does not have a [[Writable]] field or newLenDesc.[[Writable]] is true, let newWritable be true.
14. Else,
    - NOTE: Setting the [[Writable]] attribute to false is deferred in case any elements cannot be deleted.
    - Let newWritable be false.
    - Set newLenDesc.[[Writable]] to true.
15. Let succeeded be ! OrdinaryDefineOwnProperty(A, "length", newLenDesc).
16. If succeeded is false, return false.
17. For each own property key P of A that is an array index, whose numeric value is greater than or equal to newLen, in descending numeric index order, do
    - Let deleteSucceeded be ! A.[[Delete]](P).
    - If deleteSucceeded is false, then
        1. Set newLenDesc.[[Value]] to ! ToUint32(P) + 1ğ”½.
        2. If newWritable is false, set newLenDesc.[[Writable]] to false.
        3. Perform ! OrdinaryDefineOwnProperty(A, "length", newLenDesc).
        4. Return false.
18. If newWritable is false, then
    - Set succeeded to ! OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor { [[Writable]]: false }).
    - Assert: succeeded is true.
19. Return true.

>NOTE åœ¨æ­¥éª¤3å’Œ4ä¸­ï¼Œå¦‚æœDesc.[[Value]]æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œé‚£ä¹ˆå®ƒçš„valueOfæ–¹æ³•å°†è¢«è°ƒç”¨ä¸¤æ¬¡ã€‚è¿™æ˜¯ä»æœ¬è§„èŒƒç¬¬äºŒç‰ˆå¼€å§‹æŒ‡å®šçš„é—ç•™è¡Œä¸ºã€‚

### 10.4.3 String Exotic Objects

å­—ç¬¦ä¸²å¯¹è±¡æ˜¯ä¸€ä¸ªå¼‚è´¨å¯¹è±¡ï¼Œå®ƒå°è£…å­—ç¬¦ä¸²å€¼å¹¶å…¬å¼€ä¸å­—ç¬¦ä¸²å€¼çš„å„ä¸ªä»£ç å•å…ƒå…ƒç´ ç›¸å¯¹åº”çš„è™šæ‹Ÿæ•´æ•°ç´¢å¼•æ•°æ®å±æ€§ã€‚å­—ç¬¦ä¸²å¼‚è´¨å¯¹è±¡æ€»æ˜¯æœ‰ä¸€ä¸ªåä¸ºâ€œlengthâ€çš„æ•°æ®å±æ€§ï¼Œå…¶å€¼æ˜¯å°è£…çš„å­—ç¬¦ä¸²å€¼ä¸­çš„ä»£ç å•å…ƒå…ƒç´ æ•°ã€‚ä»£ç å•å…ƒæ•°æ®å±æ€§(6.1.7)å’Œâ€œlengthâ€å±æ€§éƒ½æ˜¯ä¸å¯å†™å’Œä¸å¯é…ç½®çš„ã€‚

å¦‚æœä¸€ä¸ªå¯¹è±¡çš„[[GetOwnProperty]]ã€[[DefineOwnProperty]]å’Œ[[OwnPropertyKeys]]çš„å†…éƒ¨æ–¹æ³•ä½¿ç”¨ä»¥ä¸‹å®ç°ï¼Œè€Œå®ƒçš„å…¶ä»–åŸºæœ¬å†…éƒ¨æ–¹æ³•ä½¿ç”¨10.1ä¸­çš„å®šä¹‰ï¼Œåˆ™è¯¥å¯¹è±¡å°±æ˜¯å­—ç¬¦ä¸²å¼‚è´¨å¯¹è±¡ï¼ˆæˆ–ç®€å•åœ°è¯´ï¼Œå­—ç¬¦ä¸²å¯¹è±¡ï¼‰ã€‚è¿™äº›æ–¹æ³•å®‰è£…åœ¨StringCreateä¸­ã€‚

å­—ç¬¦ä¸²å¼‚è´¨å¯¹è±¡ä¸æ™®é€šå¯¹è±¡å…·æœ‰ç›¸åŒçš„å†…éƒ¨æ§½ã€‚å®ƒä»¬è¿˜æœ‰ä¸€ä¸ª[[StringData]]å†…éƒ¨æ’æ§½ã€‚

#### 10.4.3.1 [[GetOwnProperty]] ( P )

å½“ä½¿ç”¨å±æ€§é”®Pè°ƒç”¨å­—ç¬¦ä¸²å¼‚è´¨å¯¹è±¡Sçš„[[GetOwnProperty]]å†…éƒ¨æ–¹æ³•æ—¶ï¼Œå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let desc be OrdinaryGetOwnProperty(S, P).
2. If desc is not undefined, return desc.
3. Return StringGetOwnProperty(S, P).

```
//ç¬¬ä¸‰æ­¥æ˜¯ä½¿ç”¨substringè·å–çš„
```

#### 10.4.3.2 [[DefineOwnProperty]] ( P, Desc )

String å¼‚è´¨å¯¹è±¡ S çš„ [[DefineOwnProperty]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å’Œ Descï¼ˆå±æ€§æè¿°ç¬¦ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let stringDesc be StringGetOwnProperty(S, P).
2. If stringDesc is not undefined, then
    - Let extensible be S.[[Extensible]].
    - Return IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc).
3. Return ! OrdinaryDefineOwnProperty(S, P, Desc).

```
const object1 = new String(123)

const descriptor1 = Object.getOwnPropertyDescriptor(object1, '0');

const descriptor1 = Object.getOwnPropertyDescriptor(object1, '3');

console.log(descriptor1);
```

#### 10.4.3.3 [[OwnPropertyKeys]] ( )

String å¼‚è´¨å¯¹è±¡ O çš„ [[OwnPropertyKeys]] å†…éƒ¨æ–¹æ³•ä¸æ¥å—ä»»ä½•å‚æ•°ï¼Œå¹¶è¿”å›åŒ…å«å±æ€§é”®åˆ—è¡¨çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let keys be a new empty List.
2. Let str be O.[[StringData]].
3. Assert: str is a String.
4. Let len be the length of str.
5. For each integer i such that 0 â‰¤ i < len, in ascending order, do
    - Append ! ToString(ğ”½(i)) to keys.
6. For each own property key P of O such that P is an array index and ! ToIntegerOrInfinity(P) â‰¥ len, in ascending numeric index order, do
    - Append P to keys.
7. For each own property key P of O such that P is a String and P is not an array index, in ascending chronological order of property creation, do
    - Append P to keys.
8. For each own property key P of O such that P is a Symbol, in ascending chronological order of property creation, do
    - Append P to keys.
9. Return keys.

#### 10.4.3.4 StringCreate ( value, prototype )

æŠ½è±¡æ“ä½œ StringCreate æ¥å—å‚æ•°å€¼ï¼ˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼‰å’ŒåŸå‹ï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰å¹¶è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²å¼‚è´¨å¯¹è±¡ã€‚ å®ƒç”¨äºæŒ‡å®šåˆ›å»ºæ–°çš„ String å¼‚è´¨å¯¹è±¡ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let S be MakeBasicObject(Â« [[Prototype]], [[Extensible]], [[StringData]] Â»).
2. Set S.[[Prototype]] to prototype.
3. Set S.[[StringData]] to value.
4. Set S.[[GetOwnProperty]] as specified in 10.4.3.1.
5. Set S.[[DefineOwnProperty]] as specified in 10.4.3.2.
6. Set S.[[OwnPropertyKeys]] as specified in 10.4.3.3.
7. Let length be the length of value.
8. Perform ! DefinePropertyOrThrow(S, "length", PropertyDescriptor { [[Value]]: ğ”½(length), [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).
9. Return S.

#### 10.4.3.5 StringGetOwnProperty ( S, P )

æŠ½è±¡æ“ä½œ StringGetOwnProperty æ¥å—å‚æ•° Sï¼ˆå…·æœ‰ [[StringData]] å†…éƒ¨æ§½çš„å¯¹è±¡ï¼‰å’Œ Pï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›å±æ€§æè¿°ç¬¦æˆ–æœªå®šä¹‰ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is not a String, return undefined.
2. Let index be CanonicalNumericIndexString(P).
3. If index is undefined, return undefined.
4. If IsIntegralNumber(index) is false, return undefined.
5. If index is -0ğ”½, return undefined.
6. Let str be S.[[StringData]].
7. Assert: str is a String.
8. Let len be the length of str.
9. If â„(index) < 0 or len â‰¤ â„(index), return undefined.
10. Let resultStr be the substring of str from â„(index) to â„(index) + 1.
11. Return the PropertyDescriptor { [[Value]]: resultStr, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }.

### 10.4.4 Arguments Exotic Objects

å¤§å¤šæ•°ECMAScriptå‡½æ•°ä½¿argumentså¯¹è±¡å¯¹å…¶ä»£ç å¯ç”¨ã€‚æ ¹æ®å‡½æ•°å®šä¹‰çš„ç‰¹æ€§ï¼Œå®ƒçš„argumentså¯¹è±¡å¯ä»¥æ˜¯æ™®é€šå¯¹è±¡ï¼Œä¹Ÿå¯ä»¥æ˜¯argumentså¼‚è´¨å¯¹è±¡ã€‚å‚æ•°å¼‚è´¨å¯¹è±¡æ˜¯ä¸€ä¸ªå¼‚è´¨å¯¹è±¡ï¼Œå…¶æ•°ç»„ç´¢å¼•å±æ€§æ˜ å°„åˆ°è°ƒç”¨å…¶å…³è”ECMAScriptå‡½æ•°çš„å½¢å¼å‚æ•°ç»‘å®šã€‚

å¦‚æœä¸€ä¸ªå¯¹è±¡çš„å†…éƒ¨æ–¹æ³•ä½¿ç”¨ä»¥ä¸‹å®ç°ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€ä¸ªå‚æ•°å¼‚è´¨å¯¹è±¡ï¼Œè¿™é‡Œæ²¡æœ‰æŒ‡å®šçš„æ–¹æ³•ä½¿ç”¨9.1ä¸­çš„å®ç°ã€‚è¿™äº›æ–¹æ³•å®‰è£…åœ¨CreateMappedArgumentsObjectä¸­ã€‚

>NOTE1 å½“CreateUnmappedArgumentsObjectåˆ†ç»„åˆ°è¿™ä¸ªå­å¥ä¸­æ—¶ï¼Œå®ƒåˆ›å»ºä¸€ä¸ªæ™®é€šå¯¹è±¡ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå‚æ•°å¼‚è´¨å¯¹è±¡ã€‚


å‚æ•°å¼‚è´¨å¯¹è±¡å’Œæ™®é€šå¯¹è±¡æœ‰ç›¸åŒçš„å†…éƒ¨æ§½ã€‚å®ƒä»¬è¿˜æœ‰ä¸€ä¸ª[[ParameterMap]]å†…éƒ¨æ’æ§½ã€‚æ™®é€šå‚æ•°å¯¹è±¡è¿˜æœ‰ä¸€ä¸ª[[ParameterMap]]å†…éƒ¨æ§½ï¼Œå…¶å€¼å§‹ç»ˆä¸ºundefinedã€‚å¯¹äºæ™®é€šå‚æ•°å¯¹è±¡ï¼Œ[[ParameterMap]]å†…éƒ¨æ§½ä»…ç”±Object.prototype.toStringï¼ˆ20.1.3.6ï¼‰ä»¥è¯†åˆ«å®ƒä»¬ã€‚


>NOTE2 å‚æ•°å¼‚è´¨å¯¹è±¡çš„æ•´å‹ç´¢å¼•æ•°æ®å±æ€§ï¼Œå…¶æ•°å­—åç§°å€¼å°äºç›¸åº”å‡½æ•°å¯¹è±¡çš„å½¢å¼å‚æ•°æ•°ï¼Œæœ€åˆä¸å‡½æ•°æ‰§è¡Œä¸Šä¸‹æ–‡ä¸­çš„ç›¸åº”å‚æ•°ç»‘å®šå…±äº«å…¶å€¼ã€‚è¿™æ„å‘³ç€æ›´æ”¹å±æ€§ä¼šæ›´æ”¹å‚æ•°ç»‘å®šçš„ç›¸åº”å€¼ï¼Œåä¹‹äº¦ç„¶ã€‚å¦‚æœåˆ é™¤å¹¶é‡æ–°å®šä¹‰æ­¤ç±»å±æ€§ï¼Œæˆ–è€…å°†è¯¥å±æ€§æ›´æ”¹ä¸ºè®¿é—®å™¨å±æ€§ï¼Œåˆ™æ­¤å¯¹åº”å…³ç³»å°†ä¸­æ–­ã€‚å¦‚æœargumentså¯¹è±¡æ˜¯æ™®é€šå¯¹è±¡ï¼Œåˆ™å…¶å±æ€§å€¼åªæ˜¯ä¼ é€’ç»™å‡½æ•°çš„å‚æ•°çš„å‰¯æœ¬ï¼Œå¹¶ä¸”å±æ€§å€¼å’Œå½¢å¼å‚æ•°å€¼ä¹‹é—´æ²¡æœ‰åŠ¨æ€é“¾æ¥ã€‚

>NOTE3 ParameterMapå¯¹è±¡åŠå…¶å±æ€§å€¼ç”¨ä½œæŒ‡å®šå‚æ•°å¯¹è±¡ä¸å‚æ•°ç»‘å®šå¯¹åº”å…³ç³»çš„è®¾å¤‡ã€‚ParameterMapå¯¹è±¡åŠå…¶å±æ€§å€¼çš„å¯¹è±¡ä¸èƒ½ä»ECMAScriptä»£ç ä¸­ç›´æ¥è§‚å¯Ÿåˆ°ã€‚ECMAScriptå®ç°ä¸éœ€è¦å®é™…åˆ›å»ºæˆ–ä½¿ç”¨è¿™æ ·çš„å¯¹è±¡æ¥å®ç°æŒ‡å®šçš„è¯­ä¹‰ã€‚

>NOTE4 æ™®é€šå‚æ•°å¯¹è±¡å®šä¹‰åä¸ºâ€œcalleeâ€çš„ä¸å¯é…ç½®è®¿é—®å™¨å±æ€§ï¼Œè¯¥å±æ€§åœ¨è®¿é—®æ—¶å¼•å‘TypeErrorå¼‚å¸¸ã€‚â€œcalleeâ€å±æ€§å¯¹å‚æ•°æœ‰æ›´å…·ä½“çš„å«ä¹‰ï¼Œå¼‚è´¨å¯¹è±¡åªä¸ºæŸäº›éä¸¥æ ¼å‡½æ•°ç±»åˆ›å»ºã€‚æ­¤å±æ€§åœ¨æ™®é€šå˜é‡ä¸­çš„å®šä¹‰æ˜¯ä¸ºäº†ç¡®ä¿å®ƒä¸æ˜¯é€šè¿‡ç¬¦åˆECMAScriptå®ç°ä»¥ä»»ä½•å…¶ä»–æ–¹å¼å®šä¹‰çš„ã€‚

>NOTE5 å‚æ•°çš„ECMAScriptå®ç°å¼‚è´¨å¯¹è±¡å†æ¥åŒ…å«ä¸€ä¸ªåä¸ºâ€œcallerâ€çš„è®¿é—®å™¨å±æ€§ã€‚åœ¨ECMAScript 2017ä¹‹å‰ï¼Œè¯¥è§„èŒƒåŒ…å«äº†å¯¹æ™®é€šå‚æ•°å¯¹è±¡æŠ›å‡ºâ€œcallerâ€å±æ€§çš„å®šä¹‰ã€‚ç”±äºå®ç°ä¸å†åŒ…å«æ­¤æ‰©å±•ï¼ŒECMAScript 2017å–æ¶ˆäº†æŠ›å‡ºâ€œcallerâ€è®¿é—®å™¨çš„è¦æ±‚ã€‚

#### 10.4.4.1 [[GetOwnProperty]] ( P )

å‚æ•°å¼‚è´¨å¯¹è±¡ args çš„ [[GetOwnProperty]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›åŒ…å«å±æ€§æè¿°ç¬¦æˆ–æœªå®šä¹‰çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let desc be OrdinaryGetOwnProperty(args, P).
2. If desc is undefined, return desc.
3. Let map be args.[[ParameterMap]].
4. Let isMapped be ! HasOwnProperty(map, P).
5. If isMapped is true, then
    - Set desc.[[Value]] to ! Get(map, P).
6. Return desc.

#### 10.4.4.2 [[DefineOwnProperty]] ( P, Desc )

å¼‚è´¨å¯¹è±¡ args çš„ [[DefineOwnProperty]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å’Œ Descï¼ˆå±æ€§æè¿°ç¬¦ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let map be args.[[ParameterMap]].
2. Let isMapped be ! HasOwnProperty(map, P).
3. Let newArgDesc be Desc.
4. If isMapped is true and IsDataDescriptor(Desc) is true, then
    - If Desc does not have a [[Value]] field, Desc has a [[Writable]] field, and Desc.[[Writable]] is false, then
        1. Set newArgDesc to a copy of Desc.
        2. Set newArgDesc.[[Value]] to ! Get(map, P).
5. Let allowed be ! OrdinaryDefineOwnProperty(args, P, newArgDesc).
6. If allowed is false, return false.
7. If isMapped is true, then
    - If IsAccessorDescriptor(Desc) is true, then
        i. Perform ! map.[[Delete]](P).
    - Else,
        1. If Desc has a [[Value]] field, then
            - Assert: The following Set will succeed, since formal parameters mapped by arguments objects are always writable.
            - Perform ! Set(map, P, Desc.[[Value]], false).
        2. If Desc has a [[Writable]] field and Desc.[[Writable]] is false, then
            - Perform ! map.[[Delete]](P).
8. Return true.

#### 10.4.4.3 [[Get]] ( P, Receiver )

å‚æ•°å¼‚è´¨å¯¹è±¡ args çš„ [[Get]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å’Œ Receiverï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å¹¶è¿”å›åŒ…å« ECMAScript è¯­è¨€å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let map be args.[[ParameterMap]].
2. Let isMapped be ! HasOwnProperty(map, P).
3. If isMapped is false, then
    - Return ? OrdinaryGet(args, P, Receiver).
4. Else,
    - Assert: map contains a formal parameter mapping for P.
    - Return ! Get(map, P).


#### 10.4.4.4 [[Set]] ( P, V, Receiver )

å¥‡å¼‚å¯¹è±¡ args çš„ [[Set]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰ã€Vï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å’Œ Receiverï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼æˆ– æŠ•æ·å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If SameValue(args, Receiver) is false, then
    - Let isMapped be false.
2. Else,
    - Let map be args.[[ParameterMap]].
    - Let isMapped be ! HasOwnProperty(map, P).
3. If isMapped is true, then
    - Assert: The following Set will succeed, since formal parameters mapped by arguments objects are always writable.
    - Perform ! Set(map, P, V, false).
4. Return ? OrdinarySet(args, P, V, Receiver).

#### 10.4.4.5 [[Delete]] ( P )

å¤–æ¥å¯¹è±¡ args å‚æ•°çš„ [[Delete]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let map be args.[[ParameterMap]].
2. Let isMapped be ! HasOwnProperty(map, P).
3. Let result be ? OrdinaryDelete(args, P).
4. If result is true and isMapped is true, then
    - Perform ! map.[[Delete]](P).
5. Return result.

#### 10.4.4.6 CreateUnmappedArgumentsObject ( argumentsList )

æŠ½è±¡æ“ä½œ CreateUnmappedArgumentsObject æ¥å—å‚æ•° argumentsListï¼ˆECMAScript è¯­è¨€å€¼åˆ—è¡¨ï¼‰å¹¶è¿”å›ä¸€ä¸ªæ™®é€šå¯¹è±¡ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let len be the number of elements in argumentsList.
2. Let obj be OrdinaryObjectCreate(%Object.prototype%, Â« [[ParameterMap]] Â»).
3. Set obj.[[ParameterMap]] to undefined.
4. Perform ! DefinePropertyOrThrow(obj, "length", PropertyDescriptor { [[Value]]: ğ”½(len), [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).
5. Let index be 0.
6. Repeat, while index < len,
    - Let val be argumentsList[index].
    - Perform ! CreateDataPropertyOrThrow(obj, ! ToString(ğ”½(index)), val).
    - Set index to index + 1.
7. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).
8. Perform ! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false }).
9. Return obj.

#### 10.4.4.7 CreateMappedArgumentsObject ( func, formals, argumentsList, env )

æŠ½è±¡æ“ä½œ CreateMappedArgumentsObject æ¥å—å‚æ•° funcï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰ã€formalsï¼ˆä¸€ä¸ªè§£æèŠ‚ç‚¹ï¼‰ã€argumentsListï¼ˆä¸€ä¸ª ECMAScript è¯­è¨€å€¼åˆ—è¡¨ï¼‰å’Œ envï¼ˆä¸€ä¸ªç¯å¢ƒè®°å½•ï¼‰å¹¶è¿”å›ä¸€ä¸ªå‚æ•°å¤–æ¥å¯¹è±¡ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Assert: formals does not contain a rest parameter, any binding patterns, or any initializers. It may contain duplicate identifiers.
2. Let len be the number of elements in argumentsList.
3. Let obj be MakeBasicObject(Â« [[Prototype]], [[Extensible]], [[ParameterMap]] Â»).
4. Set obj.[[GetOwnProperty]] as specified in 10.4.4.1.
5. Set obj.[[DefineOwnProperty]] as specified in 10.4.4.2.
6. Set obj.[[Get]] as specified in 10.4.4.3.
7. Set obj.[[Set]] as specified in 10.4.4.4.
8. Set obj.[[Delete]] as specified in 10.4.4.5.
9. Set obj.[[Prototype]] to %Object.prototype%.
10. Let map be OrdinaryObjectCreate(null).
11. Set obj.[[ParameterMap]] to map.
12. Let parameterNames be the BoundNames of formals.
13. Let numberOfParameters be the number of elements in parameterNames.
14. Let index be 0.
15. Repeat, while index < len,
    - Let val be argumentsList[index].
    - Perform ! CreateDataPropertyOrThrow(obj, ! ToString(ğ”½(index)), val).
    - Set index to index + 1.
16. Perform ! DefinePropertyOrThrow(obj, "length", PropertyDescriptor { [[Value]]: ğ”½(len), [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).
17. Let mappedNames be a new empty List.
18. Set index to numberOfParameters - 1.
19. Repeat, while index â‰¥ 0,
    - Let name be parameterNames[index].
    - If name is not an element of mappedNames, then
        1. Append name to mappedNames.
        2. If index < len, then
            - Let g be MakeArgGetter(name, env).
            - Let p be MakeArgSetter(name, env).
            - Perform ! map.[[DefineOwnProperty]](! ToString(ğ”½(index)), PropertyDescriptor { [[Set]]: p, [[Get]]: g, [[Enumerable]]: false, [[Configurable]]: true }).
            c. Set index to index - 1.
20. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).
21. Perform ! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { [[Value]]: func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).
22. Return obj.


##### 10.4.4.7.1 MakeArgGetter ( name, env )

æŠ½è±¡æ“ä½œ MakeArgGetter æ¥å—å‚æ•°åç§°ï¼ˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼‰å’Œç¯å¢ƒï¼ˆä¸€ä¸ªç¯å¢ƒè®°å½•ï¼‰å¹¶è¿”å›ä¸€ä¸ªå‡½æ•°å¯¹è±¡ã€‚ å®ƒåˆ›å»ºä¸€ä¸ªå†…ç½®å‡½æ•°å¯¹è±¡ï¼Œå½“æ‰§è¡Œæ—¶è¿”å› env ä¸­ name ç»‘å®šçš„å€¼ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let getterClosure be a new Abstract Closure with no parameters that captures name and env and performs the following steps when called:
    - Return env.GetBindingValue(name, false).
2. Let getter be CreateBuiltinFunction(getterClosure, 0, "", Â« Â»).
3. NOTE: getter is never directly accessible to ECMAScript code.
4. Return getter.

>NOTE ArgGetterå‡½æ•°æ°¸è¿œä¸èƒ½ç›´æ¥è¢«ECMAScriptä»£ç è®¿é—®ã€‚

##### 10.4.4.7.2 MakeArgSetter ( name, env )

æŠ½è±¡æ“ä½œMakeArgSetteræ¥å—å‚æ•°nameï¼ˆå­—ç¬¦ä¸²ï¼‰å’Œenvï¼ˆç¯å¢ƒè®°å½•ï¼‰ã€‚å®ƒåˆ›å»ºäº†ä¸€ä¸ªå†…ç½®çš„å‡½æ•°å¯¹è±¡ï¼Œå½“æ‰§è¡Œè¯¥å¯¹è±¡æ—¶ï¼Œè¯¥å¯¹è±¡å°†è®¾ç½®envä¸­nameçš„ç»‘å®šå€¼ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let setterClosure be a new Abstract Closure with parameters (value) that captures name and env and performs the following steps when called:
    - Return ! env.SetMutableBinding(name, value, false).
2. Let setter be CreateBuiltinFunction(setterClosure, 1, "", Â« Â»).
3. NOTE: setter is never directly accessible to ECMAScript code.
4. Return setter.

>NOTE ArgSetterå‡½æ•°æ°¸è¿œä¸èƒ½ç›´æ¥è¢«ECMAScriptä»£ç è®¿é—®ã€‚

### 10.4.5 Integer-Indexed Exotic Objects

æ•´æ•°ç´¢å¼•çš„å¼‚è´¨å¯¹è±¡æ˜¯æ‰§è¡Œæ•´æ•°ç´¢å¼•å±æ€§é”®ç‰¹æ®Šå¤„ç†çš„å¼‚è´¨å¯¹è±¡ã€‚

æ•´æ•°ç´¢å¼•çš„å¼‚è´¨å¯¹è±¡ä¸æ™®é€šå¯¹è±¡å…·æœ‰ç›¸åŒçš„å†…éƒ¨æ§½ï¼Œæ­¤å¤–è¿˜æœ‰[[ViewedArrayBuffer]]ã€[[ArrayLength]]ã€[[ByteOffset]]ã€[[ContentType]]å’Œ[[TypedArrayName]]å†…éƒ¨æ§½ã€‚

å¦‚æœä¸€ä¸ªå¯¹è±¡çš„[[GetOwnProperty]]ã€[[HasProperty]]ã€[[DefineOwnProperty]]ã€[[Get]]ã€[[Set]]ã€[[Delete]]å’Œ[[OwnPropertyKeys]]çš„å†…éƒ¨æ–¹æ³•ä½¿ç”¨æœ¬èŠ‚ä¸­çš„å®šä¹‰ï¼Œå¹¶ä¸”å…¶å…¶ä»–åŸºæœ¬å†…éƒ¨æ–¹æ³•ä½¿ç”¨10.1ä¸­çš„å®šä¹‰ï¼Œåˆ™è¯¥å¯¹è±¡æ˜¯ä¸€ä¸ªæ•´æ•°ç´¢å¼•çš„å¼‚è´¨å¯¹è±¡ã€‚è¿™äº›æ–¹æ³•ç”±IntegerIndexedObjectCreateå®‰è£…ã€‚

#### 10.4.5.1 [[GetOwnProperty]] ( P )

Integer-Indexed å¥‡å¼‚å¯¹è±¡ O çš„ [[GetOwnProperty]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›åŒ…å«å±æ€§æè¿°ç¬¦æˆ–æœªå®šä¹‰çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is a String, then
    - Let numericIndex be CanonicalNumericIndexString(P).
    - If numericIndex is not undefined, then
        1. Let value be IntegerIndexedElementGet(O, numericIndex).
        2. If value is undefined, return undefined.
        3. Return the PropertyDescriptor { [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
2. Return OrdinaryGetOwnProperty(O, P).

#### 10.4.5.2 [[HasProperty]] ( P )

Integer-Indexed å¥‡å¼‚å¯¹è±¡ O çš„ [[HasProperty]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is a String, then
    - Let numericIndex be CanonicalNumericIndexString(P).
    - If numericIndex is not undefined, return IsValidIntegerIndex(O, numericIndex).
2. Return ? OrdinaryHasProperty(O, P).

#### 10.4.5.3 [[DefineOwnProperty]] ( P, Desc )

Integer-Indexed å¥‡å¼‚å¯¹è±¡ O çš„ [[DefineOwnProperty]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å’Œ Descï¼ˆå±æ€§æè¿°ç¬¦ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is a String, then
    - Let numericIndex be CanonicalNumericIndexString(P).
    - If numericIndex is not undefined, then
        1. If IsValidIntegerIndex(O, numericIndex) is false, return false.
        2. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is false, return false.
        3. If Desc has an [[Enumerable]] field and if Desc.[[Enumerable]] is false, return false.
        4. If IsAccessorDescriptor(Desc) is true, return false.
        5. If Desc has a [[Writable]] field and if Desc.[[Writable]] is false, return false.
        6. If Desc has a [[Value]] field, perform ? IntegerIndexedElementSet(O, numericIndex, Desc.[[Value]]).
        7. Return true.
2. Return ! OrdinaryDefineOwnProperty(O, P, Desc).

#### 10.4.5.4 [[Get]] ( P, Receiver )

Integer-Indexed å¥‡å¼‚å¯¹è±¡ O çš„ [[Get]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å’Œ Receiverï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å¹¶è¿”å›åŒ…å« ECMAScript è¯­è¨€å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is a String, then
    - Let numericIndex be CanonicalNumericIndexString(P).
    - If numericIndex is not undefined, then
        1. Return IntegerIndexedElementGet(O, numericIndex).
2. Return ? OrdinaryGet(O, P, Receiver).

#### 10.4.5.5 [[Set]] ( P, V, Receiver )

Integer-Indexed å¥‡å¼‚å¯¹è±¡ O çš„ [[Set]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰ã€Vï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å’Œ Receiverï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆ æˆ–æŠ•æ·å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is a String, then
    - Let numericIndex be CanonicalNumericIndexString(P).
    - If numericIndex is not undefined, then
        1. If SameValue(O, Receiver) is true, then
            - Perform ? IntegerIndexedElementSet(O, numericIndex, V).
            - Return true.
        2. If IsValidIntegerIndex(O, numericIndex) is false, return true.
2. Return ? OrdinarySet(O, P, V, Receiver).

#### 10.4.5.6 [[Delete]] ( P )

Integer-Indexed å¥‡å¼‚å¯¹è±¡ O çš„ [[Delete]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is a String, then
    - Let numericIndex be CanonicalNumericIndexString(P).
    - If numericIndex is not undefined, then
        1. If IsValidIntegerIndex(O, numericIndex) is false, return true; else return false.
2. Return ! OrdinaryDelete(O, P).

#### 10.4.5.7 [[OwnPropertyKeys]] ( )

Integer-Indexed exotic object O çš„ [[OwnPropertyKeys]] å†…éƒ¨æ–¹æ³•ä¸æ¥å—ä»»ä½•å‚æ•°ï¼Œå¹¶è¿”å›åŒ…å«å±æ€§é”®åˆ—è¡¨çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let keys be a new empty List.
2. If IsDetachedBuffer(O.[[ViewedArrayBuffer]]) is false, then
    - For each integer i such that 0 â‰¤ i < O.[[ArrayLength]], in ascending order, do
        1. Append ! ToString(ğ”½(i)) to keys.
3. For each own property key P of O such that P is a String and P is not an integer index, in ascending chronological order of property creation, do
    - Append P to keys.
4. For each own property key P of O such that P is a Symbol, in ascending chronological order of property creation, do
    - Append P to keys.
5. Return keys.

#### 10.4.5.8 IntegerIndexedObjectCreate ( prototype )

æŠ½è±¡æ“ä½œ IntegerIndexedObjectCreate æ¥å—å‚æ•°åŸå‹ï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰å¹¶è¿”å›ä¸€ä¸ª Integer-Indexed å¤–æ¥å¯¹è±¡ã€‚ å®ƒç”¨äºæŒ‡å®šåˆ›å»ºæ–°çš„ Integer-Indexed å¥‡å¼‚å¯¹è±¡ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let internalSlotsList be Â« [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] Â».
2. Let A be MakeBasicObject(internalSlotsList).
3. Set A.[[GetOwnProperty]] as specified in 10.4.5.1.
4. Set A.[[HasProperty]] as specified in 10.4.5.2.
5. Set A.[[DefineOwnProperty]] as specified in 10.4.5.3.
6. Set A.[[Get]] as specified in 10.4.5.4.
7. Set A.[[Set]] as specified in 10.4.5.5.
8. Set A.[[Delete]] as specified in 10.4.5.6.
9. Set A.[[OwnPropertyKeys]] as specified in 10.4.5.7.
10. Set A.[[Prototype]] to prototype.
11. Return A.

#### 10.4.5.9 IsValidIntegerIndex ( O, index )

æŠ½è±¡æ“ä½œ IsValidIntegerIndex æ¥å—å‚æ•° Oï¼ˆä¸€ä¸ª Integer-Indexed å¥‡å¼‚å¯¹è±¡ï¼‰å’Œç´¢å¼•ï¼ˆä¸€ä¸ªæ•°å­—ï¼‰å¹¶è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If IsDetachedBuffer(O.[[ViewedArrayBuffer]]) is true, return false.
2. If IsIntegralNumber(index) is false, return false.
3. If index is -0ğ”½, return false.
4. If â„(index) < 0 or â„(index) â‰¥ O.[[ArrayLength]], return false.
5. Return true.

#### 10.4.5.10 IntegerIndexedElementGet ( O, index )

æŠ½è±¡æ“ä½œ IntegerIndexedElementGet æ¥å—å‚æ•° Oï¼ˆä¸€ä¸ª Integer-Indexed å¥‡å¼‚å¯¹è±¡ï¼‰å’Œç´¢å¼•ï¼ˆä¸€ä¸ªæ•°å­—ï¼‰å¹¶è¿”å›ä¸€ä¸ª Numberã€ä¸€ä¸ª BigInt æˆ– undefinedã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If IsValidIntegerIndex(O, index) is false, return undefined.
2. Let offset be O.[[ByteOffset]].
3. Let elementSize be TypedArrayElementSize(O).
4. Let indexedPosition be (â„(index) Ã— elementSize) + offset.
5. Let elementType be TypedArrayElementType(O).
6. Return GetValueFromBuffer(O.[[ViewedArrayBuffer]], indexedPosition, elementType, true, Unordered).

#### 10.4.5.11 IntegerIndexedElementSet ( O, index, value )

æŠ½è±¡æ“ä½œ IntegerIndexedElementSet é‡‡ç”¨å‚æ•° Oï¼ˆä¸€ä¸ª Integer-Indexed å¥‡å¼‚å¯¹è±¡ï¼‰ã€ç´¢å¼•ï¼ˆä¸€ä¸ªæ•°å­—ï¼‰å’Œå€¼ï¼ˆä¸€ä¸ª ECMAScript è¯­è¨€å€¼ï¼‰ï¼Œå¹¶è¿”å›åŒ…å«æœªä½¿ç”¨çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If O.[[ContentType]] is BigInt, let numValue be ? ToBigInt(value).
2. Otherwise, let numValue be ? ToNumber(value).
3. If IsValidIntegerIndex(O, index) is true, then
    - Let offset be O.[[ByteOffset]].
    - Let elementSize be TypedArrayElementSize(O).
    - Let indexedPosition be (â„(index) Ã— elementSize) + offset.
    - Let elementType be TypedArrayElementType(O).
    - Perform SetValueInBuffer(O.[[ViewedArrayBuffer]], indexedPosition, elementType, numValue, true, Unordered).
4. Return unused.

>NOTE æ­¤æ“ä½œä¼¼ä¹æ€»æ˜¯æˆåŠŸï¼Œä½†åœ¨å°è¯•å†™å…¥è¶…è¿‡ TypedArray çš„æœ«å°¾æˆ–å†™å…¥ç”±åˆ†ç¦»çš„ ArrayBuffer æ”¯æŒçš„ TypedArray æ—¶ï¼Œå®ƒæ²¡æœ‰ä»»ä½•æ•ˆæœã€‚

### 10.4.6 Module Namespace Exotic Objects

æ¨¡å—å‘½åç©ºé—´å¼‚è´¨å¯¹è±¡æ˜¯ä¸€ä¸ªå¼‚è´¨å¯¹è±¡ï¼Œå®ƒå…¬å¼€ä»ECMAScriptæ¨¡å—å¯¼å‡ºçš„ç»‘å®šï¼ˆå‚è§16.2.3ï¼‰ã€‚æ¨¡å—å‘½åç©ºé—´å¼‚è´¨å¯¹è±¡çš„å­—ç¬¦ä¸²é”®è‡ªèº«å±æ€§ä¸æ¨¡å—å¯¼å‡ºçš„ç»‘å®šåç§°ä¹‹é—´å­˜åœ¨ä¸€å¯¹ä¸€çš„å¯¹åº”å…³ç³»ã€‚å¯¼å‡ºçš„ç»‘å®šåŒ…æ‹¬ä½¿ç”¨export* export itemsé—´æ¥å¯¼å‡ºçš„ä»»ä½•ç»‘å®šã€‚æ¯ä¸ªå­—ç¬¦ä¸²å€¼çš„ownå±æ€§é”®éƒ½æ˜¯ç›¸åº”çš„å¯¼å‡ºç»‘å®šåç§°çš„StringValueã€‚è¿™äº›æ˜¯æ¨¡å—å‘½åç©ºé—´å¥‡å¼‚å¯¹è±¡çš„å”¯ä¸€ä»¥å­—ç¬¦ä¸²ä¸ºé”®çš„å±æ€§ã€‚ æ¯ä¸ªè¿™æ ·çš„å±æ€§éƒ½æœ‰å±æ€§ { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }ã€‚ æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡æ˜¯ä¸å¯æ‰©å±•çš„ã€‚

å¦‚æœå¯¹è±¡çš„[[SetPrototypeOf]]ã€[[IsExtensible]]ã€[[PreventExtensions]]ã€[[GetOwnProperty]]ã€[[HasProperty]]ã€[[Get]]ã€[[Set]]ã€[[Delete]]å’Œ[[OwnPropertyKeys]]çš„å†…éƒ¨æ–¹æ³•ä½¿ç”¨æœ¬èŠ‚ä¸­çš„å®šä¹‰ï¼Œå¹¶ä¸”å…¶å…¶ä»–åŸºæœ¬å†…éƒ¨æ–¹æ³•ä½¿ç”¨æ‰¾åˆ°çš„å®šä¹‰ï¼Œåˆ™è¯¥å¯¹è±¡å°±æ˜¯æ¨¡å—å‘½åç©ºé—´å¼‚è´¨å¯¹è±¡åœ¨10.1ä¸­ã€‚è¿™äº›æ–¹æ³•ç”±ModuleNamespaceCreateå®‰è£…ã€‚

æ¨¡å—åç§°ç©ºé—´å¼‚è´¨å¯¹è±¡å…·æœ‰è¡¨32ä¸­å®šä¹‰çš„å†…éƒ¨æ’æ§½ã€‚

<center>Table 32: Internal Slots of Module Namespace Exotic Objects</center>

|Internal Slot	    |Type	        |Description|
|----               |----           |----       |
[[Module]]	        |Module Record	|æ­¤å‘½åç©ºé—´å…¬å¼€å…¶å¯¼å‡ºçš„æ¨¡å—è®°å½•ã€‚
[[Exports]]	        |List of String	|ä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶å…ƒç´ æ˜¯ä½œä¸ºè¯¥å¯¹è±¡è‡ªå·±çš„å±æ€§å…¬å¼€çš„å¯¼å‡ºåç§°çš„å­—ç¬¦ä¸²å€¼ã€‚ è¯¥åˆ—è¡¨è¢«æ’åºï¼Œå°±å¥½åƒè¿™äº›å­—ç¬¦ä¸²å€¼çš„æ•°ç»„å·²ä½¿ç”¨ï¼…Array.prototype.sortï¼…ï¼ˆundefinedä¸ºcomparefnï¼‰è¿›è¡Œäº†æ’åºã€‚

æ¨¡å—å‘½åç©ºé—´å¼‚è´¨å¯¹è±¡ä¸ºé™¤[[GetPrototypeOf]]ä¹‹å¤–çš„æ‰€æœ‰å†…éƒ¨æ–¹æ³•æä¾›äº†æ›¿ä»£å®šä¹‰ï¼Œå…¶è¡Œä¸ºå¦‚10.1.1ä¸­æ‰€å®šä¹‰ã€‚

#### 10.4.6.1 [[GetPrototypeOf]] ( )

æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡çš„ [[GetPrototypeOf]] å†…éƒ¨æ–¹æ³•ä¸æ¥å—ä»»ä½•å‚æ•°å¹¶è¿”å›åŒ…å« null çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Return null.

#### 10.4.6.2 [[SetPrototypeOf]] ( V )

æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡ O çš„ [[SetPrototypeOf]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Vï¼ˆå¯¹è±¡æˆ– nullï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Return ! SetImmutablePrototype(O, V).

#### 10.4.6.3 [[IsExtensible]] ( )

æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡çš„ [[IsExtensible]] å†…éƒ¨æ–¹æ³•ä¸æ¥å—ä»»ä½•å‚æ•°å¹¶è¿”å›åŒ…å« false çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Return false.

#### 10.4.6.4 [[PreventExtensions]] ( )

æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡çš„ [[PreventExtensions]] å†…éƒ¨æ–¹æ³•ä¸å¸¦å‚æ•°å¹¶è¿”å›åŒ…å« true çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Return true.

#### 10.4.6.5 [[GetOwnProperty]] ( P )

The [[GetOwnProperty]] internal method of a module namespace exotic object O takes argument P (a property key) and returns either a normal completion containing either a Property Descriptor or undefined, or a throw completion. It performs the following steps when called:

æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡ O çš„ [[GetOwnProperty]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›åŒ…å«å±æ€§æè¿°ç¬¦æˆ–æœªå®šä¹‰çš„æ­£å¸¸å®Œæˆï¼Œæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is a Symbol, return OrdinaryGetOwnProperty(O, P).
2. Let exports be O.[[Exports]].
3. If P is not an element of exports, return undefined.
4. Let value be ? O.[[Get]](P, O).
5. Return PropertyDescriptor { [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }.

#### 10.4.6.6 [[DefineOwnProperty]] ( P, Desc )

æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡ O çš„ [[DefineOwnProperty]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å’Œ Descï¼ˆå±æ€§æè¿°ç¬¦ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is a Symbol, return ! OrdinaryDefineOwnProperty(O, P, Desc).
2. Let current be ? O.[[GetOwnProperty]](P).
3. If current is undefined, return false.
4. If Desc has a [[Configurable]] field and Desc.[[Configurable]] is true, return false.
5. If Desc has an [[Enumerable]] field and Desc.[[Enumerable]] is false, return false.
6. If IsAccessorDescriptor(Desc) is true, return false.
7. If Desc has a [[Writable]] field and Desc.[[Writable]] is false, return false.
8. If Desc has a [[Value]] field, return SameValue(Desc.[[Value]], current.[[Value]]).
9. Return true.

#### 10.4.6.7 [[HasProperty]] ( P )

æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡ O çš„ [[HasProperty]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is a Symbol, return ! OrdinaryHasProperty(O, P).
2. Let exports be O.[[Exports]].
3. If P is an element of exports, return true.
4. Return false.

#### 10.4.6.8 [[Get]] ( P, Receiver )

æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡ O çš„ [[Get]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å’Œ Receiverï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å¹¶è¿”å›åŒ…å« ECMAScript è¯­è¨€å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is a Symbol, then
    - Return ! OrdinaryGet(O, P, Receiver).
2. Let exports be O.[[Exports]].
3. If P is not an element of exports, return undefined.
4. Let m be O.[[Module]].
5. Let binding be ! m.ResolveExport(P).
6. Assert: binding is a ResolvedBinding Record.
7. Let targetModule be binding.[[Module]].
8. Assert: targetModule is not undefined.
9. If binding.[[BindingName]] is namespace, then
    - Return ? GetModuleNamespace(targetModule).
10. Let targetEnv be targetModule.[[Environment]].
11. If targetEnv is empty, throw a ReferenceError exception.
12. Return ? targetEnv.GetBindingValue(binding.[[BindingName]], true).

>NOTE ResolveExportæ²¡æœ‰å‰¯ä½œç”¨ã€‚æ¯æ¬¡ä½¿ç”¨ç‰¹å®šçš„exportNameã€resolveSet pairä½œä¸ºå‚æ•°è°ƒç”¨æ­¤æ“ä½œæ—¶ï¼Œå®ƒå¿…é¡»è¿”å›ç›¸åŒçš„ç»“æœã€‚å®ç°å¯ä»¥é€‰æ‹©ä¸ºæ¯ä¸ªæ¨¡å—å‘½åç©ºé—´å¼‚è´¨å¯¹è±¡çš„[[Exports]]é¢„è®¡ç®—æˆ–ç¼“å­˜ResolveExportç»“æœã€‚

#### 10.4.6.9 [[Set]] ( P, V, Receiver )

æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡çš„ [[Set]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰ã€Vï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å’Œ Receiverï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å¹¶è¿”å›åŒ…å« false çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Return false.

#### 10.4.6.10 [[Delete]] ( P )

æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡ O çš„ [[Delete]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Pï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If P is a Symbol, then
    - Return ! OrdinaryDelete(O, P).
2. Let exports be O.[[Exports]].
3. If P is an element of exports, return false.
4. Return true.

#### 10.4.6.11 [[OwnPropertyKeys]] ( )

æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡ O çš„ [[OwnPropertyKeys]] å†…éƒ¨æ–¹æ³•ä¸æ¥å—ä»»ä½•å‚æ•°ï¼Œå¹¶è¿”å›åŒ…å«å±æ€§é”®åˆ—è¡¨çš„æ­£å¸¸å®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let exports be O.[[Exports]].
2. Let symbolKeys be OrdinaryOwnPropertyKeys(O).
3. Return the list-concatenation of exports and symbolKeys.

#### 10.4.6.12 ModuleNamespaceCreate ( module, exports )

æŠ½è±¡æ“ä½œ ModuleNamespaceCreate æ¥å—å‚æ•°æ¨¡å—ï¼ˆä¸€ä¸ªæ¨¡å—è®°å½•ï¼‰å’Œå¯¼å‡ºï¼ˆä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼‰å¹¶è¿”å›ä¸€ä¸ªæ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡ã€‚ å®ƒç”¨äºæŒ‡å®šæ–°æ¨¡å—å‘½åç©ºé—´å¤–æ¥å¯¹è±¡çš„åˆ›å»ºã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

 1. Assert: module.[[Namespace]] is empty.
2. Let internalSlotsList be the internal slots listed in Table 32.
3. Let M be MakeBasicObject(internalSlotsList).
4. Set M's essential internal methods to the definitions specified in 10.4.6.
5. Set M.[[Module]] to module.
6. Let sortedExports be a List whose elements are the elements of exports ordered as if an Array of the same values had been sorted using %Array.prototype.sort% using undefined as comparefn.
7. Set M.[[Exports]] to sortedExports.
8. Create own properties of M corresponding to the definitions in 28.3.
9. Set module.[[Namespace]] to M.
10. Return M.

### 10.4.7 Immutable Prototype Exotic Objects

ä¸€ä¸ªä¸å¯å˜çš„åŸå‹å¼‚è´¨å¯¹è±¡æ˜¯ä¸€ä¸ªå…·æœ‰[[prototype]]å†…éƒ¨æ§½çš„å¼‚è´¨å¯¹è±¡ï¼Œä¸€æ—¦åˆå§‹åŒ–å®ƒå°±ä¸ä¼šæ”¹å˜ã€‚

å¦‚æœä¸€ä¸ªå¯¹è±¡çš„[[SetPrototypeOf]]å†…éƒ¨æ–¹æ³•ä½¿ç”¨ä»¥ä¸‹å®ç°ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€ä¸ªä¸å¯å˜çš„åŸå‹å¼‚è´¨å¯¹è±¡ã€‚ï¼ˆå®ƒçš„å…¶ä»–åŸºæœ¬å†…éƒ¨æ–¹æ³•å¯ä»¥ä½¿ç”¨ä»»ä½•å®ç°ï¼Œè¿™å–å†³äºæ‰€è®¨è®ºçš„ç‰¹å®šçš„ä¸å¯å˜åŸå‹å¼‚è´¨å¯¹è±¡ï¼‰

>MOTE ä¸å…¶ä»–å¤–æ¥å¯¹è±¡ä¸åŒï¼Œæ²¡æœ‰ä¸ºä¸å¯å˜åŸå‹å¤–æ¥å¯¹è±¡æä¾›ä¸“é—¨çš„åˆ›å»ºæŠ½è±¡æ“ä½œã€‚ è¿™æ˜¯å› ä¸ºå®ƒä»¬ä»…ç”± %Object.prototype% å’Œå®¿ä¸»ç¯å¢ƒä½¿ç”¨ï¼Œå¹¶ä¸”åœ¨å®¿ä¸»ç¯å¢ƒä¸­ï¼Œç›¸å…³å¯¹è±¡åœ¨å…¶ä»–æ–¹é¢å¯èƒ½æ˜¯å¥‡å¼‚çš„ï¼Œå› æ­¤éœ€è¦å®ƒä»¬è‡ªå·±çš„ä¸“ç”¨åˆ›å»ºæ“ä½œã€‚

#### 10.4.7.1 [[SetPrototypeOf]] ( V )

ä¸å¯å˜åŸå‹å¥‡å¼‚å¯¹è±¡ O çš„ [[SetPrototypeOf]] å†…éƒ¨æ–¹æ³•é‡‡ç”¨å‚æ•° Vï¼ˆå¯¹è±¡æˆ– nullï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Return ? SetImmutablePrototype(O, V).

#### 10.4.7.2 SetImmutablePrototype ( O, V )

æŠ½è±¡æ“ä½œ SetImmutablePrototype æ¥å—å‚æ•° Oï¼ˆå¯¹è±¡ï¼‰å’Œ Vï¼ˆå¯¹è±¡æˆ– nullï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let current be ? O.[[GetPrototypeOf]]().
2. If SameValue(V, current) is true, return true.
3. Return false.
