# <center> 13 ECMAScript Language: Expressions</center>

## 13.1 Identifiers

Syntax

    IdentifierReference[Yield, Await]:
        Identifier
        [~Yield]yield
        [~Await]await
    BindingIdentifier[Yield, Await]:
        Identifier
        yield
        await
    LabelIdentifier[Yield, Await]:
        Identifier
        [~Yield]yield
        [~Await]await
    Identifier:
        IdentifierNamebut not ReservedWord


>NOTE åœ¨è¯­æ³•ä¸­ï¼Œyieldå’Œawaitå¯ä»¥ä½œä¸ºBindingIdentifieræ¥ä½¿ç”¨ï¼Œå¹¶ä¸”åœ¨ä¸‹é¢çš„é™æ€è¯­ä¹‰ä¸­è¢«ç¦æ­¢ï¼Œä»¥é˜²æ­¢åœ¨ä»¥ä¸‹æƒ…å†µä¸‹è‡ªåŠ¨æ’å…¥åˆ†å·ï¼š

    let
    await 0;

### 13.1.1 Static Semantics: Early Errors

BindingIdentifier:Identifier

- å¦‚æœä¸æ­¤äº§ç”Ÿå¼åŒ¹é…çš„ä»£ç åŒ…å«åœ¨ä¸¥æ ¼æ¨¡å¼ä»£ç ä¸­ï¼Œå¹¶ä¸”Identifierçš„StringValueæ˜¯â€œargumentsâ€æˆ–â€œ evalâ€ï¼Œåˆ™æ˜¯è¯­æ³•é”™è¯¯ã€‚

IdentifierReference:yield
BindingIdentifier:yield
LabelIdentifier:yield

- å¦‚æœæ­¤äº§ç”Ÿå¼åŒ¹é…çš„ä»£ç åŒ…å«åœ¨ä¸¥æ ¼æ¨¡å¼ä»£ç ä¸­ï¼Œåˆ™ä¸ºè¯­æ³•é”™è¯¯ã€‚

IdentifierReference:await
BindingIdentifier:await
LabelIdentifier:await

- å¦‚æœå¥æ³•è¯­æ³•çš„ç›®æ ‡ç¬¦å·æ˜¯æ¨¡å—ï¼Œé‚£å°±æ˜¯è¯­æ³•é”™è¯¯ã€‚

BindingIdentifier[Yield, Await]:yield

- å¦‚æœæ­¤äº§ç”Ÿå¼å…·æœ‰[Yield]å‚æ•°ï¼Œåˆ™ä¸ºè¯­æ³•é”™è¯¯ã€‚

BindingIdentifier[Yield, Await]:await

- å¦‚æœæ­¤äº§ç”Ÿå¼å…·æœ‰[Await]å‚æ•°ï¼Œåˆ™ä¸ºè¯­æ³•é”™è¯¯ã€‚


IdentifierReference[Yield, Await]:Identifier
BindingIdentifier[Yield, Await]:Identifier
LabelIdentifier[Yield, Await]:Identifier

- å¦‚æœè¿™ä¸ªäº§ç”Ÿå¼æœ‰ä¸€ä¸ª[Yield]å‚æ•°ï¼Œè€Œæ ‡è¯†ç¬¦çš„StringValueæ˜¯â€œYieldâ€ï¼Œåˆ™è¿™æ˜¯ä¸€ä¸ªè¯­æ³•é”™è¯¯ã€‚

- å¦‚æœè¿™ä¸ªäº§ç”Ÿå¼æœ‰ä¸€ä¸ª[Await]å‚æ•°ï¼Œè€Œæ ‡è¯†ç¬¦çš„StringValueæ˜¯â€œAwaitâ€ï¼Œåˆ™è¿™æ˜¯ä¸€ä¸ªè¯­æ³•é”™è¯¯ã€‚

Identifier:IdentifierNamebut not ReservedWord

- å¦‚æœæ­¤çŸ­è¯­åŒ…å«åœ¨ä¸¥æ ¼æ¨¡å¼ä»£ç ä¸­ï¼Œå¹¶ä¸”IdentifierNameçš„StringValueä¸ºï¼š "implements", "interface", "let", "package", "private", "protected", "public", "static", or "yield"
- å¦‚æœè¯­æ³•è¯­æ³•çš„ç›®æ ‡ç¬¦å·ä¸ºModuleä¸”IdentifierNameçš„StringValueä¸ºâ€œ awaitâ€ï¼Œåˆ™ä¸ºè¯­æ³•é”™è¯¯ã€‚
- å¦‚æœIdentifierNameçš„StringValueä¸ä»»ä½•ReservedWordçš„StringValueç›¸åŒçš„Stringå€¼ï¼ˆé™¤yieldæˆ–awaitä»¥å¤–ï¼‰å‡æ˜¯è¯­æ³•é”™è¯¯ã€‚

>NOTE IdentifierNameçš„StringValueè§„èŒƒåŒ–äº†IdentifierNameä¸­çš„ä»»ä½•Unicodeè½¬ä¹‰åºåˆ—ï¼Œå› æ­¤æ­¤ç±»è½¬ä¹‰ä¸èƒ½ç”¨äºç¼–å†™å…¶ç ä½åºåˆ—ä¸ReservedWordç›¸åŒçš„æ ‡è¯†ç¬¦ã€‚

### 13.1.2 Static Semantics: StringValue

è¯­æ³•åˆ¶å¯¼çš„æ“ä½œ StringValue ä¸å¸¦å‚æ•°ã€‚ å®ƒåœ¨ä»¥ä¸‹äº§ç”Ÿå¼ä¸Šåˆ†æ®µå®šä¹‰ï¼š

```
IdentifierName ::

        IdentifierStart
        IdentifierName IdentifierPart

    1. Let idTextUnescaped be IdentifierCodePoints(12.6.1.2) of IdentifierName.
    2. Return ! CodePointsToString(idTextUnescaped).
```
IdentifierReference:yield

BindingIdentifier:yield

LabelIdentifier:yield

    1. Return "yield".

IdentifierReference:await

BindingIdentifier:await

LabelIdentifier:await

    1. Return "await".

Identifier : IdentifierName but not ReservedWord

1. Return the StringValue of IdentifierName.

PrivateIdentifier ::

    # IdentifierName

1. Return the string-concatenation of 0x0023 (NUMBER SIGN) and the StringValue of IdentifierName.

ModuleExportName : StringLiteral

1. Return the SV of StringLiteral.


### 13.1.3 Runtime Semantics: Evaluation

IdentifierReference:Identifier

    Return ? ResolveBinding(StringValue of Identifier).

IdentifierReference:yield

    Return ? ResolveBinding("yield").

IdentifierReference:await

    Return ? ResolveBinding("await").

>NOTE1 è®¡ç®—IdentifierReferenceçš„ç»“æœå§‹ç»ˆæ˜¯ç±»å‹å¼•ç”¨çš„å€¼ã€‚

>NOTE2 åœ¨éä¸¥æ ¼ä»£ç ä¸­ï¼Œå…³é”®å­—yieldå¯ä»¥ç”¨ä½œæ ‡è¯†ç¬¦ã€‚è¯„ä¼°IdentifierReferenceä¼šè§£æyieldçš„ç»‘å®šï¼Œå°±åƒå®ƒæ˜¯ä¸€ä¸ªæ ‡è¯†ç¬¦ä¸€æ ·ã€‚æ—©æœŸçš„é”™è¯¯é™åˆ¶ç¡®ä¿åªæœ‰éä¸¥æ ¼ä»£ç æ‰èƒ½è¿›è¡Œè¿™ç§è®¡ç®—ã€‚


## 13.2 ä¸»è¡¨è¾¾å¼(Primary Expression)

### Syntax

PrimaryExpression[Yield, Await]:

    this
    IdentifierReference[?Yield, ?Await]
    Literal
    ArrayLiteral[?Yield, ?Await]
    ObjectLiteral[?Yield, ?Await]
    FunctionExpression
    ClassExpression[?Yield, ?Await]
    GeneratorExpression
    AsyncFunctionExpression
    AsyncGeneratorExpression
    RegularExpressionLiteral
    TemplateLiteral[?Yield, ?Await, ~Tagged]
    CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]

CoverParenthesizedExpressionAndArrowParameterList[Yield, Await]:

    (Expression[+In, ?Yield, ?Await])
    (Expression[+In, ?Yield, ?Await],)
    ()
    (...BindingIdentifier[?Yield, ?Await])
    (...BindingPattern[?Yield, ?Await])
    (Expression[+In, ?Yield, ?Await],...BindingIdentifier[?Yield, ?Await])
    (Expression[+In, ?Yield, ?Await],...BindingPattern[?Yield, ?Await])

### è¡¥å……è¯­æ³•(Supplemental Syntax)

å¤„ç†äº§ç”Ÿå¼å®ä¾‹æ—¶

PrimaryExpression[Yield, Await]:CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] 

CoverInsulatedExpressionAndArrowParameterListçš„è§£é‡Šä½¿ç”¨ä»¥ä¸‹è¯­æ³•è¿›è¡Œäº†ä¼˜åŒ–ï¼š

ParenthesizedExpression[Yield, Await]:

    (Expression[+In, ?Yield, ?Await])

### 13.2.1 The this Keyword

PrimaryExpression:this

1. Return ? ResolveThisBinding().

### 13.2.2 Identifier Reference

See 13.1 for IdentifierReference.

### 13.2.3 å­—é¢é‡(Literals)

Syntax

    Literal:
        NullLiteral
        BooleanLiteral
        NumericLiteral
        StringLiteral

#### 13.2.3.1 Runtime Semantics: Evaluation
Literal:NullLiteral

1. Return null.

Literal:BooleanLiteral

1. å¦‚æœBooleanLiteralæ˜¯æ ‡è®°falseï¼Œåˆ™è¿”å›falseã€‚

2. å¦‚æœBooleanLiteralæ˜¯æ ‡è®°trueï¼Œåˆ™è¿”å›trueã€‚

Literal:NumericLiteral

1. è¿”å›11.8.3ä¸­å®šä¹‰çš„NumericLiteralçš„NumericValueã€‚

Literal:StringLiteral

1. è¿”å›11.8.4.1ä¸­å®šä¹‰çš„StringLiteralçš„StringValueã€‚


### 13.2.4 æ•°ç»„åˆå§‹å™¨(Array Initializer)

>NOTE ArrayLiteralæ˜¯ä¸€ä¸ªæè¿°æ•°ç»„å¯¹è±¡åˆå§‹åŒ–çš„è¡¨è¾¾å¼ï¼Œä½¿ç”¨ä¸€ä¸ªåˆ—è¡¨ï¼Œç”±é›¶ä¸ªæˆ–å¤šä¸ªè¡¨è¾¾å¼ç»„æˆï¼Œæ¯ä¸ªè¡¨è¾¾å¼éƒ½è¡¨ç¤ºä¸€ä¸ªæ•°ç»„å…ƒç´ ï¼Œç”¨æ–¹æ‹¬å·æ‹¬èµ·æ¥ã€‚å…ƒç´ ä¸å¿…æ˜¯å­—é¢é‡ï¼›æ¯æ¬¡å¯¹æ•°ç»„åˆå§‹å€¼è®¾å®šé¡¹è§£ææ—¶éƒ½ä¼šå¯¹å…¶æ±‚å€¼ã€‚

```
   [function(){return 1}()]       //è¿™é‡Œç›´æ¥ç”¨ä¸€ä¸ªæ‹¬å·å°±å¯è°ƒç”¨è¡¨è¾¾å¼
```

æ•°ç»„å…ƒç´ å¯ä»¥åœ¨å…ƒç´ åˆ—è¡¨çš„å¼€å¤´ã€ä¸­é—´æˆ–ç»“å°¾çœç•¥ã€‚æ¯å½“å…ƒç´ åˆ—è¡¨ä¸­çš„é€—å·å‰é¢æ²¡æœ‰AssignmentExpressionï¼ˆå³ï¼Œé€—å·ä½äºå¦ä¸€ä¸ªé€—å·çš„å¼€å¤´æˆ–åé¢ï¼‰æ—¶ï¼Œç¼ºå°‘çš„æ•°ç»„å…ƒç´ ä¼šå¢åŠ æ•°ç»„çš„é•¿åº¦ï¼Œå¹¶å¢åŠ åç»­å…ƒç´ çš„ç´¢å¼•ã€‚æœªå®šä¹‰çœç•¥çš„æ•°ç»„å…ƒç´ ã€‚å¦‚æœæŸä¸ªå…ƒç´ åœ¨æ•°ç»„çš„æœ«å°¾è¢«çœç•¥ï¼Œåˆ™è¯¥å…ƒç´ ä¸ä¼šå½±å“æ•°ç»„çš„é•¿åº¦ã€‚

Syntax

    ArrayLiteral[Yield, Await]:
        [Elisionopt]
        [ElementList[?Yield, ?Await]]
        [ElementList[?Yield, ?Await],Elisionopt]
    ElementList[Yield, Await]:
        ElisionoptAssignmentExpression[+In, ?Yield, ?Await]
        ElisionoptSpreadElement[?Yield, ?Await]
        ElementList[?Yield, ?Await],ElisionoptAssignmentExpression[+In, ?Yield, ?Await]
        ElementList[?Yield, ?Await],ElisionoptSpreadElement[?Yield, ?Await]
    Elision:
        ,
        Elision,
    SpreadElement[Yield, Await]:
        ...AssignmentExpression[+In, ?Yield, ?Await]
    
#### 13.2.4.1 Runtime Semantics: æ•°ç»„ç´¯åŠ (ArrayAccumulation)

With parameters array and nextIndex.

1. Elision:,
2. Let len be nextIndex + 1.
3. Perform ? Set(array, "length", ğ”½(len), true).
4. NOTE: The above Set throws if len exceeds 232-1.
5. Return len.

Elision:Elision,

1. è¿”å›ä½¿ç”¨å‚æ•°arrayå’ŒnextIndex + 1å¯¹Elisionæ‰§è¡ŒArrayAccumulationçš„ç»“æœã€‚

ElementList:Elisionopt  AssignmentExpression

1. If Elision is present, then
    Set nextIndex to the result of performing ArrayAccumulation for Elision with arguments array and nextIndex.
    ReturnIfAbrupt(nextIndex).
2. Let initResult be the result of evaluating AssignmentExpression.
3. Let initValue be ? GetValue(initResult).
4. Let created be ! CreateDataPropertyOrThrow(array, ! ToString(ğ”½(nextIndex)), initValue).
5. Return nextIndex + 1.

ElementList:Elision<sub>opt</sub>  SpreadElement

1. å¦‚æœå­˜åœ¨çœç•¥ï¼Œé‚£ä¹ˆ

    1. ä½¿ç”¨arrayå’ŒnextIndexå‚æ•°å°†nextIndexè®¾ç½®ä¸ºå¯¹çœç•¥æ‰§è¡ŒArrayAccumulationçš„ç»“æœã€‚

    2. ReturnIfAbruptï¼ˆnextIndexï¼‰ã€‚

2. è¿”å›ä½¿ç”¨arrayå’ŒnextIndexå‚æ•°å¯¹SpreadElementæ‰§è¡ŒArrayAccumulationçš„ç»“æœã€‚

ElementList:ElementList,Elisionopt  AssignmentExpression

    Set nextIndex to the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.
    ReturnIfAbrupt(nextIndex).
    If Elision is present, then
        Set nextIndex to the result of performing ArrayAccumulation for Elision with arguments array and nextIndex.
        ReturnIfAbrupt(nextIndex).
    Let initResult be the result of evaluating AssignmentExpression.
    Let initValue be ? GetValue(initResult).
    Let created be ! CreateDataPropertyOrThrow(array, ! ToString(ğ”½(nextIndex)), initValue).
    Return nextIndex + 1.

ElementList:ElementList,Elisionopt  SpreadElement

    Set nextIndex to the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.
    ReturnIfAbrupt(nextIndex).
    If Elision is present, then
        Set nextIndex to the result of performing ArrayAccumulation for Elision with arguments array and nextIndex.
        ReturnIfAbrupt(nextIndex).
    Return the result of performing ArrayAccumulation for SpreadElement with arguments array and nextIndex.

SpreadElement:...AssignmentExpression

    Let spreadRef be the result of evaluating AssignmentExpression.
    Let spreadObj be ? GetValue(spreadRef).
    Let iteratorRecord be ? GetIterator(spreadObj).
    Repeat,
        Let next be ? IteratorStep(iteratorRecord).
        If next is false, return nextIndex.
        Let nextValue be ? IteratorValue(next).
        Perform ! CreateDataPropertyOrThrow(array, ! ToString(ğ”½(nextIndex)), nextValue).
        Set nextIndex to nextIndex + 1.


> NOTE CreateDataPropertyOrThrowç”¨äºç¡®ä¿ä¸ºæ•°ç»„å®šä¹‰è‡ªå·±çš„å±æ€§ï¼Œå³ä½¿æ ‡å‡†å†…ç½®æ•°ç»„åŸå‹å¯¹è±¡çš„ä¿®æ”¹æ–¹å¼ä¼šé˜»æ­¢ä½¿ç”¨[[Set]]åˆ›å»ºæ–°çš„è‡ªå·±çš„å±æ€§ã€‚

#### 13.2.4.2 Runtime Semantics: Evaluation

ArrayLiteral:[Elisionopt]

    Let array be ! ArrayCreate(0).
    If Elision is present, then
        Let len be the result of performing ArrayAccumulation for Elision with arguments array and 0.
        ReturnIfAbrupt(len).
    Return array.

ArrayLiteral:[ElementList]

    Let array be ! ArrayCreate(0).
    Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.
    ReturnIfAbrupt(len).
    Return array.
ArrayLiteral:[ElementList,Elisionopt]

    Let array be ! ArrayCreate(0).
    Let nextIndex be the result of performing ArrayAccumulation for ElementList with arguments array and 0.
    ReturnIfAbrupt(nextIndex).
    If Elision is present, then
        Let len be the result of performing ArrayAccumulation for Elision with arguments array and nextIndex.
        ReturnIfAbrupt(len).
    Return array.

### 13.2.5 Object Initializer

NOTE1 å¯¹è±¡åˆå§‹å€¼è®¾å®šé¡¹æ˜¯æè¿°å¯¹è±¡åˆå§‹åŒ–çš„è¡¨è¾¾å¼ï¼Œä»¥ç±»ä¼¼äºæ–‡æœ¬çš„å½¢å¼ç¼–å†™ã€‚å®ƒæ˜¯ä¸€ä¸ªåŒ…å«é›¶å¯¹æˆ–å¤šå¯¹å±æ€§é”®å’Œç›¸å…³å€¼çš„åˆ—è¡¨ï¼Œç”¨èŠ±æ‹¬å·æ‹¬èµ·æ¥ã€‚ä¸éœ€è¦å¯¹åˆå§‹å€¼è®¾å®šé¡¹æ±‚å€¼ï¼›æ¯ä¸ªå€¼éƒ½æ˜¯åˆå§‹åŒ–å€¼ã€‚


Syntax

    ObjectLiteral[Yield, Await]:
        {}
        {PropertyDefinitionList[?Yield, ?Await]}
        {PropertyDefinitionList[?Yield, ?Await],}
    PropertyDefinitionList[Yield, Await]:
        PropertyDefinition[?Yield, ?Await]
        PropertyDefinitionList[?Yield, ?Await],PropertyDefinition[?Yield, ?Await]
    PropertyDefinition[Yield, Await]:
        IdentifierReference[?Yield, ?Await]
        CoverInitializedName[?Yield, ?Await]
        PropertyName[?Yield, ?Await]:AssignmentExpression[+In, ?Yield, ?Await]
        MethodDefinition[?Yield, ?Await]
        ...AssignmentExpression[+In, ?Yield, ?Await]
    PropertyName[Yield, Await]:
        LiteralPropertyName
        ComputedPropertyName[?Yield, ?Await]
    LiteralPropertyName:
        IdentifierName
        StringLiteral
        NumericLiteral
    ComputedPropertyName[Yield, Await]:
        [AssignmentExpression[+In, ?Yield, ?Await]]
    CoverInitializedName[Yield, Await]:
        IdentifierReference[?Yield, ?Await]Initializer[+In, ?Yield, ?Await]
    Initializer[In, Yield, Await]:
        =AssignmentExpression[?In, ?Yield, ?Await]


> NOTE2 MethodDefinition is defined in 15.4.

> NOTE3 åœ¨æŸäº›æƒ…å†µä¸‹ï¼ŒObjectLiteralç”¨ä½œè¦†ç›–è¯­æ³•ï¼Œç”¨äºæ›´ä¸¥æ ¼çš„è¾…åŠ©è¯­æ³•ã€‚ CoverInitializedNameç”Ÿæˆå¯¹äºå®Œå…¨è¦†ç›–è¿™äº›è¾…åŠ©è¯­æ³•æ˜¯å¿…éœ€çš„ã€‚ ä½†æ˜¯ï¼Œåœ¨é€šå¸¸éœ€è¦å®é™…ObjectLiteralçš„æ­£å¸¸æƒ…å†µä¸‹ï¼Œä½¿ç”¨è¿™ç§äº§ç”Ÿæ–¹å¼ä¼šå¯¼è‡´æ—©æœŸçš„è¯­æ³•é”™è¯¯ã€‚

#### 13.2.5.1 Static Semantics: Early Errors
PropertyDefinition:MethodDefinition

- å¦‚æœMethodDefinitionçš„HasDirectSuperä¸ºtrueï¼Œåˆ™ä¸ºè¯­æ³•é”™è¯¯ã€‚
- å¦‚æœ MethodDefinition çš„ PrivateBoundIdentifiers ä¸ä¸ºç©ºï¼Œåˆ™ä¸ºè¯­æ³•é”™è¯¯ã€‚

é™¤äº†æè¿°å®é™…çš„å¯¹è±¡åˆå§‹å€¼è®¾å®šé¡¹å¤–ï¼ŒObjectLiteralç”Ÿæˆé¡¹è¿˜ç”¨ä½œObjectAssignmentPatternçš„è¦†ç›–è¯­æ³•ï¼Œå¹¶ä¸”å¯ä»¥è¢«è¯†åˆ«ä¸ºCoverInsulatedExpressionAndArrowParameterListçš„ä¸€éƒ¨åˆ†ã€‚å½“ObjectLiteralå‡ºç°åœ¨éœ€è¦ObjectAssignmentPatternçš„ä¸Šä¸‹æ–‡ä¸­æ—¶ï¼Œä¸åº”ç”¨ä»¥ä¸‹æ—©æœŸé”™è¯¯è§„åˆ™ã€‚æ­¤å¤–ï¼Œåœ¨æœ€åˆè§£æcoverCallExpressionAndArrowParameterListæˆ–CoverCallExpressionAndAsyncArrowHeadæ—¶ï¼Œå®ƒä»¬ä¸ä¼šåº”ç”¨ã€‚

PropertyDefinition:CoverInitializedName

- å¦‚æœä»£ç ä¸æ­¤äº§ç”Ÿå¼åŒ¹é…ï¼Œåˆ™å§‹ç»ˆå¼•å‘è¯­æ³•é”™è¯¯ã€‚

> NOTE1 è¿™ç§äº§ç”Ÿå¼çš„å­˜åœ¨ä½¿å¾—ObjectLiteralå¯ä»¥ä½œä¸ºObjectAssignmentPatternçš„è¦†ç›–è¯­æ³•ã€‚å®ƒä¸èƒ½å‘ç”Ÿåœ¨å®é™…çš„å¯¹è±¡åˆå§‹å€¼è®¾å®šé¡¹ä¸­ã€‚

ObjectLiteral :

    { PropertyDefinitionList }
    { PropertyDefinitionList , }

- å¦‚æœ PropertyDefinitionList çš„ PropertyNameList åŒ…å«â€œ__proto__â€çš„ä»»ä½•é‡å¤æ¡ç›®å¹¶ä¸”è¿™äº›æ¡ç›®ä¸­çš„è‡³å°‘ä¸¤ä¸ªæ˜¯ä» PropertyDefinition : PropertyName : AssignmentExpression å½¢å¼çš„äº§ç”Ÿä¸­è·å¾—çš„ï¼Œåˆ™è¿™æ˜¯ä¸€ä¸ªè¯­æ³•é”™è¯¯ã€‚å¦‚æœæ­¤ ObjectLiteral åŒ…å«åœ¨ä¸º JSON.parse è§£æçš„è„šæœ¬ä¸­ï¼Œåˆ™ä¸åº”ç”¨æ­¤è§„åˆ™ï¼ˆè¯·å‚é˜… JSON.parse çš„ç¬¬ 4 æ­¥ï¼‰ã€‚

>NOTE2 PropertyNameListè¿”å›çš„åˆ—è¡¨ä¸åŒ…æ‹¬ä½¿ç”¨ComputedPropertyNameå®šä¹‰çš„å±æ€§åç§°ã€‚

```
a = {a:1, b:2, [this.a+this.b]:3}
```

#### 13.2.5.2 Static Semantics: ComputedPropertyContains

è¯­æ³•æŒ‡å¯¼çš„æ“ä½œ IsComputedPropertyKey ä¸æ¥å—ä»»ä½•å‚æ•°å¹¶è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ã€‚å®ƒåœ¨ä»¥ä¸‹äº§ç”Ÿå¼ä¸Šåˆ†æ®µå®šä¹‰ï¼š

PropertyName:LiteralPropertyName

    1. Return false.

PropertyName:ComputedPropertyName

    1. Return true.

#### 13.2.5.3 Static Semantics: PropertyNameList

è¯­æ³•æŒ‡å¯¼çš„æ“ä½œ PropertyNameList ä¸æ¥å—ä»»ä½•å‚æ•°å¹¶è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ã€‚å®ƒåœ¨ä»¥ä¸‹äº§ç”Ÿå¼ä¸Šåˆ†æ®µå®šä¹‰ï¼š

PropertyDefinitionList : PropertyDefinition

1. Let propName be PropName of PropertyDefinition.
2. If propName is empty, return a new empty List.
3. Return Â« propName Â».

PropertyDefinitionList : PropertyDefinitionList , PropertyDefinition

1. Let list be PropertyNameList of PropertyDefinitionList.
2. Let propName be PropName of PropertyDefinition.
3. If propName is empty, return list.
4. Return the list-concatenation of list and Â« propName Â».

#### 13.2.5.4 Runtime Semantics: Evaluation

ObjectLiteral : { }

1. Return OrdinaryObjectCreate(%Object.prototype%).

ObjectLiteral :

    { PropertyDefinitionList }
    { PropertyDefinitionList , }

1. Let obj be OrdinaryObjectCreate(%Object.prototype%).
2. Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with argument obj.
3. Return obj.

LiteralPropertyName : IdentifierName

1. Return StringValue of IdentifierName.

LiteralPropertyName : StringLiteral

1. Return the SV of StringLiteral.

LiteralPropertyName : NumericLiteral

1. Let nbr be the NumericValue of NumericLiteral.
2. Return ! ToString(nbr).

```
{070:2} 
//{56:2}
```

ComputedPropertyName : [ AssignmentExpression ]

1. Let exprValue be the result of evaluating AssignmentExpression.
2. Let propName be ? GetValue(exprValue).
3. Return ? ToPropertyKey(propName).

```
a = {[3||2]:1}
b={...[1,2,3]}
```

#### 13.2.5.5 Runtime Semantics: PropertyDefinitionEvaluation

The syntax-directed operation PropertyDefinitionEvaluation takes argument object and returns either a normal completion containing unused or an abrupt completion. It is defined piecewise over the following productions:

PropertyDefinitionList : PropertyDefinitionList , PropertyDefinition
1. Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with argument object.
2. Perform ? PropertyDefinitionEvaluation of PropertyDefinition with argument object.
3. Return unused.

PropertyDefinition : ... AssignmentExpression

1. Let exprValue be the result of evaluating AssignmentExpression.
2. Let fromValue be ? GetValue(exprValue).
3. Let excludedNames be a new empty List.
4. Perform ? CopyDataProperties(object, fromValue, excludedNames).
5. Return unused.

PropertyDefinition : IdentifierReference

1. Let propName be StringValue of IdentifierReference.
2. Let exprValue be the result of evaluating IdentifierReference.
3. Let propValue be ? GetValue(exprValue).
4. Assert: object is an ordinary, extensible object with no non-configurable properties.
5. Perform ! CreateDataPropertyOrThrow(object, propName, propValue).
6. Return unused.


PropertyDefinition : PropertyName : AssignmentExpression

1. Let propKey be the result of evaluating PropertyName.
2. ReturnIfAbrupt(propKey).
3. If this PropertyDefinition is contained within a Script that is being evaluated for JSON.parse (see step 7 of JSON.parse), then
    - Let isProtoSetter be false.
4. Else if propKey is the String value "__proto__" and if IsComputedPropertyKey of PropertyName is false, then
    - Let isProtoSetter be true.
5. Else,
    - Let isProtoSetter be false.
6. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and isProtoSetter is false, then
    - Let propValue be ? NamedEvaluation of AssignmentExpression with argument propKey.
7. Else,
    - Let exprValueRef be the result of evaluating AssignmentExpression.
    - Let propValue be ? GetValue(exprValueRef).
8. If isProtoSetter is true, then
    - If Type(propValue) is either Object or Null, then
        - Perform ! object.[[SetPrototypeOf]](propValue).
    - Return unused.
9. Assert: object is an ordinary, extensible object with no non-configurable properties.
10. Perform ! CreateDataPropertyOrThrow(object, propKey, propValue).
11. Return unused.

PropertyDefinition : MethodDefinition

1. Perform ? MethodDefinitionEvaluation of MethodDefinition with arguments object and true.
2. Return unused.

### 13.2.6 Function Defining Expressions

See 15.2 for PrimaryExpression : FunctionExpression .

See 15.5 for PrimaryExpression : GeneratorExpression .

See 15.7 for PrimaryExpression : ClassExpression .

See 15.8 for PrimaryExpression : AsyncFunctionExpression .

See 15.6 for PrimaryExpression : AsyncGeneratorExpression .

### 13.2.7 Regular Expression Literals

Syntax

See 12.8.5.

#### 13.2.7.1 Static Semantics: Early Errors

PrimaryExpression : RegularExpressionLiteral

- It is a Syntax Error if IsValidRegularExpressionLiteral(RegularExpressionLiteral) is false.

#### 13.2.7.2 Static Semantics: IsValidRegularExpressionLiteral ( literal )

The abstract operation IsValidRegularExpressionLiteral takes argument literal (a RegularExpressionLiteral Parse Node) and returns a Boolean. It determines if its argument is a valid regular expression literal. It performs the following steps when called:

1. If FlagText of literal contains any code points other than g, i, m, s, u, or y, or if it contains the same code point more than once, return false.
2. Let patternText be BodyText of literal.
3. If FlagText of literal contains u, let u be true; else let u be false.
4. If u is false, then
    - Let stringValue be CodePointsToString(patternText).
    - Set patternText to the sequence of code points resulting from interpreting each of the 16-bit elements of stringValue as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.
5. Let parseResult be ParsePattern(patternText, u).
6. If parseResult is a Parse Node, return true; else return false.

#### 13.2.7.3 Runtime Semantics: Evaluation

PrimaryExpression : RegularExpressionLiteral
1. Let pattern be CodePointsToString(BodyText of RegularExpressionLiteral).
2. Let flags be CodePointsToString(FlagText of RegularExpressionLiteral).
3. Return ! RegExpCreate(pattern, flags).

### 13.2.8 Template Literals

Syntax


    TemplateLiteral[Yield, Await, Tagged] :
        NoSubstitutionTemplate
        SubstitutionTemplate[?Yield, ?Await, ?Tagged]
    SubstitutionTemplate[Yield, Await, Tagged] :
        TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
    TemplateSpans[Yield, Await, Tagged] :
        TemplateTail
        TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail
    TemplateMiddleList[Yield, Await, Tagged] :
        TemplateMiddle Expression[+In, ?Yield, ?Await]
        TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]

#### 13.2.8.1 Static Semantics: Early Errors

TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate
- It is a Syntax Error if the [Tagged] parameter was not set and NoSubstitutionTemplate Contains NotEscapeSequence.
TemplateLiteral[Yield, Await, Tagged] : SubstitutionTemplate[?Yield, ?Await, ?Tagged]
- It is a Syntax Error if the number of elements in the result of TemplateStrings of TemplateLiteral with argument false is greater than 232 - 1.
SubstitutionTemplate[Yield, Await, Tagged] : TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
- It is a Syntax Error if the [Tagged] parameter was not set and TemplateHead Contains NotEscapeSequence.
TemplateSpans[Yield, Await, Tagged] : TemplateTail
- It is a Syntax Error if the [Tagged] parameter was not set and TemplateTail Contains NotEscapeSequence.
TemplateMiddleList[Yield, Await, Tagged] :
TemplateMiddle Expression[+In, ?Yield, ?Await]
TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
- It is a Syntax Error if the [Tagged] parameter was not set and TemplateMiddle Contains NotEscapeSequence.

#### 13.2.8.2 Static Semantics: TemplateStrings

The syntax-directed operation TemplateStrings takes argument raw and returns a List of Strings. It is defined piecewise over the following productions:

TemplateLiteral : NoSubstitutionTemplate
1. If raw is false, then
    - Let string be the TV of NoSubstitutionTemplate.
2. Else,
    - Let string be the TRV of NoSubstitutionTemplate.
3. Return Â« string Â».


SubstitutionTemplate : TemplateHead Expression TemplateSpans
1. If raw is false, then
    - Let head be the TV of TemplateHead.
2. Else,
    - Let head be the TRV of TemplateHead.
3. Let tail be TemplateStrings of TemplateSpans with argument raw.
4. Return the list-concatenation of Â« head Â» and tail.

TemplateSpans : TemplateTail
1. If raw is false, then
    - Let tail be the TV of TemplateTail.
2. Else,
    - Let tail be the TRV of TemplateTail.
3. Return Â« tail Â».


TemplateSpans : TemplateMiddleList TemplateTail
1. Let middle be TemplateStrings of TemplateMiddleList with argument raw.
2. If raw is false, then
    - Let tail be the TV of TemplateTail.
3. Else,
    - Let tail be the TRV of TemplateTail.
4. Return the list-concatenation of middle and Â« tail Â».

TemplateMiddleList : TemplateMiddle Expression
1. If raw is false, then
    - Let string be the TV of TemplateMiddle.
2. Else,
    - Let string be the TRV of TemplateMiddle.
3. Return Â« string Â».

TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
1. Let front be TemplateStrings of TemplateMiddleList with argument raw.
2. If raw is false, then
    - Let last be the TV of TemplateMiddle.
3. Else,
    - Let last be the TRV of TemplateMiddle.
4. Return the list-concatenation of front and Â« last Â».

#### 13.2.8.3 GetTemplateObject ( templateLiteral )

The abstract operation GetTemplateObject takes argument templateLiteral (a Parse Node) and returns an Array. It performs the following steps when called:

1. Let realm be the current Realm Record.
2. Let templateRegistry be realm.[[TemplateMap]].
3. For each element e of templateRegistry, do
    - If e.[[Site]] is the same Parse Node as templateLiteral, then
        - Return e.[[Array]].
4. Let rawStrings be TemplateStrings of templateLiteral with argument true.
5. Let cookedStrings be TemplateStrings of templateLiteral with argument false.
6. Let count be the number of elements in the List cookedStrings.
7. Assert: count â‰¤ 232 - 1.
8. Let template be ! ArrayCreate(count).
9. Let rawObj be ! ArrayCreate(count).
10. Let index be 0.
11. Repeat, while index < count,
    - Let prop be ! ToString(ğ”½(index)).
    - Let cookedValue be cookedStrings[index].
    - Perform ! DefinePropertyOrThrow(template, prop, PropertyDescriptor { [[Value]]: cookedValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }).
    - Let rawValue be the String value rawStrings[index].
    - Perform ! DefinePropertyOrThrow(rawObj, prop, PropertyDescriptor { [[Value]]: rawValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }).
    - Set index to index + 1.
12. Perform ! SetIntegrityLevel(rawObj, frozen).
13. Perform ! DefinePropertyOrThrow(template, "raw", PropertyDescriptor { [[Value]]: rawObj, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).
14. Perform ! SetIntegrityLevel(template, frozen).
15. Append the Record { [[Site]]: templateLiteral, [[Array]]: template } to templateRegistry.
16. Return template.

> NOTE1 The creation of a template object cannot result in an abrupt completion.

> NOTE2 é¢†åŸŸçš„ç¨‹åºä»£ç ä¸­çš„æ¯ä¸ª TemplateLiteral éƒ½ä¸ä¸€ä¸ªå”¯ä¸€çš„æ¨¡æ¿å¯¹è±¡ç›¸å…³è”ï¼Œè¯¥æ¨¡æ¿å¯¹è±¡ç”¨äºè¯„ä¼°æ ‡è®°æ¨¡æ¿ (13.2.8.5)ã€‚æ¨¡æ¿å¯¹è±¡è¢«å†»ç»“ï¼Œå¹¶ä¸”æ¯æ¬¡è¯„ä¼°ç‰¹å®šæ ‡è®°æ¨¡æ¿æ—¶ä½¿ç”¨ç›¸åŒçš„æ¨¡æ¿å¯¹è±¡ã€‚æ¨¡æ¿å¯¹è±¡æ˜¯åœ¨ç¬¬ä¸€æ¬¡è¯„ä¼° TemplateLiteral æ—¶å»¶è¿Ÿåˆ›å»ºè¿˜æ˜¯åœ¨ç¬¬ä¸€æ¬¡è¯„ä¼°ä¹‹å‰æ€¥åˆ‡åœ°åˆ›å»ºï¼Œè¿™æ˜¯ ECMAScript ä»£ç æ— æ³•è§‚å¯Ÿåˆ°çš„å®ç°é€‰æ‹©ã€‚

> NOTE3 æœ¬è§„èŒƒçš„æœªæ¥ç‰ˆæœ¬å¯èƒ½ä¼šå®šä¹‰æ¨¡æ¿å¯¹è±¡çš„å…¶ä»–ä¸å¯æšä¸¾å±æ€§ã€‚

### 13.2.8.4 Runtime Semantics: SubstitutionEvaluation

The syntax-directed operation SubstitutionEvaluation takes no arguments and returns either a normal completion containing a List of ECMAScript language values or an abrupt completion. It is defined piecewise over the following productions:

TemplateSpans : TemplateTail

1. Return a new empty List.

TemplateSpans : TemplateMiddleList TemplateTail

1. Return ? SubstitutionEvaluation of TemplateMiddleList.

TemplateMiddleList : TemplateMiddle Expression

1. Let subRef be the result of evaluating Expression.
2. Let sub be ? GetValue(subRef).
3. Return Â« sub Â».

TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression

1. Let preceding be ? SubstitutionEvaluation of TemplateMiddleList.
2. Let nextRef be the result of evaluating Expression.
3. Let next be ? GetValue(nextRef).
4. Return the list-concatenation of preceding and Â« next Â».

#### 13.2.8.5 Runtime Semantics: Evaluation

TemplateLiteral : NoSubstitutionTemplate

1. Return the TV of NoSubstitutionTemplate as defined in 12.8.6.

SubstitutionTemplate : TemplateHead Expression TemplateSpans

1. Let head be the TV of TemplateHead as defined in 12.8.6.
2. Let subRef be the result of evaluating Expression.
3. Let sub be ? GetValue(subRef).
4. Let middle be ? ToString(sub).
5. Let tail be the result of evaluating TemplateSpans.
6. ReturnIfAbrupt(tail).
7. Return the string-concatenation of head, middle, and tail.

> NOTE1 åº”ç”¨äº Expression å€¼çš„å­—ç¬¦ä¸²è½¬æ¢è¯­ä¹‰ç±»ä¼¼äº String.prototype.concat è€Œä¸æ˜¯ + è¿ç®—ç¬¦ã€‚

TemplateSpans : TemplateTail

1. Return the TV of TemplateTail as defined in 12.8.6.

TemplateSpans : TemplateMiddleList TemplateTail

1. Let head be the result of evaluating TemplateMiddleList.
2. ReturnIfAbrupt(head).
3. Let tail be the TV of TemplateTail as defined in 12.8.6.
4. Return the string-concatenation of head and tail.

TemplateMiddleList : TemplateMiddle Expression

1. Let head be the TV of TemplateMiddle as defined in 12.8.6.
2. Let subRef be the result of evaluating Expression.
3. Let sub be ? GetValue(subRef).
4. Let middle be ? ToString(sub).
5. Return the string-concatenation of head and middle.

> NOTE2 åº”ç”¨äº Expression å€¼çš„å­—ç¬¦ä¸²è½¬æ¢è¯­ä¹‰ç±»ä¼¼äº String.prototype.concat è€Œä¸æ˜¯ + è¿ç®—ç¬¦ã€‚

TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression

1. Let rest be the result of evaluating TemplateMiddleList.
2. ReturnIfAbrupt(rest).
3. Let middle be the TV of TemplateMiddle as defined in 12.8.6.
4. Let subRef be the result of evaluating Expression.
5. Let sub be ? GetValue(subRef).
6. Let last be ? ToString(sub).
7. Return the string-concatenation of rest, middle, and last.

> NOTE3 åº”ç”¨äº Expression å€¼çš„å­—ç¬¦ä¸²è½¬æ¢è¯­ä¹‰ç±»ä¼¼äº String.prototype.concat è€Œä¸æ˜¯ + è¿ç®—ç¬¦ã€‚

### 13.2.9 The Grouping Operator

#### 13.2.9.1 Static Semantics: Early Errors

- CoverParenthesizedExpressionAndArrowParameterList å¿…é¡»è¦†ç›–ä¸€ä¸ªæ‹¬å·è¡¨è¾¾å¼ã€‚

#### 13.2.9.2 Runtime Semantics: Evaluation

PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList

1. Let expr be the ParenthesizedExpression that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. Return the result of evaluating expr.

ParenthesizedExpression : ( Expression )

1. Return the result of evaluating Expression. This may be of type Reference.

>NOTE æ­¤ç®—æ³•ä¸ä¼šå°† GetValue åº”ç”¨äºè®¡ç®—è¡¨è¾¾å¼çš„ç»“æœã€‚è¿™æ ·åšçš„ä¸»è¦åŠ¨æœºæ˜¯å¯ä»¥å°†è¯¸å¦‚ delete å’Œ typeof ä¹‹ç±»çš„è¿ç®—ç¬¦åº”ç”¨äºå¸¦æ‹¬å·çš„è¡¨è¾¾å¼ã€‚

```
delete (alert, console) 
//æœªåˆ é™¤
delete (console)
//åˆ é™¤äº†console
```