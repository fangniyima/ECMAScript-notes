## 13.4 Update Expressions

Syntax

    UpdateExpression[Yield, Await] :
        LeftHandSideExpression[?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] ++
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] --
        ++ UnaryExpression[?Yield, ?Await]
        -- UnaryExpression[?Yield, ?Await]

### 13.4.1 Static Semantics: Early Errors

    UpdateExpression :
        LeftHandSideExpression ++
        LeftHandSideExpression --

- It is an early Syntax Error if AssignmentTargetType of LeftHandSideExpression is not simple.
```
    UpdateExpression :
        ++ UnaryExpression
        -- UnaryExpression
```
- It is an early Syntax Error if AssignmentTargetType of UnaryExpression is not simple.

### Postfix Increment Operator(åç¼€å¢é‡è¿ç®—ç¬¦)

#### 13.4.2.1 Runtime Semantics: Evaluation

UpdateExpression : LeftHandSideExpression ++

1. Let lhs be the result of evaluating LeftHandSideExpression.
2. Let oldValue be ? ToNumeric(? GetValue(lhs)).
3. If Type(oldValue) is Number, then
    - Let newValue be Number::add(oldValue, 1ğ”½).
4. Else,
    - Assert: Type(oldValue) is BigInt.
    - Let newValue be BigInt::add(oldValue, 1â„¤).
5. Perform ? PutValue(lhs, newValue).
6. Return oldValue.

### 13.4.3 Postfix Decrement Operator

#### 13.4.3.1 Runtime Semantics: Evaluation

UpdateExpression : LeftHandSideExpression --

1. Let lhs be the result of evaluating LeftHandSideExpression.
2. Let oldValue be ? ToNumeric(? GetValue(lhs)).
3. If Type(oldValue) is Number, then
     Let newValue be Number::subtract(oldValue, 1ğ”½).
4. Else,
     Assert: Type(oldValue) is BigInt.
     Let newValue be BigInt::subtract(oldValue, 1â„¤).
5. Perform ? PutValue(lhs, newValue).
6. Return oldValue.


### 13.4.4 Prefix Increment Operator

#### 13.4.4.1 Runtime Semantics: Evaluation

UpdateExpression : ++ UnaryExpression

1. Let expr be the result of evaluating UnaryExpression.
2. Let oldValue be ? ToNumeric(? GetValue(expr)).
3. If Type(oldValue) is Number, then
    - Let newValue be Number::add(oldValue, 1ğ”½).
4. Else,
    - Assert: Type(oldValue) is BigInt.
    - Let newValue be BigInt::add(oldValue, 1â„¤).
5. Perform ? PutValue(expr, newValue).
6. Return newValue.

### 13.4.5 Prefix Decrement Operator

#### 13.4.5.1 Runtime Semantics: Evaluation

UpdateExpression : -- UnaryExpression

1. Let expr be the result of evaluating UnaryExpression.
2. Let oldValue be ? ToNumeric(? GetValue(expr)).
3. If Type(oldValue) is Number, then
    - Let newValue be Number::subtract(oldValue, 1ğ”½).
4. Else,
    - Assert: Type(oldValue) is BigInt.
    - Let newValue be BigInt::subtract(oldValue, 1â„¤).
5. Perform ? PutValue(expr, newValue).
6. Return newValue.

## 13.5 Unary Operators

Syntax

    UnaryExpression[Yield, Await] :
        UpdateExpression[?Yield, ?Await]
        delete UnaryExpression[?Yield, ?Await]
        void UnaryExpression[?Yield, ?Await]
        typeof UnaryExpression[?Yield, ?Await]
        + UnaryExpression[?Yield, ?Await]
        - UnaryExpression[?Yield, ?Await]
        ~ UnaryExpression[?Yield, ?Await]
        ! UnaryExpression[?Yield, ?Await]
        [+Await] AwaitExpression[?Yield]

### 13.5.1 The delete Operator

#### 13.5.1.1 Static Semantics: Early Errors

UnaryExpression : delete UnaryExpression

- It is a Syntax Error if the UnaryExpression is contained in strict mode code and the derived UnaryExpression is PrimaryExpression : IdentifierReference , MemberExpression : MemberExpression . PrivateIdentifier , CallExpression : CallExpression . PrivateIdentifier , OptionalChain : ?. PrivateIdentifier , or OptionalChain : OptionalChain . PrivateIdentifier .

- å¦‚æœæ´¾ç”Ÿçš„ UnaryExpression æ˜¯ PrimaryExpression ï¼Œåˆ™ä¸ºè¯­æ³•é”™è¯¯ï¼š CoverParenthesizedExpressionAndArrowParameterList å’Œ CoverParenthesizedExpressionAndArrowParameterList æœ€ç»ˆæ´¾ç”Ÿå‡ºä¸€ä¸ªçŸ­è¯­ï¼Œå¦‚æœä½¿ç”¨è¯¥çŸ­è¯­ä»£æ›¿ UnaryExpressionï¼Œå°†æ ¹æ®è¿™äº›è§„åˆ™äº§ç”Ÿè¯­æ³•é”™è¯¯ã€‚è¯¥è§„åˆ™æ˜¯é€’å½’åº”ç”¨çš„ã€‚

>æœ€åä¸€æ¡è§„åˆ™æ„å‘³ç€è¯¸å¦‚ delete (((foo))) ä¹‹ç±»çš„è¡¨è¾¾å¼ä¼šç”±äºç¬¬ä¸€æ¡è§„åˆ™çš„é€’å½’åº”ç”¨è€Œäº§ç”Ÿæ—©æœŸé”™è¯¯ã€‚

#### 13.5.1.2 Runtime Semantics: Evaluation

UnaryExpression : delete UnaryExpression

1. Let ref be the result of evaluating UnaryExpression.
2. ReturnIfAbrupt(ref).
3. If ref is not a Reference Record, return true.
4. If IsUnresolvableReference(ref) is true, then
    - Assert: ref.[[Strict]] is false.
    - Return true.
5. If IsPropertyReference(ref) is true, then
    - Assert: IsPrivateReference(ref) is false.
    - If IsSuperReference(ref) is true, throw a ReferenceError exception.
    - Let baseObj be ? ToObject(ref.[[Base]]).
    - Let deleteStatus be ? baseObj.[[Delete]](ref.[[ReferencedName]]).
    - If deleteStatus is false and ref.[[Strict]] is true, throw a TypeError exception.
    - Return deleteStatus.
6. Else,
    - Let base be ref.[[Base]].
    - Assert: base is an Environment Record.
    - Return ? base.DeleteBinding(ref.[[ReferencedName]]).

>NOTE1 å½“deleteè¿ç®—ç¬¦å‡ºç°åœ¨ä¸¥æ ¼æ¨¡å¼ä»£ç ä¸­æ—¶ï¼Œå¦‚æœå…¶ UnaryExpression æ˜¯å¯¹å˜é‡ã€å‡½æ•°å‚æ•°æˆ–å‡½æ•°åçš„ç›´æ¥å¼•ç”¨(æœªé™å®šæ ‡è¯†ç¬¦)ï¼Œåˆ™ä¼šå¼•å‘ SyntaxError å¼‚å¸¸ã€‚æ­¤å¤–ï¼Œå¦‚æœåˆ é™¤æ“ä½œç¬¦å‡ºç°åœ¨ä¸¥æ ¼æ¨¡å¼ä»£ç ä¸­å¹¶ä¸”è¦åˆ é™¤çš„å±æ€§å…·æœ‰å±æ€§ { [[Configurable]]: false } ï¼ˆå¦åˆ™æ— æ³•åˆ é™¤ï¼‰ï¼Œåˆ™ä¼šå¼•å‘ TypeError å¼‚å¸¸ã€‚

>NOTE2 æ­¥éª¤ 5.c ä¸­å¯èƒ½åˆ›å»ºçš„å¯¹è±¡åœ¨ä¸Šè¿°æŠ½è±¡æ“ä½œå’Œæ™®é€šå¯¹è±¡ [[Delete]] å†…éƒ¨æ–¹æ³•ä¹‹å¤–æ˜¯ä¸å¯è®¿é—®çš„ã€‚å®ç°å¯èƒ½ä¼šé€‰æ‹©é¿å…å®é™…åˆ›å»ºè¯¥å¯¹è±¡ã€‚

### 13.5.2 The void Operator

#### 13.5.2.1 Runtime Semantics: Evaluation

UnaryExpression : void UnaryExpression

1. Let expr be the result of evaluating UnaryExpression.
2. Perform ? GetValue(expr).
3. Return undefined.

>NOTE GetValue must be called even though its value is not used because it may have observable side-effects.

### 13.5.3 The typeof Operator

#### 13.5.3.1 Runtime Semantics: Evaluation

UnaryExpression : typeof UnaryExpression

>NOTE å¯ä»¥åœ¨ B.3.6.3 ä¸­æ‰¾åˆ°ä¸ [[IsHTMLDDA]] å†…éƒ¨æ’æ§½ç›¸å…³çš„é™„åŠ æ¡ç›®ã€‚

1. Let val be the result of evaluating UnaryExpression.
2. If val is a Reference Record, then
    - If IsUnresolvableReference(val) is true, return "undefined".
3. Set val to ? GetValue(val).
4. NOTE: This step is replaced in section B.3.6.3.
5. Return a String according to Table 41.

<center>Table 41: typeof Operator Results</center>

|Type of val|Result|
|Undefined|"undefined"|
|Null|"object"|
|Boolean|"boolean"|
|Number|"number"|
|String|"string"|
|Symbol|"symbol"|
|BigInt|"bigint"|
|Object (does not implement [[Call]])|"object"|
|Object (implements [[Call]])|"function"|

### 13.5.4 Unary + Operator

>NOTE  The unary + operator converts its operand to Number type.

UnaryExpression : + UnaryExpression

1. Let expr be the result of evaluating UnaryExpression.
2. Return ? ToNumber(? GetValue(expr)).

### 13.5.5 Unary - Operator

> NOTE ä¸€å…ƒè¿ç®—ç¬¦å°†å…¶æ“ä½œæ•°è½¬æ¢ä¸ºæ•°å­—ç±»å‹ï¼Œç„¶åæ±‚åã€‚æ±‚å+0ğ”½ ç”Ÿäº§-0ğ”½, å¹¶å–å-0ğ”½ äº§ç”Ÿ+0ğ”½.

#### 13.5.5.1 Runtime Semantics: Evaluation

UnaryExpression : - UnaryExpression

1. Let expr be the result of evaluating UnaryExpression.
2. Let oldValue be ? ToNumeric(? GetValue(expr)).
3. Let T be Type(oldValue).
4. If Type(oldValue) is Number, then
    - Return Number::unaryMinus(oldValue).
5. Else,
    - Assert: Type(oldValue) is BigInt.
    - Return BigInt::unaryMinus(oldValue).


```
+2n
-2n
Number(2n)
new Number(2n)
```

### 13.5.6 Bitwise NOT Operator ( ~ )

#### 13.5.6.1 Runtime Semantics: Evaluation

UnaryExpression : ~ UnaryExpression

1. Let expr be the result of evaluating UnaryExpression.
2. Let oldValue be ? ToNumeric(? GetValue(expr)).
3. Let T be Type(oldValue).
4. If Type(oldValue) is Number, then
    - Return Number::bitwiseNOT(oldValue).
5. Else,
    - Assert: Type(oldValue) is BigInt.
    - Return BigInt::bitwiseNOT(oldValue).

### 13.5.7 Logical NOT Operator ( ! )

#### 13.5.7.1 Runtime Semantics: Evaluation

UnaryExpression : ! UnaryExpression

1. Let expr be the result of evaluating UnaryExpression.
2. Let oldValue be ToBoolean(? GetValue(expr)).
3. If oldValue is true, return false.
4. Return true.

## 13.6 Exponentiation Operator

Syntax

    ExponentiationExpression[Yield, Await] :
        UnaryExpression[?Yield, ?Await]
        UpdateExpression[?Yield, ?Await] ** ExponentiationExpression[?Yield, ?Await]

### 13.6.1 Runtime Semantics: Evaluation

ExponentiationExpression : UpdateExpression ** ExponentiationExpression

1. Return ? EvaluateStringOrNumericBinaryExpression(UpdateExpression, **, ExponentiationExpression).

## 13.7 Multiplicative Operators

Syntax

    MultiplicativeExpression[Yield, Await] :
    ExponentiationExpression[?Yield, ?Await]
    MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]
    MultiplicativeOperator : one of
    * / %

> NOTE
- The * operator performs multiplication, producing the product of its operands.
- The / operator performs division, producing the quotient of its operands.
- The % operator yields the remainder of its operands from an implied division.

### 13.7.1 Runtime Semantics: Evaluation

MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

1. Let opText be the source text matched by MultiplicativeOperator.
2. Return ? EvaluateStringOrNumericBinaryExpression(MultiplicativeExpression, opText, ExponentiationExpression).

## 13.8 Additive Operators

Syntax

    AdditiveExpression[Yield, Await] :
        MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] + MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] - MultiplicativeExpression[?Yield, ?Await]

### 13.8.1 The Addition Operator ( + )

>NOTE åŠ æ³•è¿ç®—ç¬¦æ‰§è¡Œå­—ç¬¦ä¸²ä¸²è”æˆ–æ•°å­—åŠ æ³•ã€‚

#### 13.8.1.1 Runtime Semantics: Evaluation
AdditiveExpression : AdditiveExpression + MultiplicativeExpression

1. Return ? EvaluateStringOrNumericBinaryExpression(AdditiveExpression, +, MultiplicativeExpression).

### 13.8.2 The Subtraction Operator ( - )

>NOTE è¿ç®—ç¬¦æ‰§è¡Œå‡æ³•ï¼Œäº§ç”Ÿå…¶æ“ä½œæ•°çš„å·®ã€‚

#### 13.8.2.1 Runtime Semantics: Evaluation

AdditiveExpression : AdditiveExpression - MultiplicativeExpression

1. Return ? EvaluateStringOrNumericBinaryExpression(AdditiveExpression, -, MultiplicativeExpression).

### 13.9.1 The Left Shift Operator ( << )

>NOTE æŒ‰å³æ“ä½œæ•°æŒ‡å®šçš„é‡å¯¹å·¦æ“ä½œæ•°æ‰§è¡Œé€ä½å·¦ç§»ä½è¿ç®—ã€‚

#### 13.9.1.1 Runtime Semantics: Evaluation

ShiftExpression : ShiftExpression << AdditiveExpression

1. Return ? EvaluateStringOrNumericBinaryExpression(ShiftExpression, <<, AdditiveExpression).

### 13.9.2 The Signed Right Shift Operator ( >> )

>NOTE æŒ‰å³æ“ä½œæ•°æŒ‡å®šçš„é‡å¯¹å·¦æ“ä½œæ•°æ‰§è¡Œç¬¦å·å¡«å……é€ä½å³ç§»è¿ç®—ã€‚

#### 13.9.2.1 Runtime Semantics: Evaluation

ShiftExpression : ShiftExpression >> AdditiveExpression

1. Return ? EvaluateStringOrNumericBinaryExpression(ShiftExpression, >>, AdditiveExpression).

### 13.9.3 The Unsigned Right Shift Operator ( >>> )

>NOTE æŒ‰å³æ“ä½œæ•°æŒ‡å®šçš„é‡å¯¹å·¦æ“ä½œæ•°æ‰§è¡Œé€ä½é›¶å¡«å……å³ç§»è¿ç®—ã€‚

#### 13.9.3.1 Runtime Semantics: Evaluation

ShiftExpression : ShiftExpression >>> AdditiveExpression

1. Return ? EvaluateStringOrNumericBinaryExpression(ShiftExpression, >>>, AdditiveExpression).