## 13.10 Relational Operators

>NOTE1 è®¡ç®—å…³ç³»è¿ç®—ç¬¦çš„ç»“æœå§‹ç»ˆæ˜¯å¸ƒå°”ç±»å‹ï¼Œåæ˜ è¿ç®—ç¬¦å‘½åçš„å…³ç³»æ˜¯å¦åœ¨å…¶ä¸¤ä¸ªæ“ä½œæ•°ä¹‹é—´æˆç«‹ã€‚

Syntax

    RelationalExpression[In, Yield, Await] :

        ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] < ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] > ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] <= ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] >= ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] instanceof ShiftExpression[?Yield, ?Await]
        [+In] RelationalExpression[+In, ?Yield, ?Await] in ShiftExpression[?Yield, ?Await]

>NOTE2  éœ€è¦ [In] è¯­æ³•å‚æ•°ä»¥é¿å…å°†å…³ç³»è¡¨è¾¾å¼ä¸­çš„ in è¿ç®—ç¬¦ä¸ for è¯­å¥ä¸­çš„ in è¿ç®—ç¬¦æ··æ·†ã€‚     

### 13.10.1 Runtime Semantics: Evaluation

RelationalExpression : RelationalExpression < ShiftExpression

1. Let lref be the result of evaluating RelationalExpression.
2. Let lval be ? GetValue(lref).
3. Let rref be the result of evaluating ShiftExpression.
4. Let rval be ? GetValue(rref).
5. Let r be ? IsLessThan(lval, rval, true).
6. If r is undefined, return false. Otherwise, return r.

RelationalExpression : RelationalExpression > ShiftExpression

1. Let lref be the result of evaluating RelationalExpression.
2. Let lval be ? GetValue(lref).
3. Let rref be the result of evaluating ShiftExpression.
4. Let rval be ? GetValue(rref).
5. Let r be ? IsLessThan(rval, lval, false).
6. If r is undefined, return false. Otherwise, return r.

RelationalExpression : RelationalExpression <= ShiftExpression

1. Let lref be the result of evaluating RelationalExpression.
2. Let lval be ? GetValue(lref).
3. Let rref be the result of evaluating ShiftExpression.
4. Let rval be ? GetValue(rref).
5. Let r be ? IsLessThan(rval, lval, false).
6. If r is true or undefined, return false. Otherwise, return true.

RelationalExpression : RelationalExpression >= ShiftExpression

1. Let lref be the result of evaluating RelationalExpression.
2. Let lval be ? GetValue(lref).
3. Let rref be the result of evaluating ShiftExpression.
4. Let rval be ? GetValue(rref).
5. Let r be ? IsLessThan(lval, rval, true).
6. If r is true or undefined, return false. Otherwise, return true.

RelationalExpression : RelationalExpression instanceof ShiftExpression

1. Let lref be the result of evaluating RelationalExpression.
2. Let lval be ? GetValue(lref).
3. Let rref be the result of evaluating ShiftExpression.
4. Let rval be ? GetValue(rref).
5. Return ? InstanceofOperator(lval, rval).

RelationalExpression : RelationalExpression in ShiftExpression

1. Let lref be the result of evaluating RelationalExpression.
2. Let lval be ? GetValue(lref).
3. Let rref be the result of evaluating ShiftExpression.
4. Let rval be ? GetValue(rref).
5. If Type(rval) is not Object, throw a TypeError exception.
6. Return ? HasProperty(rval, ? ToPropertyKey(lval)).

RelationalExpression : PrivateIdentifier in ShiftExpression

1. Let privateIdentifier be the StringValue of PrivateIdentifier.
2. Let rref be the result of evaluating ShiftExpression.
3. Let rval be ? GetValue(rref).
4. If Type(rval) is not Object, throw a TypeError exception.
5. Let privateEnv be the running execution context's PrivateEnvironment.
6. Let privateName be ResolvePrivateIdentifier(privateEnv, privateIdentifier).
7. If PrivateElementFind(rval, privateName) is not empty, return true.
8. Return false.

### 13.10.2 InstanceofOperator ( V, target )

æŠ½è±¡æ“ä½œ InstanceofOperator æ¥å—å‚æ•° Vï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å’Œ targetï¼ˆECMAScript è¯­è¨€å€¼ï¼‰ï¼Œå¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆæˆ–çªç„¶å®Œæˆã€‚å®ƒå®ç°äº†ç”¨äºç¡®å®š V æ˜¯å¦æ˜¯ç›®æ ‡å®ä¾‹çš„é€šç”¨ç®—æ³•ï¼Œæˆ–è€…é€šè¿‡å’¨è¯¢ç›®æ ‡çš„ @@hasInstance æ–¹æ³•ï¼Œæˆ–è€…å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™ç¡®å®šç›®æ ‡çš„â€œåŸå‹â€å±æ€§çš„å€¼æ˜¯å¦å­˜åœ¨äº V çš„åŸå‹é“¾ä¸­ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If Type(target) is not Object, throw a TypeError exception.
2. Let instOfHandler be ? GetMethod(target, @@hasInstance).
3. If instOfHandler is not undefined, then
    - Return ToBoolean(? Call(instOfHandler, target, Â« V Â»)).
4. If IsCallable(target) is false, throw a TypeError exception.
5. Return ? OrdinaryHasInstance(target, V).

>NOTE ç¬¬ 4 æ­¥å’Œç¬¬ 5 æ­¥æä¾›äº†ä¸ä»¥å‰ç‰ˆæœ¬çš„ ECMAScript çš„å…¼å®¹æ€§ï¼Œè¿™äº›ç‰ˆæœ¬æ²¡æœ‰ä½¿ç”¨ @@hasInstance æ–¹æ³•æ¥å®šä¹‰ instanceof è¿ç®—ç¬¦è¯­ä¹‰ã€‚å¦‚æœä¸€ä¸ªå¯¹è±¡æ²¡æœ‰å®šä¹‰æˆ–ç»§æ‰¿ @@hasInstance å®ƒä½¿ç”¨é»˜è®¤çš„ instanceof è¯­ä¹‰ã€‚

## 13.11 Equality Operators

>NOTE æ±‚å€¼ç›¸ç­‰è¿ç®—ç¬¦çš„ç»“æœå§‹ç»ˆä¸ºå¸ƒå°”ç±»å‹ï¼Œåæ˜ è¿ç®—ç¬¦å‘½åçš„å…³ç³»æ˜¯å¦åœ¨å…¶ä¸¤ä¸ªæ“ä½œæ•°ä¹‹é—´æˆç«‹ã€‚

Syntax

    EqualityExpression[In, Yield, Await] :
        RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] == RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] != RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] === RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] !== RelationalExpression[?In, ?Yield, ?Await]

### 13.11.1 Runtime Semantics: Evaluation

EqualityExpression : EqualityExpression == RelationalExpression

1. Let lref be the result of evaluating EqualityExpression.
2. Let lval be ? GetValue(lref).
3. Let rref be the result of evaluating RelationalExpression.
4. Let rval be ? GetValue(rref).
5. Return ? IsLooselyEqual(rval, lval).

EqualityExpression : EqualityExpression != RelationalExpression

1. Let lref be the result of evaluating EqualityExpression.
2. Let lval be ? GetValue(lref).
3. Let rref be the result of evaluating RelationalExpression.
4. Let rval be ? GetValue(rref).
5. Let r be ? IsLooselyEqual(rval, lval).
6. If r is true, return false. Otherwise, return true.

EqualityExpression : EqualityExpression === RelationalExpression

1. Let lref be the result of evaluating EqualityExpression.
2. Let lval be ? GetValue(lref).
3. Let rref be the result of evaluating RelationalExpression.
4. Let rval be ? GetValue(rref).
5. Return IsStrictlyEqual(rval, lval).

EqualityExpression : EqualityExpression !== RelationalExpression

1. Let lref be the result of evaluating EqualityExpression.
2. Let lval be ? GetValue(lref).
3. Let rref be the result of evaluating RelationalExpression.
4. Let rval be ? GetValue(rref).
5. Let r be IsStrictlyEqual(rval, lval).
6. If r is true, return false. Otherwise, return true.        

>NOTE1 Given the above definition of equality:

- String comparison can be forced by: `${a}` == `${b}`.
- Numeric comparison can be forced by: +a == +b.
- Boolean comparison can be forced by: !a == !b.

>NOTE2 ç­‰å¼è¿ç®—ç¬¦ä¿æŒä»¥ä¸‹ä¸å˜é‡ï¼š

- A != B is equivalent to !(A == B).
- A == B is equivalent to B == A, except in the order of evaluation of A and B.

>NOTE3 ç­‰å¼è¿ç®—ç¬¦å¹¶ä¸æ€»æ˜¯å¯ä¼ é€’çš„ã€‚ä¾‹å¦‚ï¼Œå¯èƒ½æœ‰ä¸¤ä¸ªä¸åŒçš„å­—ç¬¦ä¸²å¯¹è±¡ï¼Œæ¯ä¸ªå¯¹è±¡ä»£è¡¨ç›¸åŒçš„å­—ç¬¦ä¸²å€¼ï¼›é€šè¿‡==è¿ç®—ç¬¦å¯ä»¥è®¤ä¸ºæ¯ä¸ªå­—ç¬¦ä¸²å¯¹è±¡ç­‰äºå­—ç¬¦ä¸²å€¼ï¼Œä½†è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²å¯¹è±¡ä¸ä¼šå½¼æ­¤ç›¸ç­‰ã€‚ä¾‹å¦‚ï¼š

- new String("a") == "a" and "a" == new String("a") are both true.
- new String("a") == new String("a") is false.

>NOTE4 å­—ç¬¦ä¸²æ¯”è¾ƒå¯¹ä»£ç å•ä½å€¼åºåˆ—ä½¿ç”¨ç®€å•çš„ç›¸ç­‰æ€§æµ‹è¯•ã€‚æ²¡æœ‰äººè¯•å›¾ä½¿ç”¨Unicodeè§„èŒƒä¸­å®šä¹‰çš„æ›´å¤æ‚ã€é¢å‘è¯­ä¹‰çš„å­—ç¬¦æˆ–å­—ç¬¦ä¸²ç›¸ç­‰å’Œæ’åºé¡ºåºå®šä¹‰ã€‚å› æ­¤ï¼Œæ ¹æ®Unicodeæ ‡å‡†ï¼Œæ ‡å‡†ç›¸ç­‰çš„å­—ç¬¦ä¸²å€¼å¯èƒ½ä¼šè¢«æµ‹è¯•ä¸ºä¸ç›¸ç­‰ã€‚å®é™…ä¸Šï¼Œè¯¥ç®—æ³•å‡è®¾ä¸¤ä¸ªå­—ç¬¦ä¸²éƒ½å·²å¤„äºè§„èŒƒåŒ–å½¢å¼ã€‚

## 13.12 Binary Bitwise Operators

Syntax

    BitwiseANDExpression[In, Yield, Await] :
        EqualityExpression[?In, ?Yield, ?Await]
        BitwiseANDExpression[?In, ?Yield, ?Await] & EqualityExpression[?In, ?Yield, ?Await]
    BitwiseXORExpression[In, Yield, Await] :
        BitwiseANDExpression[?In, ?Yield, ?Await]
        BitwiseXORExpression[?In, ?Yield, ?Await] ^ BitwiseANDExpression[?In, ?Yield, ?Await]
    BitwiseORExpression[In, Yield, Await] :
        BitwiseXORExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await] | BitwiseXORExpression[?In, ?Yield, ?Await]

### 13.12.1 Runtime Semantics: Evaluation

BitwiseANDExpression : BitwiseANDExpression & EqualityExpression

1. Return ? EvaluateStringOrNumericBinaryExpression(BitwiseANDExpression, &, EqualityExpression).

BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression

1. Return ? EvaluateStringOrNumericBinaryExpression(BitwiseXORExpression, ^, BitwiseANDExpression).

BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression

1. Return ? EvaluateStringOrNumericBinaryExpression(BitwiseORExpression, |, BitwiseXORExpression).

## 13.13 Binary Logical Operators

Syntax

    LogicalANDExpression[In, Yield, Await] :
        BitwiseORExpression[?In, ?Yield, ?Await]
        LogicalANDExpression[?In, ?Yield, ?Await] && BitwiseORExpression[?In, ?Yield, ?Await]
    LogicalORExpression[In, Yield, Await] :
        LogicalANDExpression[?In, ?Yield, ?Await]
        LogicalORExpression[?In, ?Yield, ?Await] || LogicalANDExpression[?In, ?Yield, ?Await]
    CoalesceExpression[In, Yield, Await] :
        CoalesceExpressionHead[?In, ?Yield, ?Await] ?? BitwiseORExpression[?In, ?Yield, ?Await]
    CoalesceExpressionHead[In, Yield, Await] :
        CoalesceExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await]
    ShortCircuitExpression[In, Yield, Await] :
        LogicalORExpression[?In, ?Yield, ?Await]
        CoalesceExpression[?In, ?Yield, ?Await]



>NOTE && æˆ– || äº§ç”Ÿçš„å€¼è¿ç®—ç¬¦ä¸ä¸€å®šæ˜¯å¸ƒå°”ç±»å‹ã€‚äº§ç”Ÿçš„å€¼å°†å§‹ç»ˆæ˜¯ä¸¤ä¸ªæ“ä½œæ•°è¡¨è¾¾å¼ä¹‹ä¸€çš„å€¼ã€‚

### 13.13.1 Runtime Semantics: Evaluation

LogicalANDExpression : LogicalANDExpression && BitwiseORExpression

1. Let lref be the result of evaluating LogicalANDExpression.
2. Let lval be ? GetValue(lref).
3. Let lbool be ToBoolean(lval).
4. If lbool is false, return lval.
5. Let rref be the result of evaluating BitwiseORExpression.
6. Return ? GetValue(rref).

LogicalORExpression : LogicalORExpression || LogicalANDExpression

1. Let lref be the result of evaluating LogicalORExpression.
2. Let lval be ? GetValue(lref).
3. Let lbool be ToBoolean(lval).
4. If lbool is true, return lval.
5. Let rref be the result of evaluating LogicalANDExpression.
6. Return ? GetValue(rref).

CoalesceExpression : CoalesceExpressionHead ?? BitwiseORExpression

1. Let lref be the result of evaluating CoalesceExpressionHead.
2. Let lval be ? GetValue(lref).
3. If lval is undefined or null, then
    - Let rref be the result of evaluating BitwiseORExpression.
    - Return ? GetValue(rref).
4. Otherwise, return lval.

## 13.14 Conditional Operator ( ? : )

Syntax

    ConditionalExpression[In, Yield, Await] :
        ShortCircuitExpression[?In, ?Yield, ?Await]
        ShortCircuitExpression[?In, ?Yield, ?Await] ? AssignmentExpression[+In, ?Yield, ?Await] : AssignmentExpression[?In, ?Yield, ?Await]

>NOTE ECMAScript ä¸­ ConditionalExpression çš„è¯­æ³•ä¸ C å’Œ Java ä¸­çš„è¯­æ³•ç•¥æœ‰ä¸åŒï¼Œå®ƒä»¬éƒ½å…è®¸ç¬¬äºŒä¸ªå­è¡¨è¾¾å¼ä¸º Expressionï¼Œä½†é™åˆ¶ç¬¬ä¸‰ä¸ªè¡¨è¾¾å¼ä¸º ConditionalExpressionã€‚ ECMAScript ä¸­è¿™ç§å·®å¼‚çš„åŠ¨æœºæ˜¯å…è®¸èµ‹å€¼è¡¨è¾¾å¼ç”±æ¡ä»¶çš„ä»»ä¸€åˆ†æ”¯æ§åˆ¶ï¼Œå¹¶æ¶ˆé™¤é€—å·è¡¨è¾¾å¼ä½œä¸ºä¸­å¿ƒè¡¨è¾¾å¼çš„æ··ä¹±å’Œç›¸å½“æ— ç”¨çš„æƒ…å†µã€‚        

## 13.15 Assignment Operators

Syntax

    AssignmentExpression[In, Yield, Await] :
        ConditionalExpression[?In, ?Yield, ?Await]
        [+Yield] YieldExpression[?In, ?Await]
        ArrowFunction[?In, ?Yield, ?Await]
        AsyncArrowFunction[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] = AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] &&= AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] ||= AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] ??= AssignmentExpression[?In, ?Yield, ?Await]
    AssignmentOperator : one of
        *= /= %= += -= <<= >>= >>>= &= ^= |= **=

```
Assignment -> Conditional -> LogicalOr -> LogicalAnd -> Bitwise(Or -> Xor -> And) -> Equality -> Relational -> Shift -> Add -> Mult -> Exponential -> Unary -> Update -> LHS -> New -> Member -> Primary -> Literal -> Numeric.
```

### 13.15.1 Static Semantics: Early Errors

AssignmentExpression : LeftHandSideExpression = AssignmentExpression

If LeftHandSideExpression is an ObjectLiteral or an ArrayLiteral, the following Early Error rules are applied:

- LeftHandSideExpression å¿…é¡»è¦†ç›–ä¸€ä¸ª AssignmentPatternã€‚

å¦‚æœ LeftHandSideExpression æ—¢ä¸æ˜¯ ObjectLiteral ä¹Ÿä¸æ˜¯ ArrayLiteralï¼Œåˆ™åº”ç”¨ä»¥ä¸‹ Early Error è§„åˆ™ï¼š

- å¦‚æœ LeftHandSideExpression çš„ AssignmentTargetType ä¸ç®€å•ï¼Œåˆ™ä¸ºè¯­æ³•é”™è¯¯ã€‚

```
[] = []
[,] = []
[] = {} //å³ä¾§ä¸å¯è¿­ä»£
```

### 13.15.2 Runtime Semantics: Evaluation

AssignmentExpression : LeftHandSideExpression = AssignmentExpression

1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then
    - Let lref be the result of evaluating LeftHandSideExpression.
    - ReturnIfAbrupt(lref).
    - If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then
        - Let rval be ? NamedEvaluation of AssignmentExpression with argument lref.[[ReferencedName]].
    - Else,
        - Let rref be the result of evaluating AssignmentExpression.
        - Let rval be ? GetValue(rref).
    - Perform ? PutValue(lref, rval).
    - Return rval.
2. Let assignmentPattern be the AssignmentPattern that is covered by LeftHandSideExpression.
3. Let rref be the result of evaluating AssignmentExpression.
4. Let rval be ? GetValue(rref).
5. Perform ? DestructuringAssignmentEvaluation of assignmentPattern with argument rval.
6. Return rval.

AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression

1. Let lref be the result of evaluating LeftHandSideExpression.
2. Let lval be ? GetValue(lref).
3. Let rref be the result of evaluating AssignmentExpression.
4. Let rval be ? GetValue(rref).
5. Let assignmentOpText be the source text matched by AssignmentOperator.
6. Let opText be the sequence of Unicode code points associated with assignmentOpText in the following table:
<center>

|assignmentOpText|opText|
|--|--|
|**=|**|
|*=|*|
|/=|/|
|%=|%|
|+=|+|
|-=|-|
|<<=|<<|
|>>=|>>|
|>>>=|>>>|
|&=|&|
|^=|^|
||=|||

</center>
7. Let r be ? ApplyStringOrNumericBinaryOperator(lval, opText, rval).
8. Perform ? PutValue(lref, r).
9. Return r.

AssignmentExpression : LeftHandSideExpression &&= AssignmentExpression

1. Let lref be the result of evaluating LeftHandSideExpression.
2. Let lval be ? GetValue(lref).
3. Let lbool be ToBoolean(lval).
4. If lbool is false, return lval.
5. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
    - Let rval be ? NamedEvaluation of AssignmentExpression with argument lref.[[ReferencedName]].
6. Else,
    - Let rref be the result of evaluating AssignmentExpression.
    - Let rval be ? GetValue(rref).
7. Perform ? PutValue(lref, rval).
8. Return rval.

AssignmentExpression : LeftHandSideExpression ||= AssignmentExpression

1. Let lref be the result of evaluating LeftHandSideExpression.
2. Let lval be ? GetValue(lref).
3. Let lbool be ToBoolean(lval).
4. If lbool is true, return lval.
5. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
    - Let rval be ? NamedEvaluation of AssignmentExpression with argument lref.[[ReferencedName]].
6. Else,
    - Let rref be the result of evaluating AssignmentExpression.
    - Let rval be ? GetValue(rref).
7. Perform ? PutValue(lref, rval).
8. Return rval.

AssignmentExpression : LeftHandSideExpression ??= AssignmentExpression

1. Let lref be the result of evaluating LeftHandSideExpression.
2. Let lval be ? GetValue(lref).
3. If lval is neither undefined nor null, return lval.
4. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
    - Let rval be ? NamedEvaluation of AssignmentExpression with argument lref.[[ReferencedName]].
5. Else,
    - Let rref be the result of evaluating AssignmentExpression.
    - Let rval be ? GetValue(rref).
6. Perform ? PutValue(lref, rval).
7. Return rval.

>NOTE When this expression occurs within strict mode code, it is a runtime error if lref in step 1.e, 2, 2, 2, 2 is an unresolvable reference. If it is, a ReferenceError exception is thrown. Additionally, it is a runtime error if the lref in step 8, 7, 7, 6 is a reference to a data property with the attribute value { [[Writable]]: false }, to an accessor property with the attribute value { [[Set]]: undefined }, or to a non-existent property of an object for which the IsExtensible predicate returns the value false. In these cases a TypeError exception is thrown.

### 13.15.3 ApplyStringOrNumericBinaryOperator ( lval, opText, rval ) åº”ç”¨å­—ç¬¦ä¸²æˆ–æ•°å­—äºŒè¿›åˆ¶è¿ç®—ç¬¦

The abstract operation ApplyStringOrNumericBinaryOperator takes arguments lval (an ECMAScript language value), opText (**, *, /, %, +, -, <<, >>, >>>, &, ^, or |), and rval (an ECMAScript language value) and returns either a normal completion containing either a String, a BigInt, or a Number, or an abrupt completion. It performs the following steps when called:

1. If opText is +, then
    - Let lprim be ? ToPrimitive(lval).
    - Let rprim be ? ToPrimitive(rval).
    - If Type(lprim) is String or Type(rprim) is String, then
        - Let lstr be ? ToString(lprim).
        - Let rstr be ? ToString(rprim).
        - Return the string-concatenation of lstr and rstr.
    - Set lval to lprim.
    - Set rval to rprim.
2. NOTE: At this point, it must be a numeric operation.
3. Let lnum be ? ToNumeric(lval).
4. Let rnum be ? ToNumeric(rval).
5. If Type(lnum) is different from Type(rnum), throw a TypeError exception.
6. If Type(lnum) is BigInt, then
    - If opText is **, return ? BigInt::exponentiate(lnum, rnum).
    - If opText is /, return ? BigInt::divide(lnum, rnum).
    - If opText is %, return ? BigInt::remainder(lnum, rnum).
    - If opText is >>>, return ? BigInt::unsignedRightShift(lnum, rnum).
7. Let operation be the abstract operation associated with opText and Type(lnum) in the following table:

<center>

|opText|Type(lnum)|operation|
|--|--|--|
|**|Number|Number::exponentiate|
|*|Number|Number::multiply|
|*|BigInt|BigInt::multiply|
|/|Number|Number::divide|
|%|Number|Number::remainder|
|+|Number|Number::add|
|+|BigInt|BigInt::add|
|-|Number|Number::subtract|
|-|BigInt|BigInt::subtract|
|<<|Number|Number::leftShift|
|<<|BigInt|BigInt::leftShift|
|>>|Number|Number::signedRightShift|
|>>|BigInt|BigInt::signedRightShift|
|>>>|Number|Number::unsignedRightShift|
|&|Number|Number::bitwiseAND|
|&|BigInt|BigInt::bitwiseAND|
|^|Number|Number::bitwiseXOR|
|^|BigInt|BigInt::bitwiseXOR|
|\|Number|Number::bitwiseOR|
|\|BigInt|BigInt::bitwiseOR|

</center>

8. Return operation(lnum, rnum).


>NOTE1 åœ¨æ­¥éª¤ 1.a å’Œ 1.b ä¸­å¯¹ ToPrimitive çš„è°ƒç”¨ä¸­æ²¡æœ‰æä¾›ä»»ä½•æç¤ºã€‚é™¤ Dates ä¹‹å¤–çš„æ‰€æœ‰æ ‡å‡†å¯¹è±¡éƒ½å¤„ç†æ²¡æœ‰æç¤ºçš„æƒ…å†µï¼Œå°±å¥½åƒç»™å‡ºäº†æ•°å­—ä¸€æ ·ï¼›æ—¥æœŸå¤„ç†æ²¡æœ‰æç¤ºçš„æƒ…å†µï¼Œå°±å¥½åƒç»™å‡ºäº†å­—ç¬¦ä¸²ä¸€æ ·ã€‚å¼‚å›½æƒ…è°ƒçš„å¯¹è±¡å¯èƒ½ä¼šä»¥å…¶ä»–æ–¹å¼å¤„ç†æç¤ºçš„ç¼ºå¤±ã€‚

>NOTE2 æ­¥éª¤ 1.c ä¸ IsLessThan ç®—æ³•çš„æ­¥éª¤ 3 ä¸åŒï¼Œå®ƒä½¿ç”¨é€»è¾‘æˆ–è¿ç®—è€Œä¸æ˜¯é€»è¾‘ä¸è¿ç®—ã€‚

### 13.15.4 EvaluateStringOrNumericBinaryExpression ( leftOperand, opText, rightOperand ) è®¡ç®—å­—ç¬¦ä¸²æˆ–æ•°å­—äºŒè¿›åˆ¶è¡¨è¾¾å¼

The abstract operation EvaluateStringOrNumericBinaryExpression takes arguments leftOperand (a Parse Node), opText (a sequence of Unicode code points), and rightOperand (a Parse Node) and returns either a normal completion containing either a String, a BigInt, or a Number, or an abrupt completion. It performs the following steps when called:

1. Let lref be the result of evaluating leftOperand.
2. Let lval be ? GetValue(lref).
3. Let rref be the result of evaluating rightOperand.
4. Let rval be ? GetValue(rref).
5. Return ? ApplyStringOrNumericBinaryOperator(lval, opText, rval).

### 13.15.5 Destructuring Assignment

Supplemental Syntax

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œåœ¨å¤„ç†äº§ç”Ÿå¼å®ä¾‹æ—¶

AssignmentExpression : LeftHandSideExpression = AssignmentExpression

LeftHandSideExpression çš„è§£é‡Šä½¿ç”¨ä»¥ä¸‹è¯­æ³•è¿›è¡Œäº†ç»†åŒ–ï¼š

    AssignmentPattern[Yield, Await] :
        ObjectAssignmentPattern[?Yield, ?Await]
        ArrayAssignmentPattern[?Yield, ?Await]
    ObjectAssignmentPattern[Yield, Await] :
        { }
        { AssignmentRestProperty[?Yield, ?Await] }
        { AssignmentPropertyList[?Yield, ?Await] }
        { AssignmentPropertyList[?Yield, ?Await] , AssignmentRestProperty[?Yield, ?Await]opt }
    ArrayAssignmentPattern[Yield, Await] :
        [ Elisionopt AssignmentRestElement[?Yield, ?Await]opt ]
        [ AssignmentElementList[?Yield, ?Await] ]
        [ AssignmentElementList[?Yield, ?Await] , Elisionopt AssignmentRestElement[?Yield, ?Await]opt ]
    AssignmentRestProperty[Yield, Await] :
        ... DestructuringAssignmentTarget[?Yield, ?Await]
    AssignmentPropertyList[Yield, Await] :
        AssignmentProperty[?Yield, ?Await]
        AssignmentPropertyList[?Yield, ?Await] , AssignmentProperty[?Yield, ?Await]
    AssignmentElementList[Yield, Await] :
        AssignmentElisionElement[?Yield, ?Await]
        AssignmentElementList[?Yield, ?Await] , AssignmentElisionElement[?Yield, ?Await]
    AssignmentElisionElement[Yield, Await] :
        Elisionopt AssignmentElement[?Yield, ?Await]
    AssignmentProperty[Yield, Await] :
        IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]opt
        PropertyName[?Yield, ?Await] : AssignmentElement[?Yield, ?Await]
    AssignmentElement[Yield, Await] :
     DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]opt
    AssignmentRestElement[Yield, Await] :
        ... DestructuringAssignmentTarget[?Yield, ?Await]
    DestructuringAssignmentTarget[Yield, Await] :
        LeftHandSideExpression[?Yield, ?Await]

#### 13.15.5.1 Static Semantics: Early Errors

AssignmentProperty : IdentifierReference Initializeropt

- It is a Syntax Error if AssignmentTargetType of IdentifierReference is not simple.

AssignmentRestProperty : ... DestructuringAssignmentTarget

- It is a Syntax Error if DestructuringAssignmentTarget is an ArrayLiteral or an ObjectLiteral.

DestructuringAssignmentTarget : LeftHandSideExpression

If LeftHandSideExpression is an ObjectLiteral or an ArrayLiteral, the following Early Error rules are applied:

- LeftHandSideExpression must cover an AssignmentPattern.

If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, the following Early Error rule is applied:

It is a Syntax Error if AssignmentTargetType of LeftHandSideExpression is not simple.

#### 13.15.5.2 Runtime Semantics: DestructuringAssignmentEvaluation

The syntax-directed operation DestructuringAssignmentEvaluation takes argument value and returns either a normal completion containing unused or an abrupt completion. It is defined piecewise over the following productions:

ObjectAssignmentPattern : { }

1. Perform ? RequireObjectCoercible(value).
2. Return unused.

ObjectAssignmentPattern :

    { AssignmentPropertyList }

    { AssignmentPropertyList , }

1. Perform ? RequireObjectCoercible(value).
2. Perform ? PropertyDestructuringAssignmentEvaluation of AssignmentPropertyList with argument value.
3. Return unused.

ObjectAssignmentPattern : { AssignmentRestProperty }

1. Perform ? RequireObjectCoercible(value).
2. Let excludedNames be a new empty List.
3. Return ? RestDestructuringAssignmentEvaluation of AssignmentRestProperty with arguments value and excludedNames.

ObjectAssignmentPattern : { AssignmentPropertyList , AssignmentRestProperty }
1. Perform ? RequireObjectCoercible(value).
2. Let excludedNames be ? PropertyDestructuringAssignmentEvaluation of AssignmentPropertyList with argument value.
3. Return ? RestDestructuringAssignmentEvaluation of AssignmentRestProperty with arguments value and excludedNames.

ArrayAssignmentPattern : [ ]
1. Let iteratorRecord be ? GetIterator(value).
2. Return ? IteratorClose(iteratorRecord, NormalCompletion(unused)).

ArrayAssignmentPattern : [ Elision ]
1. Let iteratorRecord be ? GetIterator(value).
2. Let result be Completion(IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord).
3. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, result).
4. Return result.

ArrayAssignmentPattern : [ Elisionopt AssignmentRestElement ]
1. Let iteratorRecord be ? GetIterator(value).
2. If Elision is present, then
    - Let status be Completion(IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord).
    - If status is an abrupt completion, then
        - Assert: iteratorRecord.[[Done]] is true.
        - Return ? status.
3. Let result be Completion(IteratorDestructuringAssignmentEvaluation of AssignmentRestElement with argument iteratorRecord).
4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, result).
5. Return result.

ArrayAssignmentPattern : [ AssignmentElementList ]
1. Let iteratorRecord be ? GetIterator(value).
2. Let result be Completion(IteratorDestructuringAssignmentEvaluation of AssignmentElementList with argument iteratorRecord).
3. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, result).
4. Return result.

ArrayAssignmentPattern : [ AssignmentElementList , Elisionopt AssignmentRestElementopt ]
1. Let iteratorRecord be ? GetIterator(value).
2. Let status be Completion(IteratorDestructuringAssignmentEvaluation of AssignmentElementList with argument iteratorRecord).
3. If status is an abrupt completion, then
    - If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, status).
    - Return ? status.
4. If Elision is present, then
    - Set status to Completion(IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord).
    - If status is an abrupt completion, then
        - Assert: iteratorRecord.[[Done]] is true.
        - Return ? status.
5. If AssignmentRestElement is present, then
    - Set status to Completion(IteratorDestructuringAssignmentEvaluation of AssignmentRestElement with argument iteratorRecord).
6. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, status).
7. Return ? status.

#### 13.15.5.3 Runtime Semantics: PropertyDestructuringAssignmentEvaluation

The syntax-directed operation PropertyDestructuringAssignmentEvaluation takes argument value and returns either a normal completion containing a List of property keys or an abrupt completion. It collects a list of all destructured property keys. It is defined piecewise over the following productions:

AssignmentPropertyList : AssignmentPropertyList , AssignmentProperty
1. Let propertyNames be ? PropertyDestructuringAssignmentEvaluation of AssignmentPropertyList with argument value.
2. Let nextNames be ? PropertyDestructuringAssignmentEvaluation of AssignmentProperty with argument value.
3. Return the list-concatenation of propertyNames and nextNames.

AssignmentProperty : IdentifierReference Initializeropt
1. Let P be StringValue of IdentifierReference.
2. Let lref be ? ResolveBinding(P).
3. Let v be ? GetV(value, P).
4. If Initializeropt is present and v is undefined, then
    - If IsAnonymousFunctionDefinition(Initializer) is true, then
        - Set v to ? NamedEvaluation of Initializer with argument P.
    - Else,
        - Let defaultValue be the result of evaluating Initializer.
        - Set v to ? GetValue(defaultValue).
5. Perform ? PutValue(lref, v).
6. Return Â« P Â».

AssignmentProperty : PropertyName : AssignmentElement
1. Let name be the result of evaluating PropertyName.
2. ReturnIfAbrupt(name).
3. Perform ? KeyedDestructuringAssignmentEvaluation of AssignmentElement with arguments value and name.
4. Return Â« name Â».

#### 13.15.5.4 Runtime Semantics: RestDestructuringAssignmentEvaluation

The syntax-directed operation RestDestructuringAssignmentEvaluation takes arguments value and excludedNames and returns either a normal completion containing unused or an abrupt completion. It is defined piecewise over the following productions:

AssignmentRestProperty : ... DestructuringAssignmentTarget

1. Let lref be the result of evaluating DestructuringAssignmentTarget.
2. ReturnIfAbrupt(lref).
3. Let restObj be OrdinaryObjectCreate(%Object.prototype%).
4. Perform ? CopyDataProperties(restObj, value, excludedNames).
5. Return ? PutValue(lref, restObj).

#### 13.15.5.5 Runtime Semantics: IteratorDestructuringAssignmentEvaluation

è¯­æ³•å¯¼å‘çš„æ“ä½œIteratorDestructuringAssignmentEvaluationæ¥å—å‚æ•°iteratorRecordå¹¶è¿”å›åŒ…å«æœªä½¿ç”¨çš„æ­£å¸¸å®Œæˆæˆ–çªç„¶å®Œæˆã€‚å®ƒæ˜¯åœ¨ä»¥ä¸‹äº§ç”Ÿå¼åˆ†æ®µå®šä¹‰çš„ï¼š

AssignmentElementList : AssignmentElisionElement

1. Return ? IteratorDestructuringAssignmentEvaluation of AssignmentElisionElement with argument iteratorRecord.

AssignmentElementList : AssignmentElementList , AssignmentElisionElement
1. Perform ? IteratorDestructuringAssignmentEvaluation of AssignmentElementList with argument iteratorRecord.
2. Return ? IteratorDestructuringAssignmentEvaluation of AssignmentElisionElement with argument iteratorRecord.

AssignmentElisionElement : AssignmentElement
1. Return ? IteratorDestructuringAssignmentEvaluation of AssignmentElement with argument iteratorRecord.

AssignmentElisionElement : Elision AssignmentElement
1. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord.
2. Return ? IteratorDestructuringAssignmentEvaluation of AssignmentElement with argument iteratorRecord.

Elision : ,
1. If iteratorRecord.[[Done]] is false, then
    - Let next be Completion(IteratorStep(iteratorRecord)).
    - If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
    - ReturnIfAbrupt(next).
    - If next is false, set iteratorRecord.[[Done]] to true.
2. Return unused.

Elision : Elision ,
1. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord.
2. If iteratorRecord.[[Done]] is false, then
    - Let next be Completion(IteratorStep(iteratorRecord)).
    - If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
    - ReturnIfAbrupt(next).
    - If next is false, set iteratorRecord.[[Done]] to true.
3. Return unused.

AssignmentElement : DestructuringAssignmentTarget Initializeropt
1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
    - Let lref be the result of evaluating DestructuringAssignmentTarget.
    - ReturnIfAbrupt(lref).
2. If iteratorRecord.[[Done]] is false, then
    - Let next be Completion(IteratorStep(iteratorRecord)).
    - If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
    - ReturnIfAbrupt(next).
    - If next is false, set iteratorRecord.[[Done]] to true.
    - Else,
        - Let value be Completion(IteratorValue(next)).
        - If value is an abrupt completion, set iteratorRecord.[[Done]] to true.
        - ReturnIfAbrupt(value).
3. If iteratorRecord.[[Done]] is true, let value be undefined.
4. If Initializer is present and value is undefined, then
    - If IsAnonymousFunctionDefinition(Initializer) is true and IsIdentifierRef of DestructuringAssignmentTarget is true, then
        - Let v be ? NamedEvaluation of Initializer with argument lref.[[ReferencedName]].
    - Else,
        - Let defaultValue be the result of evaluating Initializer.
        - Let v be ? GetValue(defaultValue).
5. Else, let v be value.
6. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then
    - Let nestedAssignmentPattern be the AssignmentPattern that is covered by DestructuringAssignmentTarget.
    - Return ? DestructuringAssignmentEvaluation of nestedAssignmentPattern with argument v.
7. Return ? PutValue(lref, v).

>NOTE é€šè¿‡åœ¨è®¿é—®è¿­ä»£å™¨æˆ–è¯„ä¼°åˆå§‹åŒ–ç¨‹åºä¹‹å‰è¯„ä¼°ä¸æ˜¯è§£æ„æ¨¡å¼çš„ DestructuringAssignmentTarget æ¥ç»´æŠ¤ä»å·¦åˆ°å³çš„è¯„ä¼°é¡ºåºã€‚

AssignmentRestElement : ... DestructuringAssignmentTarget
1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
    - Let lref be the result of evaluating DestructuringAssignmentTarget.
    - ReturnIfAbrupt(lref).
2. Let A be ! ArrayCreate(0).
3. Let n be 0.
4. Repeat, while iteratorRecord.[[Done]] is false,
    - Let next be Completion(IteratorStep(iteratorRecord)).
    - If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
    - ReturnIfAbrupt(next).
    - If next is false, set iteratorRecord.[[Done]] to true.
    - Else,
        - Let nextValue be Completion(IteratorValue(next)).
        - If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
        - ReturnIfAbrupt(nextValue).
        - Perform ! CreateDataPropertyOrThrow(A, ! ToString(ğ”½(n)), nextValue).
        - Set n to n + 1.
5. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
    - Return ? PutValue(lref, A).
6. Let nestedAssignmentPattern be the AssignmentPattern that is covered by DestructuringAssignmentTarget.
7. Return ? DestructuringAssignmentEvaluation of nestedAssignmentPattern with argument A.

#### 13.15.5.6 Runtime Semantics: KeyedDestructuringAssignmentEvaluation

è¯­æ³•æŒ‡å¯¼çš„æ“ä½œ KeyedDestructuringAssignmentEvaluation é‡‡ç”¨å‚æ•° value å’Œ propertyName å¹¶è¿”å›åŒ…å«æœªä½¿ç”¨çš„æ­£å¸¸å®Œæˆæˆ–çªç„¶å®Œæˆã€‚å®ƒåœ¨ä»¥ä¸‹äº§ç”Ÿå¼ä¸Šåˆ†æ®µå®šä¹‰ï¼š

AssignmentElement : DestructuringAssignmentTarget Initializeropt

1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
    - Let lref be the result of evaluating DestructuringAssignmentTarget.
    - ReturnIfAbrupt(lref).
2. Let v be ? GetV(value, propertyName).
3. If Initializer is present and v is undefined, then
    - If IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then
        - Let rhsValue be ? NamedEvaluation of Initializer with argument lref.[[ReferencedName]].
    - Else,
        - Let defaultValue be the result of evaluating Initializer.
        - Let rhsValue be ? GetValue(defaultValue).
4. Else, let rhsValue be v.
5. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then
    - Let assignmentPattern be the AssignmentPattern that is covered by DestructuringAssignmentTarget.
    - Return ? DestructuringAssignmentEvaluation of assignmentPattern with argument rhsValue.
6. Return ? PutValue(lref, rhsValue).

## 13.16 Comma Operator ( , )

Syntax

    Expression[In, Yield, Await] :
        AssignmentExpression[?In, ?Yield, ?Await]
        Expression[?In, ?Yield, ?Await] , AssignmentExpression[?In, ?Yield, ?Await]

#### 13.16.1 Runtime Semantics: Evaluation

Expression : Expression , AssignmentExpression

1. Let lref be the result of evaluating Expression.
2. Perform ? GetValue(lref).
3. Let rref be the result of evaluating AssignmentExpression.
4. Return ? GetValue(rref).

>NOTE å³ä½¿æœªä½¿ç”¨ GetValue çš„å€¼ï¼Œä¹Ÿå¿…é¡»è°ƒç”¨å®ƒï¼Œå› ä¸ºå®ƒå¯èƒ½å…·æœ‰å¯è§‚å¯Ÿåˆ°çš„å‰¯ä½œç”¨ã€‚