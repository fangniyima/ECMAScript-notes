<center>Abstract Operations</center>
## 7.1ç±»å‹è½¬æ¢

ECMAScriptè¯­è¨€æ ¹æ®éœ€è¦éšå¼æ‰§è¡Œè‡ªåŠ¨ç±»å‹è½¬æ¢ã€‚ ä¸ºäº†é˜æ˜æŸäº›æ„é€ çš„è¯­ä¹‰ï¼Œå®šä¹‰ä¸€ç»„è½¬æ¢æŠ½è±¡æ“ä½œå¾ˆæœ‰ç”¨ã€‚ è½¬æ¢æŠ½è±¡æ“ä½œæ˜¯å¤šæ€çš„ã€‚ ä»–ä»¬å¯ä»¥æ¥å—ä»»ä½•ECMAScriptè¯­è¨€ç±»å‹çš„å€¼ã€‚ ä½†æ˜¯ï¼Œè¿™äº›æ“ä½œæ²¡æœ‰ä½¿ç”¨å…¶ä»–è§„èŒƒç±»å‹ã€‚

BigIntç±»å‹åœ¨ECMAScriptè¯­è¨€ä¸­æ²¡æœ‰éšå¼è½¬æ¢ã€‚ ç¨‹åºå‘˜å¿…é¡»æ˜¾å¼è°ƒç”¨BigIntæ‰èƒ½è½¬æ¢å…¶ä»–ç±»å‹çš„å€¼ã€‚

### 7.1.1 ToPrimitive(input[ï¼ŒpreferredType]) 
æŠ½è±¡æ“ä½œToPrimitiveæ¥å—å‚æ•°è¾“å…¥å’Œå¯é€‰å‚æ•°preferredTypeã€‚ å®ƒå°†å…¶è¾“å…¥å‚æ•°è½¬æ¢ä¸ºéObjectç±»å‹ã€‚ å¦‚æœå¯¹è±¡èƒ½å¤Ÿè½¬æ¢ä¸ºå¤šä¸ªåŸå§‹ç±»å‹ï¼Œåˆ™å¯ä»¥ä½¿ç”¨å¯é€‰çš„æç¤ºpreferredTypeæ¥æ”¯æŒè¯¥ç±»å‹ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: input is an ECMAScript language value.
    2.If Type(input) is Object, then
        a.Let exoticToPrim be ? GetMethod(input, @@toPrimitive).
        b.If exoticToPrim is not undefined, then
            1.If preferredType is not present, let hint be "default".
            2.Else if preferredType is string, let hint be "string".
            3.Else,
                1.Assert: preferredType is number.
                2.Let hint be "number".
            4.Let result be ? Call(exoticToPrim, input, Â« hint Â»).
            5.If Type(result) is not Object, return result.
            6.Throw a TypeError exception.
        c.If preferredType is not present, let preferredType be number.
        d.Return ? OrdinaryToPrimitive(input, preferredType).
    3.Return input.

    è¯´æ˜:æˆ‘ä»¬ä»¥BigInt(new Number(3))ä¸ºä¾‹æ¥çœ‹ä¸‹æ­¤ç®—æ³•æ­¥éª¤
    1. æ–­è¨€ï¼šinputæ˜¯ä¸€ä¸ªECMAScriptè¯­è¨€å€¼
    2. å¦‚æœinputæ˜¯å¯¹è±¡ï¼Œåˆ™

    3.è¿”å›input

<table><tr><td bgcolor=#E9FBE9 width=10%>
æ³¨æ„

å½“ToPrimitiveåœ¨æ²¡æœ‰æç¤ºçš„æƒ…å†µä¸‹è¢«è°ƒç”¨æ—¶ï¼Œå®ƒçš„è¡Œä¸ºé€šå¸¸å°±å¥½åƒæç¤ºæ˜¯æ•°å­—ä¸€æ ·ã€‚ä½†æ˜¯ï¼Œé€šè¿‡å®šä¹‰@@topPrimitiveæ–¹æ³•ï¼Œå¯¹è±¡å¯èƒ½ä¼šè¶…è¶Šæ­¤è¡Œä¸ºã€‚åœ¨æœ¬è§„èŒƒä¸­å®šä¹‰çš„å¯¹è±¡ä¸­ï¼Œåªæœ‰æ—¥æœŸå¯¹è±¡(è§20.4.4.45)å’Œç¬¦å·å¯¹è±¡(è§19.4.3.5)è¶…è¿‡äº†é»˜è®¤çš„ToPrimitiveè¡Œä¸ºã€‚Dateå¯¹è±¡ä¸å°†ä»»ä½•æç¤ºè§†ä¸ºå­—ç¬¦ä¸²ã€‚
</td></tr></table> 

#### 7.1.1.1 OrdinaryToPrimitive(Oï¼Œ hint )
æŠ½è±¡æ“ä½œOrdinaryToPrimitiveæ¥å—å‚æ•°Oå’Œhintã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: Type(O) is Object.
    2.Assert: hint is either string or number.
    3.If hint is string, then
        Let methodNames be Â« "toString", "valueOf" Â».
    4.Else,
        Let methodNames be Â« "valueOf", "toString" Â».
    5.For each element name of methodNames, do
        Let method be ? Get(O, name).
        If IsCallable(method) is true, then
            Let result be ? Call(method, O).
            If Type(result) is not Object, return result.
    6.Throw a TypeError exception.

### 7.1.2 ToBoolean(å‚æ•°)
æŠ½è±¡æ“ä½œToBooleanæ¥å—å‚æ•°argumentsã€‚ æ ¹æ®è¡¨11å®ƒå°†å‚æ•°è½¬æ¢ä¸ºBooleanç±»å‹çš„å€¼ï¼š

Table 11: ToBoolean Conversions

|Argument Type|Result|
|----|----|
Undefined	|Return false.
Null	|Return false.
Boolean|	Return argument.
Number|	If argument is +0ğ”½, -0ğ”½, or NaN, return false; otherwise return true.
String|	If argument is the empty String (its length is zero), return false; otherwise return true.
Symbol|	Return true.
BigInt|	If argument is 0â„¤, return false; otherwise return true.
Object|	Return true.    NOTE An alternate algorithm related to the [[IsHTMLDDA]] internal slot is mandated in section B.3.7.1.

### 7.1.3 ToNumeric(value)
æŠ½è±¡æ“ä½œToNumericæ¥å—å‚æ•°valueã€‚ å®ƒè¿”å›è½¬æ¢ä¸ºNumberæˆ–BigIntçš„å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Let primValue be ? ToPrimitive(value, number).
    2.If Type(primValue) is BigInt, return primValue.
    3.Return ? ToNumber(primValue).

### 7.1.4 ToNumber(arguments)
æŠ½è±¡æ“ä½œToNumberæ¥å—å‚æ•°argumentsã€‚ æ ¹æ®è¡¨12å°†å‚æ•°è½¬æ¢ä¸ºNumberç±»å‹çš„å€¼ï¼š

Table 12: ToNumber Conversions


Argument Type|	Result
----|----
Undefined	|Return NaN.
Null|	Return +0ğ”½.
Boolean|	If argument is true, return 1ğ”½. If argument is false, return +0ğ”½.
Number|	Return argument (no conversion).
String|	See grammar and conversion algorithm below.
Symbol|	Throw a TypeError exception.
BigInt|	Throw a TypeError exception.
Object|	Apply the following steps:Let primValue be ? ToPrimitive(argument, number).Return ? ToNumber(primValue).

#### 7.1.4.1 ToNumberåº”ç”¨äºå­—ç¬¦ä¸²ç±»å‹
åº”ç”¨äºå­—ç¬¦ä¸²çš„ToNumberå°†ä»¥ä¸‹è¯­æ³•åº”ç”¨äºè¢«è§£é‡Šä¸ºUTF-16ç¼–ç ä»£ç ç‚¹(6.1.4)åºåˆ—çš„è¾“å…¥å­—ç¬¦ä¸²ã€‚ å¦‚æœè¯­æ³•æ— æ³•å°†Stringè§£é‡Šä¸ºStringNumericLiteralçš„æ‰©å±•ï¼Œåˆ™ToNumberçš„ç»“æœä¸ºNaNã€‚

æ³¨1
è¯¥è¯­æ³•çš„ç»“å°¾ç¬¦å·å…¨éƒ¨ç”±UnicodeåŸºæœ¬å¤šè¯­è¨€å¹³é¢(BMP)ä¸­çš„å­—ç¬¦ç»„æˆã€‚ å› æ­¤ï¼Œå¦‚æœå­—ç¬¦ä¸²åŒ…å«ä»»ä½•æˆå¯¹çš„æˆ–ä¸æˆå¯¹çš„å‰å¯¼æˆ–å°¾éšæ›¿ä»£ä»£ç å•å…ƒï¼Œåˆ™ToNumberçš„ç»“æœå°†ä¸ºNaNã€‚

    Syntax
        StringNumericLiteral:::
        StrWhiteSpaceopt
        StrWhiteSpaceoptStrNumericLiteralStrWhiteSpaceopt
        StrWhiteSpace:::
        StrWhiteSpaceCharStrWhiteSpaceopt
        StrWhiteSpaceChar:::
        WhiteSpace
        LineTerminator
        StrNumericLiteral:::
        StrDecimalLiteral
        NonDecimalIntegerLiteral[~Sep]
        StrDecimalLiteral:::
        StrUnsignedDecimalLiteral
        +StrUnsignedDecimalLiteral
        -StrUnsignedDecimalLiteral
        StrUnsignedDecimalLiteral:::
        Infinity
        DecimalDigits[~Sep].DecimalDigits[~Sep]optExponentPart[~Sep]opt
        .DecimalDigits[~Sep]ExponentPart[~Sep]opt
        DecimalDigits[~Sep]ExponentPart[~Sep]opt

ä¸Šé¢æœªæ˜ç¡®å®šä¹‰çš„æ‰€æœ‰è¯­æ³•ç¬¦å·éƒ½å…·æœ‰åœ¨è¯æ³•è¯­æ³•ä¸­ç”¨äºæ•°å­—æ–‡å­—çš„å®šä¹‰(11.8.3)

é™„æ³¨2

åº”æ³¨æ„StringNumericLiteralå’ŒNumericLiteralçš„è¯­æ³•ä¹‹é—´çš„ä¸€äº›å·®å¼‚ï¼š

StringNumericLiteralå¯ä»¥åŒ…æ‹¬å‰å¯¼å’Œ/æˆ–å°¾éšç©ºæ ¼å’Œ/æˆ–è¡Œç»“æŸç¬¦ã€‚

åè¿›åˆ¶çš„StringNumericLiteralå¯ä»¥æœ‰ä»»ä½•æ•°é‡çš„å‰å¯¼0ä½æ•°ã€‚

åè¿›åˆ¶çš„StringNumericLiteralå¯ä»¥åŒ…å«ä¸€ä¸ª+æˆ–-æ¥è¡¨ç¤ºå®ƒçš„ç¬¦å·ã€‚

ä¸ºç©ºæˆ–ä»…åŒ…å«ç©ºç™½çš„StringNumericLiteralå°†è½¬æ¢ä¸º+0ğ”½ã€‚

æ— ç©·å’Œ-Infinityè¢«è¯†åˆ«ä¸ºStringNumericLiteralï¼Œè€Œä¸æ˜¯NumericLiteralã€‚

StringNumericLiteralä¸èƒ½åŒ…å«BigIntLiteralSuffixã€‚

##### 7.1.4.1.1 Runtime Semantics: MV

å­—ç¬¦ä¸²åˆ°æ•°å­—å€¼çš„è½¬æ¢æ€»ä½“ä¸Šä¸æ•°å­—æ–‡æœ¬çš„æ•°å­—å€¼çš„ç¡®å®šç±»ä¼¼(è§11.8.3)ï¼Œä½†æœ‰äº›ç»†èŠ‚ä¸åŒï¼Œå› æ­¤è¿™é‡Œç»™å‡ºäº†å°†å­—ç¬¦ä¸²æ•°å­—æ–‡æœ¬è½¬æ¢ä¸ºæ•°å­—ç±»å‹å€¼çš„è¿‡ç¨‹ã€‚æ­¤å€¼åˆ†ä¸¤æ­¥ç¡®å®šï¼šé¦–å…ˆï¼Œä»å­—ç¬¦ä¸²æ•°å­—æ–‡æœ¬æ´¾ç”Ÿæ•°å­¦å€¼(MV)ï¼›å…¶æ¬¡ï¼Œæ­¤æ•°å­¦å€¼æŒ‰å¦‚ä¸‹æ‰€è¿°å››èˆäº”å…¥ã€‚ä»¥ä¸‹æœªæä¾›çš„ä»»ä½•è¯­æ³•ç¬¦å·ä¸Šçš„MVæ˜¯11.8.3.1ä¸­å®šä¹‰çš„è¯¥ç¬¦å·çš„MVã€‚

    The MV of StringNumericLiteral:::[empty] is 0.
    The MV of StringNumericLiteral:::StrWhiteSpace is 0.
    The MV of StringNumericLiteral:::StrWhiteSpaceoptStrNumericLiteralStrWhiteSpaceopt is the MV of StrNumericLiteral, no matter whether white space is present or not.
    The MV of StrDecimalLiteral:::-StrUnsignedDecimalLiteral is the negative of the MV of StrUnsignedDecimalLiteral. (Note that if the MV of StrUnsignedDecimalLiteral is 0, the negative of this MV is also 0. The rounding rule described below handles the conversion of this signless mathematical zero to a floating-point +0ğ”½ or -0ğ”½ as appropriate.)
    The MV of StrUnsignedDecimalLiteral:::Infinity is 1010000 (a value so large that it will round to +âˆğ”½).
    The MV of StrUnsignedDecimalLiteral:::DecimalDigits.DecimalDigits is the MV of the first DecimalDigits plus (the MV of the second DecimalDigits times 10-n), where n is the number of code points in the second DecimalDigits.
    The MV of StrUnsignedDecimalLiteral:::DecimalDigits.ExponentPart is the MV of DecimalDigits times 10e, where e is the MV of ExponentPart.
    The MV of StrUnsignedDecimalLiteral:::DecimalDigits.DecimalDigitsExponentPart is (the MV of the first DecimalDigits plus (the MV of the second DecimalDigits times 10-n)) times 10e, where n is the number of code points in the second DecimalDigits and e is the MV of ExponentPart.
    The MV of StrUnsignedDecimalLiteral:::.DecimalDigits is the MV of DecimalDigits times 10-n, where n is the number of code points in DecimalDigits.
    The MV of StrUnsignedDecimalLiteral:::.DecimalDigitsExponentPart is the MV of DecimalDigits times 10e - n, where n is the number of code points in DecimalDigits and e is the MV of ExponentPart.
    The MV of StrUnsignedDecimalLiteral:::DecimalDigitsExponentPart is the MV of DecimalDigits times 10e, where e is the MV of ExponentPart.


ç¡®å®šäº†å­—ç¬¦ä¸²æ•°å­—æ–‡å­—çš„ç¡®åˆ‡MVä¹‹åï¼Œå°†å…¶å››èˆäº”å…¥ä¸ºNumberç±»å‹çš„å€¼ã€‚ å¦‚æœMVä¸º0ï¼Œåˆ™å››èˆäº”å…¥åçš„å€¼ä¸º+0ğ”½ï¼Œé™¤éStringæ•°å­—æ–‡å­—ä¸­çš„ç¬¬ä¸€ä¸ªéç©ºç™½ä»£ç ç‚¹ä¸º-ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå››èˆäº”å…¥åçš„å€¼ä¸º-0ğ”½ã€‚ å¦åˆ™ï¼Œå››èˆäº”å…¥çš„å€¼å¿…é¡»æ˜¯MVçš„Numberå€¼(åœ¨6.1.6.1ä¸­å®šä¹‰)ï¼Œé™¤éæ–‡å­—åŒ…æ‹¬StrUnsignedDecimalLiteralä¸”æ–‡å­—å…·æœ‰20ä¸ªä»¥ä¸Šçš„æœ‰æ•ˆæ•°å­—ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹Numberå€¼å¯ä»¥æ˜¯ é€šè¿‡å°†20å·ä¹‹åçš„æ¯ä¸ªæœ‰æ•ˆæ•°å­—æ›¿æ¢ä¸º0ä½è€Œäº§ç”Ÿçš„æ–‡å­—çš„MVçš„æ•°å€¼ï¼Œæˆ–è€…å°†20å·ä¹‹åçš„æ¯ä¸ªæœ‰æ•ˆæ•°å­—æ›¿æ¢ä¸º0ä½è€Œäº§ç”Ÿçš„æ–‡å­—çš„MVçš„Numberå€¼ï¼Œç„¶ååœ¨ 20ä½æ•°å­—çš„ä½ç½®ã€‚ å¦‚æœæ•°å­—ä¸æ˜¯ExpnentPartçš„ä¸€éƒ¨åˆ†ï¼Œåˆ™è¯¥æ•°å­—æ˜¯æœ‰æ•ˆçš„ï¼Œå¹¶ä¸”

    it is not 0; or
    there is a non-zero digit to its left and there is a non-zero digit, not in the ExponentPart, to its right.


### 7.1.5 ToIntegerOrInfinity(argument)
æŠ½è±¡æ“ä½œToIntegerOrInfinityæ¥å—å‚æ•°argumentsã€‚ å®ƒå°†å‚æ•°è½¬æ¢ä¸ºæ•´æ•°ï¼Œ+âˆæˆ–-âˆã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Let number be ? ToNumber(argument).
    If number is NaN, +0ğ”½, or -0ğ”½, return 0.
    If number is +âˆğ”½, return +âˆ.
    If number is -âˆğ”½, return -âˆ.
    Let integer be floor(abs(â„(number))).
    If number < +0ğ”½, set integer to -integer.
    Return integer.

### 7.1.6 ToInt32 ( argument )
æŠ½è±¡æ“ä½œToInt32æ¥å—å‚æ•°argumentsã€‚ å®ƒå°†å‚æ•°è½¬æ¢ä¸ºğ”½(-231)åˆ°ğ”½(231-1)(å«)èŒƒå›´å†…çš„232ä¸ªæ•´æ•°å€¼ä¹‹ä¸€ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Let number be ? ToNumber(argument).
    If number is NaN, +0ğ”½, -0ğ”½, +âˆğ”½, or -âˆğ”½, return +0ğ”½.
    Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(â„(number))).
    Let int32bit be int modulo 232.
    If int32bit â‰¥ 231, return ğ”½(int32bit - 232); otherwise return ğ”½(int32bit).
<table><tr><td bgcolor=#E9FBE9 width=10%>
æ³¨æ„

é‰´äºToInt32çš„ä¸Šè¿°å®šä¹‰ï¼š

ToInt32æŠ½è±¡æ“ä½œæ˜¯å¹‚ç­‰çš„ï¼šå¦‚æœåº”ç”¨äºå®ƒäº§ç”Ÿçš„ç»“æœï¼Œç¬¬äºŒä¸ªåº”ç”¨ç¨‹åºå°†ä½¿è¯¥å€¼ä¿æŒä¸å˜ã€‚
å¯¹äºxçš„æ‰€æœ‰å€¼ï¼ŒToInt32(ToUint32(x))ä¸ToInt32(x)çš„å€¼ç›¸åŒã€‚ (è¦ä¿ç•™åä¸€ä¸ªå±æ€§ï¼Œå°†+âˆğ”½å’Œ-âˆğ”½æ˜ å°„åˆ°+0ğ”½ã€‚)
ToInt32å°†-0ğ”½æ˜ å°„åˆ°+0ğ”½ã€‚
</td></tr></table> 

### 7.1.7 ToUint32 ( argument )

æŠ½è±¡æ“ä½œToUint32æ¥å—å‚æ•°argumentsã€‚ å®ƒå°†å‚æ•°è½¬æ¢ä¸º2<sup>32</sup>æ•´æ•°å€¼ä¹‹ä¸€ï¼ŒèŒƒå›´ä¸º+0ğ”½åˆ°ğ”½(2<sup>32</sup>-1)(å«)ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Let number be ? ToNumber(argument).
    If number is NaN, +0ğ”½, -0ğ”½, +âˆğ”½, or -âˆğ”½, return +0ğ”½.
    Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(â„(number))).
    Let int32bit be int modulo 232.
    Return ğ”½(int32bit).

NOTE
Given the above definition of ToUint32:

Step 5 is the only difference between ToUint32 and ToInt32.
The ToUint32 abstract operation is idempotent: if applied to a result that it produced, the second application leaves that value unchanged.
ToUint32(ToInt32(x)) is the same value as ToUint32(x) for all values of x. (It is to preserve this latter property that +âˆğ”½ and -âˆğ”½ are mapped to +0ğ”½.)
ToUint32 maps -0ğ”½ to +0ğ”½.
### 7.1.8 ToInt16 ( argument )

int16çš„æŠ½è±¡æ“ä½œé‡‡ç”¨å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸ºğ”½ï¼ˆ-215ï¼‰åˆ°ğ”½ï¼ˆ215-1ï¼‰èŒƒå›´å†…çš„216ä¸ªæ•´æ•°å€¼ä¹‹ä¸€ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Let number be ? ToNumber(argument).
    If number is NaN, +0ğ”½, -0ğ”½, +âˆğ”½, or -âˆğ”½, return +0ğ”½.
    Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(â„(number))).
    Let int16bit be int modulo 216.
    If int16bit â‰¥ 215, return ğ”½(int16bit - 216); otherwise return ğ”½(int16bit).

### 7.1.9 ToUint16 ( argument )

æŠ½è±¡æ“ä½œToUint16æ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸ºèŒƒå›´ä»+0ğ”½åˆ°ğ”½ï¼ˆ216-1ï¼‰çš„216ä¸ªæ•´æ•°å€¼ä¹‹ä¸€ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Let number be ? ToNumber(argument).
    If number is NaN, +0ğ”½, -0ğ”½, +âˆğ”½, or -âˆğ”½, return +0ğ”½.
    Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(â„(number))).
    Let int16bit be int modulo 216.
    Return ğ”½(int16bit).

<table><tr><td bgcolor=#E9FBE9>
æ³¨æ„

æ ¹æ®ä¸Šè¿°å®šä¹‰ï¼šåœ¨æ­¥éª¤4ä¸­ç”¨216æ›¿æ¢232æ˜¯ToUint32å’ŒToUint16ä¹‹é—´çš„å”¯ä¸€åŒºåˆ«ã€‚
ToUint16æ˜ å°„-0ğ”½åˆ°+0ğ”½ã€‚
</td></tr></table>

### 7.1.10 ToInt8 ( argument )

int8çš„æŠ½è±¡æ“ä½œæ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸º-128ğ”½åˆ°127ğ”½èŒƒå›´å†…çš„28ä¸ªæ•´æ•°å€¼ä¹‹ä¸€ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š


    Let number be ? ToNumber(argument).
    If number is NaN, +0ğ”½, -0ğ”½, +âˆğ”½, or -âˆğ”½, return +0ğ”½.
    Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(â„(number))).
    Let int8bit be int modulo 28.
    If int8bit â‰¥ 27, return ğ”½(int8bit - 28); otherwise return ğ”½(int8bit).


### 7.1.11 ToUint8 ( argument )

æŠ½è±¡æ“ä½œToUint8æ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸º28ä¸ªæ•´æ•°å€¼ä¹‹ä¸€ï¼ŒèŒƒå›´ä»+0ğ”½åˆ°255ğ”½ï¼ˆå«ï¼‰ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Let number be ? ToNumber(argument).
    If number is NaN, +0ğ”½, -0ğ”½, +âˆğ”½, or -âˆğ”½, return +0ğ”½.
    Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(â„(number))).
    Let int8bit be int modulo 28.
    Return ğ”½(int8bit).

### 7.1.12 ToUint8Clamp ( argument )

æŠ½è±¡æ“ä½œToUint8Clampæ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸º28ä¸ªæ•´æ•°å€¼ä¹‹ä¸€ï¼ŒèŒƒå›´ä»+0ğ”½åˆ°255ğ”½ï¼ˆå«ï¼‰ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Let number be ? ToNumber(argument).
    If number is NaN, return +0ğ”½.
    If â„(number) â‰¤ 0, return +0ğ”½.
    If â„(number) â‰¥ 255, return 255ğ”½.
    Let f be floor(â„(number)).
    If f + 0.5 < â„(number), return ğ”½(f + 1).
    If â„(number) < f + 0.5, return ğ”½(f).
    If f is odd, return ğ”½(f + 1).
    Return ğ”½(f).

<table><tr><td bgcolor=#E9FBE9>
æ³¨æ„

ä¸å…¶ä»–ECMAScriptæ•´æ•°è½¬æ¢æŠ½è±¡æ“ä½œä¸åŒï¼ŒToUint8Clampå–æ•´è€Œä¸æ˜¯æˆªæ–­éæ•´æ•°å€¼ï¼Œå¹¶ä¸”ä¸ä¼šå°†+âˆğ”½è½¬æ¢ä¸º+0ğ”½ã€‚ToUint8Clampåšâ€œå››èˆäº”å…¥â€çš„å¹³å±€ã€‚è¿™ä¸æ•°å­¦.åœ†å½¢å®ƒèƒ½ä½¿å¹³å±€â€œå››èˆäº”å…¥â€ã€‚
</td></tr></table>

### 7.1.13 ToBigInt ( argument )

æŠ½è±¡æ“ä½œToBigIntæ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸ºBigIntå€¼ï¼Œæˆ–è€…åœ¨éœ€è¦ä»Numberéšå¼è½¬æ¢æ—¶æŠ›å‡ºã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Let prim be ? ToPrimitive(argument, number).
    Return the value that prim corresponds to in Table 13.

<center>Table 13: BigInt Conversions</center>

|Argument Type	    |Result|
|----|----|
Undefined	        |Throw a TypeError exception.
Null	            |Throw a TypeError exception.
Boolean	            |Return 1n if prim is true and 0n if prim is false.
BigInt	            |Return prim.
Number	            |Throw a TypeError exception.
String	            |1.Let n be ! StringToBigInt(prim). 2.If n is NaN, throw a SyntaxError exception.  3.Return n.
Symbol	            |Throw a TypeError exception.

### 7.1.14 StringToBigInt ( argument )

åº”ç”¨7.1.4.1ä¸­çš„ç®—æ³•ï¼Œå¹¶è¿›è¡Œä»¥ä¸‹æ›´æ”¹ï¼š

- Replace the StrUnsignedDecimalLiteral production with DecimalDigits to not allow Infinity, decimal points, or exponents.
- If the MV is NaN, return NaN, otherwise return the BigInt which exactly corresponds to the MV, rather than rounding to a Number.


### 7.1.15 ToBigInt64 ( argument )

æŠ½è±¡æ“ä½œToBigInt64æ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸ºèŒƒå›´ä¸ºâ„¤ï¼ˆ-263ï¼‰åˆ°â„¤ï¼ˆ263-1ï¼‰çš„264ä¸ªBigIntå€¼ä¹‹ä¸€ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Let n be ? ToBigInt(argument).
    Let int64bit be â„(n) modulo 264.
    If int64bit â‰¥ 263, return â„¤(int64bit - 264); otherwise return â„¤(int64bit).

### 7.1.17 ToString(argument)

æŠ½è±¡æ“ä½œToStringæ¥å—å‚æ•°argumentsã€‚ æ ¹æ®è¡¨14å°†å‚æ•°è½¬æ¢ä¸ºStringç±»å‹çš„å€¼ï¼š

Table 14: ToString Conversions

|Argument Type|Result|
|----|----|
|Undefined|	Return| "undefined".
|Null	|Return "null".
|Boolean	|If argument is true, return "true".If argument is false, return "false".
|Number|	Return ! Number::toString(argument).
|String|	Return argument.
|Symbol	|Throw a TypeError exception.
|BigInt|	Return ! BigInt::toString(argument).
|Object	|Apply the following steps:Let primValue be ? ToPrimitive(argument, string).Return ? ToString(primValue).

å†™è€…æ³¨:
String(undefined),''+,tostring()ç­‰ç­‰

### 7.1.18 ToObject ( argument )

ToObjectçš„æŠ½è±¡æ“ä½œæ¥å—å‚æ•°å‚æ•°ã€‚å®ƒæ ¹æ®è¡¨15å°†å‚æ•°è½¬æ¢ä¸ºObjectç±»å‹çš„å€¼ï¼š

Table 15: ToObject Conversions

|Argument Type|	Result|
|----|----|
Undefined	|å¼•å‘TypeErrorå¼‚å¸¸ã€‚
Null        |å¼•å‘TypeErrorå¼‚å¸¸ã€‚
Boolean     |è¿”å›ä¸€ä¸ªæ–°çš„å¸ƒå°”å¯¹è±¡ï¼Œå…¶[[BooleanData]]å†…éƒ¨æ§½è®¾ç½®ä¸ºå‚æ•°ã€‚æœ‰å…³å¸ƒå°”å¯¹è±¡çš„æè¿°ï¼Œè¯·å‚è§19.3
Number      |è¿”å›ä¸€ä¸ªæ–°çš„Numberå¯¹è±¡ï¼Œå…¶[[NumberData]]å†…éƒ¨æ§½è®¾ç½®ä¸ºargumentã€‚æœ‰å…³æ•°å­—å¯¹è±¡çš„è¯´æ˜ï¼Œè¯·å‚è§20.1ã€‚
String      |è¿”å›ä¸€ä¸ªæ–°çš„Stringå¯¹è±¡ï¼Œå…¶[[StringData]]å†…éƒ¨æ§½è®¾ç½®ä¸ºargumentã€‚æœ‰å…³å­—ç¬¦ä¸²å¯¹è±¡çš„æè¿°ï¼Œè¯·å‚è§21.1ã€‚
Symbol      |è¿”å›ä¸€ä¸ªæ–°çš„Symbolå¯¹è±¡ï¼Œå…¶[[SymbolData]]å†…éƒ¨æ§½è®¾ç½®ä¸ºå‚æ•°ã€‚ç¬¦å·å¯¹è±¡çš„è¯´æ˜è§19.4ã€‚
BigInt      |è¿”å›ä¸€ä¸ªæ–°çš„BigIntå¯¹è±¡ï¼Œå…¶[[BigIntData]]å†…éƒ¨æ§½è®¾ç½®ä¸ºargumentã€‚æœ‰å…³BigIntå¯¹è±¡çš„æè¿°ï¼Œè¯·å‚è§20.2ã€‚	
Object      |è¿”å›argument.

### 7.1.19 ToPropertyKey(å‚æ•°)

æŠ½è±¡æ“ä½œToPropertyKeyæ¥å—å‚æ•°argumentsã€‚ å®ƒå°†å‚æ•°è½¬æ¢ä¸ºå¯ä»¥ç”¨ä½œå±æ€§é”®çš„å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Let key be ? ToPrimitive(argument, string).
    If Type(key) is Symbol, then
        Return key.
    Return ! ToString(key).

### 7.1.20 ToLength ( argument )

ToLengthçš„æŠ½è±¡æ“ä½œæ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸ºé€‚åˆç”¨ä½œç±»ä¼¼æ•°ç»„å¯¹è±¡é•¿åº¦çš„æ•´æ•°ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Let len be ? ToIntegerOrInfinity(argument).
    If len â‰¤ 0, return +0ğ”½.
    Return ğ”½(min(len, 253 - 1)).

### 7.1.21 CanonicalNumericIndexString ( argument )

æŠ½è±¡æ“ä½œCanonicalNumericIndexStringæ¥å—å‚æ•°å‚æ•°ã€‚å¦‚æœå®ƒæ˜¯ToStringæˆ–å­—ç¬¦ä¸²â€œ-0â€ç”Ÿæˆçš„æ•°å­—çš„å­—ç¬¦ä¸²è¡¨ç¤ºå½¢å¼ï¼Œåˆ™è¿”å›è½¬æ¢ä¸ºæ•°å­—å€¼çš„å‚æ•°ã€‚å¦åˆ™ï¼Œè¿”å›æœªå®šä¹‰ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Assert: Type(argument) is String.
    If argument is "-0", return -0ğ”½.
    Let n be ! ToNumber(argument).
    If SameValue(! ToString(n), argument) is false, return undefined.
    Return n.

è§„èŒƒæ•°å­—å­—ç¬¦ä¸²æ˜¯CanonicalNumericIndexStringæŠ½è±¡æ“ä½œä¸ä¼šè¿”å›undefinedçš„ä»»ä½•Stringå€¼ã€‚

### 7.1.22 ToIndex ( value )

æŠ½è±¡æ“ä½œToIndexæ¥å—å‚æ•°å€¼ã€‚ å¦‚æœå®ƒæ˜¯æœ‰æ•ˆçš„æ•´æ•°ç´¢å¼•å€¼ï¼Œåˆ™è¿”å›è½¬æ¢ä¸ºéè´Ÿæ•´æ•°çš„valueå‚æ•°ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    If value is undefined, then
        Return 0.
    Else,
        Let integerIndex be ğ”½(? ToIntegerOrInfinity(value)).
        If integerIndex < +0ğ”½, throw a RangeError exception.
        Let index be ! ToLength(integerIndex).
        If ! SameValue(integerIndex, index) is false, throw a RangeError exception.
        Return â„(index).    




