<center>Abstract Operations</center>

è¿™äº›æ“ä½œä¸æ˜¯ECMAScriptè¯­è¨€çš„ä¸€éƒ¨åˆ†ï¼›å®ƒä»¬åœ¨è¿™é‡Œçš„å®šä¹‰ä»…ä»…æ˜¯ä¸ºäº†å¸®åŠ©è§„èŒƒECMAScriptè¯­è¨€çš„è¯­ä¹‰ã€‚æœ¬è§„èŒƒä¸­å®šä¹‰äº†å…¶ä»–æ›´ä¸“é—¨çš„æŠ½è±¡æ“ä½œã€‚

## 7.1ç±»å‹è½¬æ¢

ECMAScriptè¯­è¨€æ ¹æ®éœ€è¦éšå¼æ‰§è¡Œè‡ªåŠ¨ç±»å‹è½¬æ¢ã€‚ ä¸ºäº†é˜æ˜æŸäº›æ„é€ çš„è¯­ä¹‰ï¼Œå®šä¹‰ä¸€ç»„è½¬æ¢æŠ½è±¡æ“ä½œå¾ˆæœ‰ç”¨ã€‚ è½¬æ¢æŠ½è±¡æ“ä½œæ˜¯å¤šæ€çš„ã€‚ ä»–ä»¬å¯ä»¥æ¥å—ä»»ä½•ECMAScriptè¯­è¨€ç±»å‹çš„å€¼ã€‚ ä½†æ˜¯ï¼Œè¿™äº›æ“ä½œæ²¡æœ‰ä½¿ç”¨å…¶ä»–è§„èŒƒç±»å‹ã€‚

BigIntç±»å‹åœ¨ECMAScriptè¯­è¨€ä¸­æ²¡æœ‰éšå¼è½¬æ¢ã€‚ ç¨‹åºå‘˜å¿…é¡»æ˜¾å¼è°ƒç”¨BigIntæ‰èƒ½è½¬æ¢å…¶ä»–ç±»å‹çš„å€¼ã€‚

### 7.1.1 ToPrimitive(input[ï¼ŒpreferredType]) 

æŠ½è±¡æ“ä½œToPrimitiveæ¥å—å‚æ•°inputå’Œå¯é€‰å‚æ•°preferredTypeã€‚ å®ƒå°†å…¶è¾“å…¥å‚æ•°è½¬æ¢ä¸ºéObjectç±»å‹ã€‚ å¦‚æœå¯¹è±¡èƒ½å¤Ÿè½¬æ¢ä¸ºå¤šä¸ªåŸå§‹ç±»å‹ï¼Œåˆ™å¯ä»¥ä½¿ç”¨å¯é€‰çš„æç¤ºpreferredTypeæ¥æ”¯æŒè¯¥ç±»å‹ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.If Type(input) is Object, then
        a.Let exoticToPrim be ? GetMethod(input, @@toPrimitive).
        b.If exoticToPrim is not undefined, then
            1.If preferredType is not present, let hint be "default".
            2.Else if preferredType is string, let hint be "string".
            3.Else,
                1.Assert: preferredType is number.
                2.Let hint be "number".
            4.Let result be ? Call(exoticToPrim, input, Â« hint Â»).
            5.If Type(result) is not Object, return result.
            6.Throw a TypeError exception.
        c.If preferredType is not present, let preferredType be number.
        d.Return ? OrdinaryToPrimitive(input, preferredType).
    2.Return input.

    1. å¦‚æœinputæ˜¯å¯¹è±¡ï¼Œåˆ™
        a. ä»¤exoticToPrimä¸º?GetMethod(input, @@toPrimitive)
        b. å¦‚æœexoticToPrimä¸æ˜¯undefined,ç„¶å
            1. å¦‚æœpreferredTypeä¸å­˜åœ¨ï¼Œä»¤hintä¸ºdefault
            2. å¦åˆ™å¦‚æœpreferredTypeæ˜¯string,ä»¤hintä¸ºstring
            3. å¦åˆ™
                1. æ–­è¨€ï¼špreferredTypeæ˜¯æ•°å­—
                2. ä»¤hintä¸ºstring
            4. ä»¤result ä¸º ?Call(exoticToPrim, input, Â« hint Â»)
            5. å¦‚æœresultç±»å‹ä¸æ˜¯Objectï¼Œè¿”å›
            6. æŠ›å‡ºç±»å‹é”™è¯¯
        c. å¦‚æœpreferredTypeä¸å­˜åœ¨ï¼Œä»¤preferredTypeä¸ºnumber
        d. è¿”å› ? OrdinaryToPrimitive(input, preferredType)
    2.è¿”å›input

> å½“ToPrimitiveåœ¨æ²¡æœ‰æç¤ºçš„æƒ…å†µä¸‹è¢«è°ƒç”¨æ—¶ï¼Œå®ƒçš„è¡Œä¸ºé€šå¸¸å°±å¥½åƒæç¤ºæ˜¯æ•°å­—ä¸€æ ·ã€‚ä½†æ˜¯ï¼Œé€šè¿‡å®šä¹‰@@topPrimitiveæ–¹æ³•ï¼Œå¯¹è±¡å¯èƒ½ä¼šè¶…è¶Šæ­¤è¡Œä¸ºã€‚åœ¨æœ¬è§„èŒƒä¸­å®šä¹‰çš„å¯¹è±¡ä¸­ï¼Œåªæœ‰æ—¥æœŸå¯¹è±¡(è§21.4.4.45)å’Œç¬¦å·å¯¹è±¡(è§20.4.3.5)è¶…è¿‡äº†é»˜è®¤çš„ToPrimitiveè¡Œä¸ºã€‚æ—¥æœŸå°†æ²¡æœ‰æç¤ºè§†ä¸ºæç¤ºæ˜¯å­—ç¬¦ä¸²ã€‚

#### 7.1.1.1 OrdinaryToPrimitive(Oï¼Œ hint )

æŠ½è±¡æ“ä½œOrdinaryToPrimitiveæ¥å—å‚æ•°Oå’Œhintã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.If hint is string, then
        Let methodNames be Â« "toString", "valueOf" Â».
    2.Else,
        Let methodNames be Â« "valueOf", "toString" Â».
    3.For each element name of methodNames, do
        Let method be ? Get(O, name).
        If IsCallable(method) is true, then
            Let result be ? Call(method, O).
            If Type(result) is not Object, return result.
    4.Throw a TypeError exception.

### 7.1.2 ToBoolean(å‚æ•°)

æŠ½è±¡æ“ä½œToBooleanæ¥å—å‚æ•°å‚æ•°ï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å¹¶è¿”å›å¸ƒå°”å€¼ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸ºå¸ƒå°”ç±»å‹çš„å€¼ã€‚è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If argument is a Boolean, return argument.
2. If argument is any of undefined, null, +0ğ”½, -0ğ”½, NaN, 0â„¤, or the empty String, return false.
3. If argument is an Object and argument has an [[IsHTMLDDA]] internal slot, return false.
4. Return true.

> åªéœ€è¦æ³¨æ„BigInt(0)ä¸ºfalseå°±å¯ä»¥äº†

### 7.1.3 ToNumeric(value)

æŠ½è±¡æ“ä½œToNumeric(æ•°å€¼å‹æ•°æ®)æ¥å—å‚æ•°valueã€‚ å®ƒè¿”å›è½¬æ¢ä¸ºNumberæˆ–BigIntçš„å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let primValue be ? ToPrimitive(value, number).
2. If Type(primValue) is BigInt, return primValue.
3. Return ? ToNumber(primValue).

### 7.1.4 ToNumber(arguments)

æŠ½è±¡æ“ä½œToNumberæ¥å—å‚æ•°argumentsã€‚ æ ¹æ®è¡¨12å°†å‚æ•°è½¬æ¢ä¸ºNumberç±»å‹çš„å€¼ï¼š

1. If argument is a Number, return argument.
2. If argument is either a Symbol or a BigInt, throw a TypeError exception.
3. If argument is undefined, return NaN.
4. If argument is either null or false, return +0ğ”½.
5. If argument is true, return 1ğ”½.
6. If argument is a String, return StringToNumber(argument).
7. Assert: argument is an Object.
8. Let primValue be ? ToPrimitive(argument, number).
9. Assert: primValue is not an Object.
10. Return ? ToNumber(primValue).

#### 7.1.4.1 ToNumberåº”ç”¨äºå­—ç¬¦ä¸²ç±»å‹

åº”ç”¨äºå­—ç¬¦ä¸²çš„ToNumberå°†ä»¥ä¸‹è¯­æ³•åº”ç”¨äºè¢«è§£é‡Šä¸ºUTF-16ç¼–ç ä»£ç ç‚¹(6.1.4)åºåˆ—çš„è¾“å…¥å­—ç¬¦ä¸²ã€‚ å¦‚æœè¯­æ³•æ— æ³•å°†Stringè§£é‡Šä¸ºStringNumericLiteralçš„æ‰©å±•ï¼Œåˆ™ToNumberçš„ç»“æœä¸ºNaNã€‚

>NOTE1 è¯¥è¯­æ³•çš„ç»“å°¾ç¬¦å·å…¨éƒ¨ç”±UnicodeåŸºæœ¬å¤šè¯­è¨€å¹³é¢(BMP)ä¸­çš„å­—ç¬¦ç»„æˆã€‚ å› æ­¤ï¼Œå¦‚æœå­—ç¬¦ä¸²åŒ…å«ä»»ä½•æˆå¯¹çš„æˆ–ä¸æˆå¯¹çš„å‰å¯¼æˆ–å°¾éšæ›¿ä»£ä»£ç å•å…ƒï¼Œåˆ™ToNumberçš„ç»“æœå°†ä¸ºNaNã€‚

    Syntax
        StringNumericLiteral:::
            StrWhiteSpaceopt
            StrWhiteSpaceopt StrNumericLiteral StrWhiteSpaceopt
        StrWhiteSpace:::
            StrWhiteSpaceCharStrWhiteSpaceopt
        StrWhiteSpaceChar:::
            WhiteSpace
            LineTerminator
        StrNumericLiteral:::
            StrDecimalLiteral
            NonDecimalIntegerLiteral[~Sep]
        StrDecimalLiteral:::
            StrUnsignedDecimalLiteral
            +StrUnsignedDecimalLiteral
            -StrUnsignedDecimalLiteral
        StrUnsignedDecimalLiteral:::
            Infinity
            DecimalDigits[~Sep].DecimalDigits[~Sep]optExponentPart[~Sep]opt
            .DecimalDigits[~Sep]ExponentPart[~Sep]opt
            DecimalDigits[~Sep]ExponentPart[~Sep]opt

ä¸Šé¢æœªæ˜ç¡®å®šä¹‰çš„æ‰€æœ‰è¯­æ³•ç¬¦å·éƒ½å…·æœ‰æ•°å­—æ–‡å­—çš„è¯æ±‡è¯­æ³• (12.9.3) ä¸­ä½¿ç”¨çš„å®šä¹‰

>NOTE åº”æ³¨æ„StringNumericLiteralå’ŒNumericLiteralçš„è¯­æ³•ä¹‹é—´çš„ä¸€äº›å·®å¼‚ï¼š

- StringNumericLiteralå¯ä»¥åŒ…æ‹¬å‰å¯¼å’Œ/æˆ–å°¾éšç©ºæ ¼å’Œ/æˆ–è¡Œç»“æŸç¬¦ã€‚
- åè¿›åˆ¶çš„StringNumericLiteralå¯ä»¥æœ‰ä»»ä½•æ•°é‡çš„å‰å¯¼0ä½æ•°ã€‚
- åè¿›åˆ¶çš„StringNumericLiteralå¯ä»¥åŒ…å«ä¸€ä¸ª+æˆ–-æ¥è¡¨ç¤ºå®ƒçš„ç¬¦å·ã€‚
- ä¸ºç©ºæˆ–ä»…åŒ…å«ç©ºç™½çš„StringNumericLiteralå°†è½¬æ¢ä¸º+0ğ”½ã€‚
- Infinityå’Œ-Infinityè¢«è¯†åˆ«ä¸ºStringNumericLiteralï¼Œè€Œä¸æ˜¯NumericLiteralã€‚
- StringNumericLiteralä¸èƒ½åŒ…å«BigIntLiteralSuffixã€‚
- StringNumericLiteralä¸èƒ½åŒ…å«NumericLiteratorã€‚

' Infinity ' == Infinity
//true
' 123 ' ==123
//true

##### 7.1.4.1.1 StringToNumber ( str )

æŠ½è±¡æ“ä½œStringToNumberæ¥å—å‚æ•°strï¼ˆå­—ç¬¦ä¸²ï¼‰ã€‚å®ƒè¿”å›ä¸€ä¸ªæ•°å­—ã€‚å®ƒåœ¨è¢«è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let text be ! StringToCodePoints(str).
2. Let literal be ParseText(text, StringNumericLiteral).
3. If literal is a List of errors, return NaN.
4. Return StringNumericValue of literal.

##### 7.1.4.1.2 Runtime Semantics: StringNumericValue

è¯­æ³•åˆ¶å¯¼çš„æ“ä½œ StringNumericValue ä¸æ¥å—ä»»ä½•å‚æ•°ã€‚

>NOTE StringNumericLiteral åˆ° Number å€¼çš„è½¬æ¢æ€»ä½“ä¸Šç±»ä¼¼äº NumericLiteral çš„ NumericValue çš„ç¡®å®šï¼ˆå‚è§ 12.8.3ï¼‰ï¼Œä½†æœ‰äº›ç»†èŠ‚ä¸åŒã€‚

å®ƒåœ¨ä»¥ä¸‹äº§ç”Ÿå¼ä¸Šåˆ†æ®µå®šä¹‰ï¼š

    StringNumericLiteral ::: StrWhiteSpaceopt
        1. Return +0ğ”½.
    StringNumericLiteral ::: StrWhiteSpaceopt StrNumericLiteral StrWhiteSpaceopt
        1. Return StringNumericValue of StrNumericLiteral.
    StrNumericLiteral ::: NonDecimalIntegerLiteral
        1. Return ğ”½(MV of NonDecimalIntegerLiteral).
    StrDecimalLiteral ::: - StrUnsignedDecimalLiteral
        1. Let a be StringNumericValue of StrUnsignedDecimalLiteral.
        2. If a is +0ğ”½, return -0ğ”½.
        3. Return -a.
    StrUnsignedDecimalLiteral ::: Infinity
        1. Return +âˆğ”½.
    StrUnsignedDecimalLiteral ::: DecimalDigits . DecimalDigitsopt ExponentPartopt
        1. Let a be MV of the first DecimalDigits.
        2. If the second DecimalDigits is present, then
            a. Let b be MV of the second DecimalDigits.
            b. Let n be the number of code points in the second DecimalDigits.
        3. Else,
            a. Let b be 0.
            b. Let n be 0.
        4. If ExponentPart is present, let e be MV of ExponentPart. Otherwise, let e be 0.
        5. Return RoundMVResult((a + (b Ã— 10-n)) Ã— 10e).
    StrUnsignedDecimalLiteral ::: . DecimalDigits ExponentPartopt
        1. Let b be MV of DecimalDigits.
        2. If ExponentPart is present, let e be MV of ExponentPart. Otherwise, let e be 0.
        3. Let n be the number of code points in DecimalDigits.
        4. Return RoundMVResult(b Ã— 10e - n).
    StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPartopt
        1. Let a be MV of DecimalDigits.
        2. If ExponentPart is present, let e be MV of ExponentPart. Otherwise, let e be 0.
        3. Return RoundMVResult(a Ã— 10e).

##### 7.1.4.1.3 RoundMVResult ( n )

æŠ½è±¡è¿ç®—RoundMVResultæ¥å—å‚æ•°nï¼ˆä¸€ä¸ªæ•°å­¦å€¼a mathematical valueï¼‰ã€‚å®ƒä»¥å®ç°å®šä¹‰( implementation-defined)çš„æ–¹å¼å°†nè½¬æ¢ä¸ºæ•°å­—ã€‚åœ¨è¿™ä¸ªæŠ½è±¡è¿ç®—ä¸­ï¼Œå¦‚æœä¸€ä¸ªæ•°å­—ä¸æ˜¯é›¶ï¼Œæˆ–è€…å·¦è¾¹æœ‰ä¸€ä¸ªéé›¶æ•°å­—ï¼Œå³è¾¹æœ‰ä¸€ä¸ªéé›¶æ•°å­—ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å­—å°±æ˜¯æœ‰æ•ˆçš„ã€‚åœ¨è¿™ä¸ªæŠ½è±¡è¿ç®—ä¸­ï¼Œâ€œæ•°å­¦å€¼çš„è¡¨ç¤ºå½¢å¼â€è¡¨ç¤ºçš„æ•°å­¦å€¼æ˜¯â€œæ•°å­¦å€¼çš„åè¿›åˆ¶è¡¨ç¤ºå½¢å¼â€çš„å€’æ•°ã€‚å®ƒåœ¨è¢«è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If the decimal representation of n has 20 or fewer significant digits, return ğ”½(n).
2. Let option1 be the mathematical value denoted by the result of replacing each significant digit in the decimal representation of n after the 20th with a 0 digit.
3. Let option2 be the mathematical value denoted by the result of replacing each significant digit in the decimal representation of n after the 20th with a 0 digit and then incrementing it at the 20th position (with carrying as necessary).
4. Let chosen be an implementation-defined choice of either option1 or option2.
5. Return ğ”½(chosen).

### 7.1.5 ToIntegerOrInfinity(argument)

æŠ½è±¡æ“ä½œToIntegerOrInfinityæ¥å—å‚æ•°argumentsã€‚ å®ƒå°†å‚æ•°è½¬æ¢ä¸ºæ•´æ•°ï¼Œ+âˆæˆ–-âˆã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let number be ? ToNumber(argument).
2. If number is NaN, +0ğ”½, or -0ğ”½, return 0.
3. If number is +âˆğ”½, return +âˆ.
4. If number is -âˆğ”½, return -âˆ.
5. Let integer be floor(abs(â„(number))).
6. If number < -0ğ”½, set integer to -integer.
7. Return integer.

### 7.1.6 ToInt32 ( argument )

æŠ½è±¡æ“ä½œToInt32æ¥å—å‚æ•°argumentsã€‚ å®ƒå°†å‚æ•°è½¬æ¢ä¸ºğ”½(-231)åˆ°ğ”½(231-1)(å«)èŒƒå›´å†…çš„232ä¸ªæ•´æ•°å€¼ä¹‹ä¸€ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let number be ? ToNumber(argument).
2. If number is not finite or number is either +0ğ”½ or -0ğ”½, return +0ğ”½.
3. Let int be the mathematical value whose sign is the sign of number and whose magnitude is floor(abs(â„(number))).
4. Let int32bit be int modulo 232.
5. If int32bit â‰¥ 231, return ğ”½(int32bit - 232); otherwise return ğ”½(int32bit).

>NOTE é‰´äºToInt32çš„ä¸Šè¿°å®šä¹‰ï¼š

>ToInt32æŠ½è±¡æ“ä½œæ˜¯å¹‚ç­‰çš„ï¼šå¦‚æœåº”ç”¨äºå®ƒäº§ç”Ÿçš„ç»“æœï¼Œç¬¬äºŒä¸ªåº”ç”¨ç¨‹åºå°†ä½¿è¯¥å€¼ä¿æŒä¸å˜ã€‚

>å¯¹äºxçš„æ‰€æœ‰å€¼ï¼ŒToInt32(ToUint32(x))ä¸ToInt32(x)çš„å€¼ç›¸åŒã€‚ (è¦ä¿ç•™åä¸€ä¸ªå±æ€§ï¼Œå°†+âˆğ”½å’Œ-âˆğ”½æ˜ å°„åˆ°+0ğ”½ã€‚)

>ToInt32å°†-0ğ”½æ˜ å°„åˆ°+0ğ”½ã€‚


### 7.1.7 ToUint32 ( argument )

æŠ½è±¡æ“ä½œToUint32æ¥å—å‚æ•°argumentsã€‚ å®ƒå°†å‚æ•°è½¬æ¢ä¸º2<sup>32</sup>æ•´æ•°å€¼ä¹‹ä¸€ï¼ŒèŒƒå›´ä¸º+0ğ”½åˆ°ğ”½(2<sup>32</sup>-1)(å«)ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let number be ? ToNumber(argument).
2. If number is not finite or number is either +0ğ”½ or -0ğ”½, return +0ğ”½.
3. Let int be the mathematical value whose sign is the sign of number and whose magnitude is floor(abs(â„(number))).
4. Let int32bit be int modulo 232.
5. Return ğ”½(int32bit).

>NOTE é‰´äºToUint32çš„ä¸Šè¿°å®šä¹‰ï¼š

>ç¬¬ 5 æ­¥æ˜¯ ToUint32 å’Œ ToInt32 ä¹‹é—´çš„å”¯ä¸€åŒºåˆ«ã€‚
>ToUint32 æŠ½è±¡æ“ä½œæ˜¯å¹‚ç­‰çš„ï¼šå¦‚æœåº”ç”¨äºå®ƒäº§ç”Ÿçš„ç»“æœï¼Œç¬¬äºŒä¸ªåº”ç”¨ç¨‹åºä¿æŒè¯¥å€¼ä¸å˜ã€‚ 
ToUint32(ToInt32(x)) is the same value as ToUint32(x) for all values of x. (It is to preserve this latter property that +âˆğ”½ and -âˆğ”½ are mapped to +0ğ”½.)
ToUint32 maps -0ğ”½ to +0ğ”½.

### 7.1.8 ToInt16 ( argument )

int16çš„æŠ½è±¡æ“ä½œé‡‡ç”¨å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸ºğ”½ï¼ˆ-215ï¼‰åˆ°ğ”½ï¼ˆ215-1ï¼‰èŒƒå›´å†…çš„216ä¸ªæ•´æ•°å€¼ä¹‹ä¸€ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let number be ? ToNumber(argument).
2. If number is not finite or number is either +0ğ”½ or -0ğ”½, return +0ğ”½.
3. Let int be the mathematical value whose sign is the sign of number and whose magnitude is floor(abs(â„(number))).
4. Let int16bit be int modulo 216.
5. If int16bit â‰¥ 215, return ğ”½(int16bit - 216); otherwise return ğ”½(int16bit).

### 7.1.9 ToUint16 ( argument )

æŠ½è±¡æ“ä½œToUint16æ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸ºèŒƒå›´ä»+0ğ”½åˆ°ğ”½ï¼ˆ216-1ï¼‰çš„216ä¸ªæ•´æ•°å€¼ä¹‹ä¸€ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let number be ? ToNumber(argument).
2. If number is not finite or number is either +0ğ”½ or -0ğ”½, return +0ğ”½.
3. Let int be the mathematical value whose sign is the sign of number and whose magnitude is floor(abs(â„(number))).
4. Let int16bit be int modulo 216.
5. Return ğ”½(int16bit).

>NOTE æ ¹æ®ä¸Šè¿°å®šä¹‰ï¼šåœ¨æ­¥éª¤4ä¸­ç”¨216æ›¿æ¢232æ˜¯ToUint32å’ŒToUint16ä¹‹é—´çš„å”¯ä¸€åŒºåˆ«ã€‚
ToUint16æ˜ å°„-0ğ”½åˆ°+0ğ”½ã€‚


### 7.1.10 ToInt8 ( argument )

int8çš„æŠ½è±¡æ“ä½œæ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸º-128ğ”½åˆ°127ğ”½èŒƒå›´å†…çš„28ä¸ªæ•´æ•°å€¼ä¹‹ä¸€ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š


1. Let number be ? ToNumber(argument).
2. If number is not finite or number is either +0ğ”½ or -0ğ”½, return +0ğ”½.
3. Let int be the mathematical value whose sign is the sign of number and whose magnitude is floor(abs(â„(number))).
4. Let int8bit be int modulo 28.
5. If int8bit â‰¥ 27, return ğ”½(int8bit - 28); otherwise return ğ”½(int8bit).


### 7.1.11 ToUint8 ( argument )

æŠ½è±¡æ“ä½œToUint8æ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸º28ä¸ªæ•´æ•°å€¼ä¹‹ä¸€ï¼ŒèŒƒå›´ä»+0ğ”½åˆ°255ğ”½ï¼ˆå«ï¼‰ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let number be ? ToNumber(argument).
2. If number is not finite or number is either +0ğ”½ or -0ğ”½, return +0ğ”½.
3. Let int be the mathematical value whose sign is the sign of number and whose magnitude is floor(abs(â„(number))).
4. Let int8bit be int modulo 28.
5. Return ğ”½(int8bit).

### 7.1.12 ToUint8Clamp ( argument )

æŠ½è±¡æ“ä½œToUint8Clampæ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸º28ä¸ªæ•´æ•°å€¼ä¹‹ä¸€ï¼ŒèŒƒå›´ä»+0ğ”½åˆ°255ğ”½ï¼ˆå«ï¼‰ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let number be ? ToNumber(argument).
2. If number is NaN, return +0ğ”½.
3. If â„(number) â‰¤ 0, return +0ğ”½.
4. If â„(number) â‰¥ 255, return 255ğ”½.
5. Let f be floor(â„(number)).
6. If f + 0.5 < â„(number), return ğ”½(f + 1).
7. If â„(number) < f + 0.5, return ğ”½(f).
8. If f is odd, return ğ”½(f + 1).
9. Return ğ”½(f).

>NOTE ä¸å…¶ä»–ECMAScriptæ•´æ•°è½¬æ¢æŠ½è±¡æ“ä½œä¸åŒï¼ŒToUint8Clampå–æ•´è€Œä¸æ˜¯æˆªæ–­éæ•´æ•°å€¼ï¼Œå¹¶ä¸”ä¸ä¼šå°†+âˆğ”½è½¬æ¢ä¸º+0ğ”½ã€‚ToUint8Clampåšâ€œå››èˆäº”å…¥â€çš„å¹³å±€ã€‚è¿™ä¸æ•°å­¦.åœ†å½¢å®ƒèƒ½ä½¿å¹³å±€â€œå››èˆäº”å…¥â€ã€‚

### 7.1.13 ToBigInt ( argument )

æŠ½è±¡æ“ä½œToBigIntæ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸ºBigIntå€¼ï¼Œæˆ–è€…åœ¨éœ€è¦ä»Numberéšå¼è½¬æ¢æ—¶æŠ›å‡ºã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let prim be ? ToPrimitive(argument, number).
2. Return the value that prim corresponds to in Table 12.

<center>Table 12: BigInt Conversions</center>

|Argument Type	    |Result|
|----|----|
Undefined	        |Throw a TypeError exception.
Null	            |Throw a TypeError exception.
Boolean	            |Return 1n if prim is true and 0n if prim is false.
BigInt	            |Return prim.
Number	            |Throw a TypeError exception.
String	            |1.Let n be ! StringToBigInt(prim). 2.If n is NaN, throw a SyntaxError exception.  3.Return n.
Symbol	            |Throw a TypeError exception.

### 7.1.14 StringToBigInt ( argument )

æŠ½è±¡æ“ä½œStringToBigIntæ¥å—å‚æ•°strï¼ˆå­—ç¬¦ä¸²ï¼‰å¹¶è¿”å›BigIntæˆ–undefinedã€‚è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let text be StringToCodePoints(str).
2. Let literal be ParseText(text, StringIntegerLiteral).
3. If literal is a List of errors, return undefined.
4. Let mv be the MV of literal.
5. Assert: mv is an integer.
6. Return â„¤(mv).

#### 7.1.14.1 StringIntegerLiteral Grammar

StringToBigIntä½¿ç”¨ä»¥ä¸‹è¯­æ³•ã€‚

Syntax

    StringIntegerLiteral :::
        StrWhiteSpaceopt
        StrWhiteSpaceopt StrIntegerLiteral StrWhiteSpaceopt
    StrIntegerLiteral :::
        SignedInteger[~Sep]
        NonDecimalIntegerLiteral[~Sep]

#### 7.1.14.2 Runtime Semantics: MV

- The MV of StringIntegerLiteral ::: StrWhiteSpaceopt is 0.
- The MV of StringIntegerLiteral ::: StrWhiteSpaceopt StrIntegerLiteral StrWhiteSpaceopt is the MV of StrIntegerLiteral.

### 7.1.15 ToBigInt64 ( argument )

æŠ½è±¡æ“ä½œToBigInt64æ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸ºèŒƒå›´ä¸ºâ„¤ï¼ˆ-263ï¼‰åˆ°â„¤ï¼ˆ263-1ï¼‰çš„264ä¸ªBigIntå€¼ä¹‹ä¸€ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let n be ? ToBigInt(argument).
2. Let int64bit be â„(n) modulo 264.
3. If int64bit â‰¥ 263, return â„¤(int64bit - 264); otherwise return â„¤(int64bit).

### 7.1.17 ToString(argument)

æŠ½è±¡æ“ä½œToStringæ¥å—å‚æ•°argumentsã€‚ æ ¹æ®è¡¨14å°†å‚æ•°è½¬æ¢ä¸ºStringç±»å‹çš„å€¼ï¼š

1. If argument is a String, return argument.
2. If argument is a Symbol, throw a TypeError exception.
3. If argument is undefined, return "undefined".
4. If argument is null, return "null".
5. If argument is true, return "true".
6. If argument is false, return "false".
7. If argument is a Number, return Number::toString(argument, 10).
8. If argument is a BigInt, return BigInt::toString(argument, 10).
9. Assert: argument is an Object.
10. Let primValue be ? ToPrimitive(argument, string).
11. Assert: primValue is not an Object.
12. Return ? ToString(primValue).

### 7.1.18 ToObject ( argument )

ToObjectçš„æŠ½è±¡æ“ä½œæ¥å—å‚æ•°å‚æ•°ã€‚å®ƒæ ¹æ®è¡¨13å°†å‚æ•°è½¬æ¢ä¸ºObjectç±»å‹çš„å€¼ï¼š

Table 13: ToObject Conversions

|Argument Type|	Result|
|----|----|
Undefined	|å¼•å‘TypeErrorå¼‚å¸¸ã€‚
Null        |å¼•å‘TypeErrorå¼‚å¸¸ã€‚
Boolean     |è¿”å›ä¸€ä¸ªæ–°çš„å¸ƒå°”å¯¹è±¡ï¼Œå…¶[[BooleanData]]å†…éƒ¨æ§½è®¾ç½®ä¸ºå‚æ•°ã€‚æœ‰å…³å¸ƒå°”å¯¹è±¡çš„æè¿°ï¼Œè¯·å‚è§20.3
Number      |è¿”å›ä¸€ä¸ªæ–°çš„Numberå¯¹è±¡ï¼Œå…¶[[NumberData]]å†…éƒ¨æ§½è®¾ç½®ä¸ºargumentã€‚æœ‰å…³æ•°å­—å¯¹è±¡çš„è¯´æ˜ï¼Œè¯·å‚è§21.1ã€‚
String      |è¿”å›ä¸€ä¸ªæ–°çš„Stringå¯¹è±¡ï¼Œå…¶[[StringData]]å†…éƒ¨æ§½è®¾ç½®ä¸ºargumentã€‚æœ‰å…³å­—ç¬¦ä¸²å¯¹è±¡çš„æè¿°ï¼Œè¯·å‚è§22.1ã€‚
Symbol      |è¿”å›ä¸€ä¸ªæ–°çš„Symbolå¯¹è±¡ï¼Œå…¶[[SymbolData]]å†…éƒ¨æ§½è®¾ç½®ä¸ºå‚æ•°ã€‚ç¬¦å·å¯¹è±¡çš„è¯´æ˜è§20.4ã€‚
BigInt      |è¿”å›ä¸€ä¸ªæ–°çš„BigIntå¯¹è±¡ï¼Œå…¶[[BigIntData]]å†…éƒ¨æ§½è®¾ç½®ä¸ºargumentã€‚æœ‰å…³BigIntå¯¹è±¡çš„æè¿°ï¼Œè¯·å‚è§21.2ã€‚	
Object      |è¿”å›argument.

### 7.1.19 ToPropertyKey(å‚æ•°)

æŠ½è±¡æ“ä½œToPropertyKeyæ¥å—å‚æ•°argumentsã€‚ å®ƒå°†å‚æ•°è½¬æ¢ä¸ºå¯ä»¥ç”¨ä½œå±æ€§é”®çš„å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let key be ? ToPrimitive(argument, string).
2. If key is a Symbol, then
    - Return key.
3. Return ! ToString(key).

### 7.1.20 ToLength ( argument )

ToLengthçš„æŠ½è±¡æ“ä½œæ¥å—å‚æ•°å‚æ•°ã€‚å®ƒå°†å‚æ•°è½¬æ¢ä¸ºé€‚åˆç”¨ä½œç±»ä¼¼æ•°ç»„å¯¹è±¡é•¿åº¦çš„æ•´æ•°ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let len be ? ToIntegerOrInfinity(argument).
2. If len â‰¤ 0, return +0ğ”½.
3. Return ğ”½(min(len, 2<sup>53</sup> - 1)).

### 7.1.21 CanonicalNumericIndexString ( argument )

æŠ½è±¡æ“ä½œCanonicalNumericIndexStringæ¥å—å‚æ•°å‚æ•°ã€‚å¦‚æœå®ƒæ˜¯ToStringæˆ–å­—ç¬¦ä¸²â€œ-0â€ç”Ÿæˆçš„æ•°å­—çš„å­—ç¬¦ä¸²è¡¨ç¤ºå½¢å¼ï¼Œåˆ™è¿”å›è½¬æ¢ä¸ºæ•°å­—å€¼çš„å‚æ•°ã€‚å¦åˆ™ï¼Œè¿”å›æœªå®šä¹‰ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If argument is "-0", return -0ğ”½.
2. Let n be ! ToNumber(argument).
3. If SameValue(! ToString(n), argument) is true, return n.
4. Return undefined.

```
å¦‚æœä¸€ä¸ªå€¼è½¬æ¢ä¸ºæ•°å­—ç±»å‹åå†è½¬æ¢ä¸ºå­—ç¬¦ä¸²ç±»å‹ä¸æœªè½¬æ¢ä¹‹å‰ç›¸åŒï¼Œé‚£ä¹ˆä»–å°±æ˜¯ä¸ªè§„èŒƒå­—ç¬¦ä¸²(01===1ï¼Œä¹Ÿæ˜¯è§„èŒƒå­—ç¬¦ä¸²)
```
è§„èŒƒæ•°å­—å­—ç¬¦ä¸²æ˜¯CanonicalNumericIndexStringæŠ½è±¡æ“ä½œä¸ä¼šè¿”å›undefinedçš„ä»»ä½•Stringå€¼ã€‚

### 7.1.22 ToIndex ( value )

æŠ½è±¡æ“ä½œToIndexæ¥å—å‚æ•°å€¼ã€‚ å¦‚æœå®ƒæ˜¯æœ‰æ•ˆçš„æ•´æ•°ç´¢å¼•å€¼ï¼Œåˆ™è¿”å›è½¬æ¢ä¸ºéè´Ÿæ•´æ•°çš„valueå‚æ•°ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If value is undefined, then
    - Return 0.
2. Else,
    - Let integer be ? ToIntegerOrInfinity(value).
    - Let clamped be ! ToLength(ğ”½(integer)).
    - If SameValue(ğ”½(integer), clamped) is false, throw a RangeError exception.
    - Assert: 0 â‰¤ integer â‰¤ 253 - 1.
    - Return integer.


