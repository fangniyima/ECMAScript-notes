### 7.2.1 RequireObjectCoercible ( argument )
æŠ½è±¡æ“ä½œRequireObjectCoercibleé‡‡ç”¨å‚æ•°argumentsã€‚ å¦‚æœå‚æ•°æ˜¯æ— æ³•ä½¿ç”¨ToObjectè½¬æ¢ä¸ºObjectçš„å€¼ï¼Œåˆ™ä¼šå¼•å‘é”™è¯¯ã€‚ ç”±è¡¨16å®šä¹‰ï¼š

|Argument Type      |Result|
|----               |----|
Undefined	        |Throw a TypeError exception.
Null	            |Throw a TypeError exception.
Boolean             |Return argument.
Number              |Return argument.
String	            |Return argument.
Symbol              |Return argument.
BigInt              |Return argument.
Object              |Return argument.

### 7.2.2 IsArrayï¼ˆå‚æ•°ï¼‰
æŠ½è±¡æ“ä½œIsArrayé‡‡ç”¨å‚æ•°argumentsã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.If Type(argument) is not Object, return false.
    2.If argument is an Array exotic object, return true.
    3.If argument is a Proxy exotic object, then
        If argument.[[ProxyHandler]] is null, throw a TypeError exception.
        Let target be argument.[[ProxyTarget]].
        Return ? IsArray(target).
    4.Return false.

### 7.2.3 IsCallableï¼ˆå‚æ•°ï¼‰
æŠ½è±¡æ“ä½œIsCallableé‡‡ç”¨å‚æ•°å½¢å‚ï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ã€‚ å®ƒä½¿ç”¨[[Call]]å†…éƒ¨æ–¹æ³•ç¡®å®šå‚æ•°æ˜¯å¦ä¸ºå¯è°ƒç”¨å‡½æ•°ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    If Type(argument) is not Object, return false.
    If argument has a [[Call]] internal method, return true.
    Return false.

### 7.2.4 IsConstructorï¼ˆå‚æ•°ï¼‰
æŠ½è±¡æ“ä½œIsConstructoræ¥å—å‚æ•°å®å‚ï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ã€‚ å®ƒä½¿ç”¨å†…éƒ¨æ–¹æ³•[[Construct]]ç¡®å®šå‚æ•°æ˜¯å¦ä¸ºå‡½æ•°å¯¹è±¡ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š    

    If Type(argument) is not Object, return false.
    If argument has a [[Construct]] internal method, return true.
    Return false.

    è¯´æ˜ï¼š
    function a(){}
    a.prototype.constructor       //Æ’ a(){}
    var obj = {b(){console.log(1)}}
    obj.b.prototype.constructor     //

### 7.2.5 IsExtensible ( O )

æŠ½è±¡æ“ä½œIsExtensibleæ¥å—å‚æ•°Oï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰å¹¶è¿”å›ä¸€ä¸ªå®Œæˆè®°å½•ï¼Œå¦‚æœå®ƒçš„[[Type]]æ˜¯æ­£å¸¸çš„ï¼Œé‚£ä¹ˆå®ƒçš„[[Value]]æ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ã€‚å®ƒç”¨äºç¡®å®šæ˜¯å¦å¯ä»¥å°†å…¶ä»–å±æ€§æ·»åŠ åˆ°Oä¸­ã€‚å½“è°ƒç”¨æ—¶ï¼Œå®ƒæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Assert: Type(O) is Object.
    Return ? O.[[IsExtensible]]().

### 7.2.6 IsIntegralNumber ( argument )
æŠ½è±¡æ“ä½œIsIntegralNumberé‡‡ç”¨å‚æ•°argumentsã€‚ å®ƒç¡®å®šå‚æ•°æ˜¯å¦ä¸ºæœ‰é™æ•´æ•°ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.If Type(argument) is not Number, return false.
    2.If argument is NaN, +âˆğ”½, or -âˆğ”½, return false.
    3.If floor(abs(â„(argument))) â‰  abs(â„(argument)), return false.
    4.Return true.

### 7.2.7 IsPropertyKeyï¼ˆ argument ï¼‰
æŠ½è±¡æ“ä½œIsPropertyKeyé‡‡ç”¨å‚æ•°å½¢å‚ï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ã€‚ å®ƒç¡®å®šå‚æ•°æ˜¯å¦ä¸ºå¯ä»¥ç”¨ä½œå±æ€§é”®çš„å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    If Type(argument) is String, return true.
    If Type(argument) is Symbol, return true.
    Return false.

### 7.2.8 IsRegExpï¼ˆ argument ï¼‰
æŠ½è±¡æ“ä½œIsRegExpé‡‡ç”¨å‚æ•°argumentsã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.If Type(argument) is not Object, return false.
    2.Let matcher be ? Get(argument, @@match).
    3.If matcher is not undefined, return ! ToBoolean(matcher).
    4.If argument has a [[RegExpMatcher]] internal slot, return true.
    5.Return false.

### 7.2.9 IsStringPrefixï¼ˆpï¼Œqï¼‰

æŠ½è±¡æ“ä½œIsStringPrefixæ¥å—å‚æ•°pï¼ˆå­—ç¬¦ä¸²ï¼‰å’Œqï¼ˆå­—ç¬¦ä¸²ï¼‰ã€‚å®ƒç¡®å®špæ˜¯å¦æ˜¯qçš„å‰ç¼€ã€‚è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Assert: Type(p) is String.
    Assert: Type(q) is String.
    If q can be the string-concatenation of p and some other String r, return true. Otherwise, return false.

æ³¨æ„

ä»»ä½•å­—ç¬¦ä¸²éƒ½æ˜¯å…¶è‡ªèº«çš„å‰ç¼€ï¼Œå› ä¸ºrå¯èƒ½æ˜¯ç©ºå­—ç¬¦ä¸²ã€‚

### 7.2.10 SameValueï¼ˆxï¼Œyï¼‰

æŠ½è±¡æ“ä½œSameValueæ¥å—å‚æ•°xï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’Œyï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ï¼Œå¹¶è¿”å›ä¸€ä¸ªå®Œæˆè®°å½•ï¼Œè¯¥è®°å½•çš„[[Type]]ä¸ºæ­£å¸¸å€¼ï¼Œ[[value]]ä¸ºå¸ƒå°”å€¼ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    If Type(x) is different from Type(y), return false.
    If Type(x) is Number or BigInt, then
      Return ! Type(x)::sameValue(x, y).
    Return ! SameValueNonNumeric(x, y).
    
æ³¨æ„

è¯¥ç®—æ³•ä¸åŒäºä¸¥æ ¼ç­‰å¼æ¯”è¾ƒç®—æ³•åœ¨å¤„ç†æœ‰ç¬¦å·é›¶å’Œnanä¸Šçš„ä¸åŒã€‚

### 7.2.11 SameValueZeroï¼ˆxï¼Œyï¼‰
æŠ½è±¡æ“ä½œSameValueZeroæ¥å—å‚æ•°xï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’Œyï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ï¼Œå¹¶è¿”å›å…¶[[Type]]æ­£å¸¸ä¸”[[Value]]æ˜¯å¸ƒå°”å€¼çš„å®Œæˆè®°å½•ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    If Type(x) is different from Type(y), return false.
    If Type(x) is Number or BigInt, then
    Return ! Type(x)::sameValueZero(x, y).
    Return ! SameValueNonNumeric(x, y).

æ³¨æ„

SameValueZeroä¸SameValueçš„åŒºåˆ«ä»…åœ¨äºå…¶å¤„ç†+0ğ”½å’Œ-0ğ”½ã€‚

### 7.2.12 SameValueNonNumericï¼ˆxï¼Œyï¼‰
æŠ½è±¡æ“ä½œSameValueNonNumericæ¥å—å‚æ•°xï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’Œyï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ï¼Œå¹¶è¿”å›å…¶[[Type]]ä¸ºæ­£å¸¸ä¸”[[Value]]ä¸ºå¸ƒå°”å€¼çš„å®Œæˆè®°å½•ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: Type(x) is not Number or BigInt.
    2.Assert: Type(x) is the same as Type(y).
    3.If Type(x) is Undefined, return true.
    4.If Type(x) is Null, return true.
    5.If Type(x) is String, then
        If x and y are exactly the same sequence of code units (same length and same code units at corresponding indices), return true; otherwise, return false.
    6.If Type(x) is Boolean, then
        If x and y are both true or both false, return true; otherwise, return false.
    7.If Type(x) is Symbol, then
        If x and y are both the same Symbol value, return true; otherwise, return false.
    8.If x and y are the same Object value, return true. Otherwise, return false.

### 7.2.13æŠ½è±¡å…³ç³»æ¯”è¾ƒ

æ¯”è¾ƒx < yï¼Œå…¶ä¸­xå’Œyæ˜¯å€¼ï¼Œäº§ç”Ÿtrueã€falseæˆ–undefinedï¼ˆè¿™è¡¨ç¤ºè‡³å°‘æœ‰ä¸€ä¸ªæ“ä½œæ•°æ˜¯NaNï¼‰ã€‚é™¤äº†xå’Œyä¹‹å¤–ï¼Œè¯¥ç®—æ³•è¿˜ä½¿ç”¨ä¸€ä¸ªåä¸ºLeftFirstçš„å¸ƒå°”æ ‡å¿—ä½œä¸ºå‚æ•°ã€‚æ­¤æ ‡å¿—ç”¨äºæ§åˆ¶å¯¹xå’Œyæ‰§è¡Œå…·æœ‰æ½œåœ¨å¯è§å‰¯ä½œç”¨çš„æ“ä½œçš„é¡ºåºã€‚è¿™æ˜¯å¿…éœ€çš„ï¼Œå› ä¸ºECMAScriptæŒ‡å®šä»å·¦åˆ°å³è®¡ç®—è¡¨è¾¾å¼ã€‚LeftFirstçš„é»˜è®¤å€¼ä¸ºtrueï¼Œè¡¨ç¤ºxå‚æ•°å¯¹åº”äºyå‚æ•°å¯¹åº”è¡¨è¾¾å¼å·¦ä¾§çš„è¡¨è¾¾å¼ã€‚å¦‚æœLeftFirstä¸ºfalseï¼Œåˆ™æƒ…å†µç›¸åï¼Œå¿…é¡»åœ¨xä¹‹å‰å¯¹yæ‰§è¡Œæ“ä½œã€‚è¿™æ ·çš„æ¯”è¾ƒå¦‚ä¸‹ï¼š

    If the LeftFirst flag is true, then
    Let px be ? ToPrimitive(x, number).
    Let py be ? ToPrimitive(y, number).
    Else,
    NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.
    Let py be ? ToPrimitive(y, number).
    Let px be ? ToPrimitive(x, number).
    If Type(px) is String and Type(py) is String, then
    If IsStringPrefix(py, px) is true, return false.
    If IsStringPrefix(px, py) is true, return true.
    Let k be the smallest non-negative integer such that the code unit at index k within px is different from the code unit at index k within py. (There must be such a k, for neither String is a prefix of the other.)
    Let m be the integer that is the numeric value of the code unit at index k within px.
    Let n be the integer that is the numeric value of the code unit at index k within py.
    If m < n, return true. Otherwise, return false.
    Else,
    If Type(px) is BigInt and Type(py) is String, then
    Let ny be ! StringToBigInt(py).
    If ny is NaN, return undefined.
    Return BigInt::lessThan(px, ny).
    If Type(px) is String and Type(py) is BigInt, then
    Let nx be ! StringToBigInt(px).
    If nx is NaN, return undefined.
    Return BigInt::lessThan(nx, py).
    NOTE: Because px and py are primitive values, evaluation order is not important.
    Let nx be ! ToNumeric(px).
    Let ny be ! ToNumeric(py).
    If Type(nx) is the same as Type(ny), return Type(nx)::lessThan(nx, ny).
    Assert: Type(nx) is BigInt and Type(ny) is Number, or Type(nx) is Number and Type(ny) is BigInt.
    If nx or ny is NaN, return undefined.
    If nx is -âˆğ”½ or ny is +âˆğ”½, return true.
    If nx is +âˆğ”½ or ny is -âˆğ”½, return false.
    If â„(nx) < â„(ny), return true; otherwise return false.

é™„æ³¨1

æ­¥éª¤3ä¸æ­¥éª¤1.cçš„ä¸åŒä¹‹å¤„åœ¨äºï¼Œåœ¨å¤„ç†åŠ æ³•è¿ç®—ç¬¦+ï¼ˆ12.15.5ï¼‰çš„ç®—æ³•ä¸­ï¼Œä½¿ç”¨é€»è¾‘andè¿ç®—è€Œä¸æ˜¯é€»è¾‘orè¿ç®—ã€‚

é™„æ³¨2

å­—ç¬¦ä¸²çš„æ¯”è¾ƒå¯¹ä»£ç å•å…ƒå€¼åºåˆ—ä½¿ç”¨äº†ä¸€ä¸ªç®€å•çš„å­—å…¸åºã€‚æ²¡æœ‰äººè¯•å›¾ä½¿ç”¨Unicodeè§„èŒƒä¸­å®šä¹‰çš„æ›´å¤æ‚ã€é¢å‘è¯­ä¹‰çš„å­—ç¬¦æˆ–å­—ç¬¦ä¸²ç›¸ç­‰æ€§å’Œæ’åºé¡ºåºçš„å®šä¹‰ã€‚å› æ­¤ï¼Œæ ¹æ®Unicodeæ ‡å‡†è§„èŒƒç›¸ç­‰çš„å­—ç¬¦ä¸²å€¼å¯èƒ½æµ‹è¯•ä¸ºä¸ç›¸ç­‰ã€‚å®é™…ä¸Šï¼Œè¿™ä¸ªç®—æ³•å‡è®¾ä¸¤ä¸ªå­—ç¬¦ä¸²éƒ½å·²ç»æ˜¯è§„èŒƒåŒ–çš„å½¢å¼ã€‚å¦å¤–ï¼Œè¯·æ³¨æ„ï¼Œå¯¹äºåŒ…å«è¡¥å……å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼ŒUTF-16ä»£ç å•å…ƒå€¼åºåˆ—çš„å­—å…¸åºé¡ºåºä¸ä»£ç ç‚¹å€¼åºåˆ—çš„å­—å…¸åºé¡ºåºä¸åŒã€‚


### 7.2.14 Abstract Equality Comparison

æ¯”è¾ƒx==yï¼Œå…¶ä¸­xå’Œyæ˜¯å€¼ï¼Œäº§ç”Ÿtrueæˆ–falseã€‚è¿™æ ·çš„æ¯”è¾ƒå¦‚ä¸‹ï¼š

    If Type(x) is the same as Type(y), then
    Return the result of performing Strict Equality Comparison x === y.
    If x is null and y is undefined, return true.
    If x is undefined and y is null, return true.
    NOTE: This step is replaced in section B.3.7.2.
    If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y).
    If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y.
    If Type(x) is BigInt and Type(y) is String, then
    Let n be ! StringToBigInt(y).
    If n is NaN, return false.
    Return the result of the comparison x == n.
    If Type(x) is String and Type(y) is BigInt, return the result of the comparison y == x.
    If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y.
    If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y).
    If Type(x) is either String, Number, BigInt, or Symbol and Type(y) is Object, return the result of the comparison x == ? ToPrimitive(y).
    If Type(x) is Object and Type(y) is either String, Number, BigInt, or Symbol, return the result of the comparison ? ToPrimitive(x) == y.
    If Type(x) is BigInt and Type(y) is Number, or if Type(x) is Number and Type(y) is BigInt, then
    If x or y are any of NaN, +âˆğ”½, or -âˆğ”½, return false.
    If â„(x) = â„(y), return true; otherwise return false.
    Return false.

### 7.2.15 Strict Equality Comparison

æ¯”è¾ƒx===yï¼Œå…¶ä¸­xå’Œyæ˜¯å€¼ï¼Œäº§ç”Ÿtrueæˆ–falseã€‚è¿™æ ·çš„æ¯”è¾ƒå¦‚ä¸‹ï¼š

    If Type(x) is different from Type(y), return false.
    If Type(x) is Number or BigInt, then
    Return ! Type(x)::equal(x, y).
    Return ! SameValueNonNumeric(x, y).

æ³¨æ„
è¯¥ç®—æ³•ä¸SameValueï¼ˆåŒå€¼ç®—æ³•ï¼‰çš„åŒºåˆ«åœ¨äºå¯¹æœ‰ç¬¦å·é›¶å’ŒNaNçš„å¤„ç†ã€‚
