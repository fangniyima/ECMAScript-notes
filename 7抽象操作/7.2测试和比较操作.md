### 7.2.1 RequireObjectCoercible ( argument )

æŠ½è±¡æ“ä½œ RequireObjectCoercible æ¥å—å‚æ•°å‚æ•°ï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å¹¶è¿”å›åŒ…å« ECMAScript è¯­è¨€å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å¦‚æœå‚æ•°æ˜¯æ— æ³•ä½¿ç”¨ ToObject è½¬æ¢ä¸ºå¯¹è±¡çš„å€¼ï¼Œåˆ™ä¼šå¼•å‘é”™è¯¯ã€‚ å®ƒç”±è¡¨ 14 å®šä¹‰ï¼š

|Argument Type      |Result|
|----               |----|
Undefined	        |Throw a TypeError exception.
Null	            |Throw a TypeError exception.
Boolean             |Return argument.
Number              |Return argument.
String	            |Return argument.
Symbol              |Return argument.
BigInt              |Return argument.
Object              |Return argument.

### 7.2.2 IsArrayï¼ˆargumentï¼‰

æŠ½è±¡æ“ä½œ IsArray æ¥å—å‚æ•°å‚æ•°ï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If argument is not an Object, return false.
2. If argument is an Array exotic object, return true.
3. If argument is a Proxy exotic object, then
    - If argument.[[ProxyHandler]] is null, throw a TypeError exception.
    - Let target be argument.[[ProxyTarget]].
    - Return ? IsArray(target).
4. Return false.

>å†™è€…æ³¨:proxyä¼šæ£€æµ‹ä»£ç†ç›®æ ‡ï¼Œä½†ä¸ä¼šæ£€æµ‹realm

### 7.2.3 IsCallableï¼ˆ argumentï¼‰

æŠ½è±¡æ“ä½œIsCallableé‡‡ç”¨å‚æ•° argumentï¼ˆan ECMAScript language value)ï¼‰ã€‚ å®ƒä½¿ç”¨[[Call]]å†…éƒ¨æ–¹æ³•ç¡®å®šå‚æ•°æ˜¯å¦ä¸ºå¯è°ƒç”¨å‡½æ•°ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If argument is not an Object, return false.
2. If argument has a [[Call]] internal method, return true.
3. Return false.

### 7.2.4 IsConstructorï¼ˆargument ï¼‰

æŠ½è±¡æ“ä½œIsConstructoræ¥å—å‚æ•°argument ï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ã€‚ å®ƒä½¿ç”¨å†…éƒ¨æ–¹æ³•[[Construct]]ç¡®å®šå‚æ•°æ˜¯å¦ä¸ºå‡½æ•°å¯¹è±¡ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š    

1. If argument is not an Object, return false.
2. If argument has a [[Construct]] internal method, return true.
3. Return false.

    è¯´æ˜ï¼š
    function a(){}
    a.prototype.constructor       //Æ’ a(){}
    var obj = {b(){console.log(1)}}
    obj.b.prototype.constructor   //ä½œä¸ºæ–¹æ³•çš„å‡½æ•°æ²¡æœ‰åŸå‹

### 7.2.5 IsExtensible ( O )

æŠ½è±¡æ“ä½œIsExtensibleæ¥å—å‚æ•°Oï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰å¹¶è¿”å›ä¸€ä¸ªå®Œæˆè®°å½•ï¼Œå¦‚æœå®ƒçš„[[Type]]æ˜¯æ­£å¸¸çš„ï¼Œé‚£ä¹ˆå®ƒçš„[[Value]]æ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ã€‚å®ƒç”¨äºç¡®å®šæ˜¯å¦å¯ä»¥å°†å…¶ä»–å±æ€§æ·»åŠ åˆ°Oä¸­ã€‚å½“è°ƒç”¨æ—¶ï¼Œå®ƒæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Return ? O.[[IsExtensible]]().

### 7.2.6 IsIntegralNumber ( argument )

æŠ½è±¡æ“ä½œIsIntegralNumberé‡‡ç”¨å‚æ•°argumentsã€‚ å®ƒç¡®å®šå‚æ•°æ˜¯å¦ä¸ºæœ‰é™æ•´æ•°ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If argument is not a Number, return false.
2. If argument is not finite, return false.
3. If floor(abs(â„(argument))) â‰  abs(â„(argument)), return false.
4. Return true.

### 7.2.7 IsPropertyKeyï¼ˆ argument ï¼‰

æŠ½è±¡æ“ä½œIsPropertyKeyé‡‡ç”¨å‚æ•°å½¢å‚ï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ã€‚ å®ƒç¡®å®šå‚æ•°æ˜¯å¦ä¸ºå¯ä»¥ç”¨ä½œå±æ€§é”®çš„å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If argument is a String, return true.
2. If argument is a Symbol, return true.
3. Return false.

### 7.2.8 IsRegExpï¼ˆ argument ï¼‰

æŠ½è±¡æ“ä½œIsRegExpé‡‡ç”¨å‚æ•°argumentsã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If argument is not an Object, return false.
2. Let matcher be ? Get(argument, @@match).
3. If matcher is not undefined, return ToBoolean(matcher).
4. If argument has a [[RegExpMatcher]] internal slot, return true.
5. Return false.

### 7.2.9 SS: IsStringWellFormedUnicode ( string )

æŠ½è±¡æ“ä½œ IsStringWellFormedUnicode é‡‡ç”¨å‚æ•°string ï¼ˆa Stringï¼‰ã€‚ å®ƒå°†å­—ç¬¦ä¸²è§£é‡Šä¸º UTF-16 ç¼–ç çš„ä»£ç ç‚¹åºåˆ—ï¼Œå¦‚ 6.1.4 ä¸­æ‰€è¿°ï¼Œå¹¶ç¡®å®šå®ƒæ˜¯å¦æ˜¯æ ¼å¼è‰¯å¥½çš„ UTF-16 åºåˆ—ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let strLen be the length of string.
2. Let k be 0.
3. Repeat, while k â‰  strLen,
    - Let cp be CodePointAt(string, k).
    - If cp.[[IsUnpairedSurrogate]] is true, return false.
    - Set k to k + cp.[[CodeUnitCount]].
4. Return true.

### 7.2.10 SameValueï¼ˆxï¼Œyï¼‰

æŠ½è±¡æ“ä½œSameValueæ¥å—å‚æ•°xï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’Œyï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ï¼Œå¹¶è¿”å›ä¸€ä¸ªå®Œæˆè®°å½•ï¼Œè¯¥è®°å½•çš„[[Type]]ä¸ºæ­£å¸¸å€¼ï¼Œ[[value]]ä¸ºå¸ƒå°”å€¼ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If Type(x) is different from Type(y), return false.
2. If x is a Number, then
    - Return Number::sameValue(x, y).
3. Return SameValueNonNumber(x, y).
    
>NOTE è¯¥ç®—æ³•ä¸åŒäºä¸¥æ ¼ç­‰å¼æ¯”è¾ƒç®—æ³•åœ¨å¤„ç†æœ‰ç¬¦å·é›¶å’ŒNaNä¸Šçš„ä¸åŒã€‚

### 7.2.11 SameValueZeroï¼ˆxï¼Œyï¼‰

æŠ½è±¡æ“ä½œSameValueZeroæ¥å—å‚æ•°xï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’Œyï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ï¼Œå¹¶è¿”å›å…¶[[Type]]æ­£å¸¸ä¸”[[Value]]æ˜¯å¸ƒå°”å€¼çš„å®Œæˆè®°å½•ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If Type(x) is different from Type(y), return false.
2. If x is a Number, then
    - Return Number::sameValueZero(x, y).
3. Return SameValueNonNumber(x, y).

>NOTE SameValueZeroä¸SameValueçš„åŒºåˆ«ä»…åœ¨äºå…¶å¤„ç†+0ğ”½å’Œ-0ğ”½ã€‚

### 7.2.12 SameValueNonNumericï¼ˆxï¼Œyï¼‰

æŠ½è±¡æ“ä½œSameValueNonNumericæ¥å—å‚æ•°xï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’Œyï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ï¼Œå¹¶è¿”å›å…¶[[Type]]ä¸ºæ­£å¸¸ä¸”[[Value]]ä¸ºå¸ƒå°”å€¼çš„å®Œæˆè®°å½•ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š


1. Assert: Type(x) is the same as Type(y).
2. If x is a BigInt, then
    - Return BigInt::equal(x, y).
3. If x is undefined, return true.
4. If x is null, return true.
5. If x is a String, then
    - If x and y are exactly the same sequence of code units (same length and same code units at corresponding indices), return true; otherwise, return false.
6. If x is a Boolean, then
    - If x and y are both true or both false, return true; otherwise, return false.
7. If x is a Symbol, then
    - If x and y are both the same Symbol value, return true; otherwise, return false.
8. If x and y are the same Object value, return true. Otherwise, return false.

### 7.2.13 IsLessThan ( x, y, LeftFirst )

æ¯”è¾ƒx < yï¼Œå…¶ä¸­xå’Œyæ˜¯å€¼ï¼Œäº§ç”Ÿtrueã€falseæˆ–undefinedï¼ˆè¿™è¡¨ç¤ºè‡³å°‘æœ‰ä¸€ä¸ªæ“ä½œæ•°æ˜¯NaNï¼‰ã€‚é™¤äº†xå’Œyä¹‹å¤–ï¼Œè¯¥ç®—æ³•è¿˜ä½¿ç”¨ä¸€ä¸ªåä¸ºLeftFirstçš„å¸ƒå°”æ ‡å¿—ä½œä¸ºå‚æ•°ã€‚æ­¤æ ‡å¿—ç”¨äºæ§åˆ¶å¯¹xå’Œyæ‰§è¡Œå…·æœ‰æ½œåœ¨å¯è§å‰¯ä½œç”¨çš„æ“ä½œçš„é¡ºåºã€‚è¿™æ˜¯å¿…éœ€çš„ï¼Œå› ä¸ºECMAScriptæŒ‡å®šä»å·¦åˆ°å³è®¡ç®—è¡¨è¾¾å¼ã€‚LeftFirstçš„é»˜è®¤å€¼ä¸ºtrueï¼Œè¡¨ç¤ºxå‚æ•°å¯¹åº”äºyå‚æ•°å¯¹åº”è¡¨è¾¾å¼å·¦ä¾§çš„è¡¨è¾¾å¼ã€‚å¦‚æœLeftFirstä¸ºfalseï¼Œåˆ™æƒ…å†µç›¸åï¼Œå¿…é¡»åœ¨xä¹‹å‰å¯¹yæ‰§è¡Œæ“ä½œã€‚è¿™æ ·çš„æ¯”è¾ƒå¦‚ä¸‹ï¼š

1. If the LeftFirst flag is true, then
    a. Let px be ? ToPrimitive(x, number).
    b. Let py be ? ToPrimitive(y, number).
2. Else,
    a. NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.
    b. Let py be ? ToPrimitive(y, number).
    c. Let px be ? ToPrimitive(x, number).
3. If px is a String and py is a String, then
    a. Let lx be the length of px.
    b. Let ly be the length of py.
    c. For each integer i such that 0 â‰¤ i < min(lx, ly), in ascending order, do
        i. Let cx be the integer that is the numeric value of the code unit at index i within px.
        ii. Let cy be the integer that is the numeric value of the code unit at index i within py.
        iii. If cx < cy, return true.
        iv. If cx > cy, return false.
    d. If lx < ly, return true. Otherwise, return false.
4. Else,
    a. If px is a BigInt and py is a String, then
        i. Let ny be StringToBigInt(py).
        ii. If ny is undefined, return undefined.
        iii. Return BigInt::lessThan(px, ny).
    b. If px is a String and py is a BigInt, then
        i. Let nx be StringToBigInt(px).
        ii. If nx is undefined, return undefined.
        iii. Return BigInt::lessThan(nx, py).
    c. NOTE: Because px and py are primitive values, evaluation order is not important.
    d. Let nx be ? ToNumeric(px).
    e. Let ny be ? ToNumeric(py).
    f. If Type(nx) is the same as Type(ny), then
        i. If nx is a Number, then
            1. Return Number::lessThan(nx, ny).
        ii. Else,
            1. Assert: nx is a BigInt.
            2. Return BigInt::lessThan(nx, ny).
    g. Assert: nx is a BigInt and ny is a Number, or nx is a Number and ny is a BigInt.
    h. If nx or ny is NaN, return undefined.
    i. If nx is -âˆğ”½ or ny is +âˆğ”½, return true.
    j. If nx is +âˆğ”½ or ny is -âˆğ”½, return false.
    k. If â„(nx) < â„(ny), return true; otherwise return false.

>NOTE1 æ­¥éª¤3ä¸æ­¥éª¤1.cçš„ä¸åŒä¹‹å¤„åœ¨äºï¼Œåœ¨å¤„ç†åŠ æ³•è¿ç®—ç¬¦+ï¼ˆ13.15.3ï¼‰çš„ç®—æ³•ä¸­ï¼Œä½¿ç”¨é€»è¾‘andè¿ç®—è€Œä¸æ˜¯é€»è¾‘orè¿ç®—ã€‚

>NOTE2 å­—ç¬¦ä¸²çš„æ¯”è¾ƒå¯¹ä»£ç å•å…ƒå€¼åºåˆ—ä½¿ç”¨äº†ä¸€ä¸ªç®€å•çš„å­—å…¸åºã€‚æ²¡æœ‰äººè¯•å›¾ä½¿ç”¨Unicodeè§„èŒƒä¸­å®šä¹‰çš„æ›´å¤æ‚ã€é¢å‘è¯­ä¹‰çš„å­—ç¬¦æˆ–å­—ç¬¦ä¸²ç›¸ç­‰æ€§å’Œæ’åºé¡ºåºçš„å®šä¹‰ã€‚å› æ­¤ï¼Œæ ¹æ®Unicodeæ ‡å‡†è§„èŒƒç›¸ç­‰çš„å­—ç¬¦ä¸²å€¼å¯èƒ½æµ‹è¯•ä¸ºä¸ç›¸ç­‰ã€‚å®é™…ä¸Šï¼Œè¿™ä¸ªç®—æ³•å‡è®¾ä¸¤ä¸ªå­—ç¬¦ä¸²éƒ½å·²ç»æ˜¯è§„èŒƒåŒ–çš„å½¢å¼ã€‚å¦å¤–ï¼Œè¯·æ³¨æ„ï¼Œå¯¹äºåŒ…å«è¡¥å……å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼ŒUTF-16ä»£ç å•å…ƒå€¼åºåˆ—çš„å­—å…¸åºé¡ºåºä¸ä»£ç ç‚¹å€¼åºåˆ—çš„å­—å…¸åºé¡ºåºä¸åŒã€‚


### 7.2.14 IsLooselyEqual ( x, y )

æŠ½è±¡æ“ä½œ IsLooselyEqual æ¥å—å‚æ•° xï¼ˆECMAScript è¯­è¨€å€¼ï¼‰å’Œ yï¼ˆECMAScript è¯­è¨€å€¼ï¼‰ã€‚ å®ƒä¸ºæ¯”è¾ƒ x == y æä¾›è¯­ä¹‰ï¼Œè¿”å› true æˆ– falseã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If Type(x) is the same as Type(y), then
    - Return IsStrictlyEqual(x, y).
2. If x is null and y is undefined, return true.
3. If x is undefined and y is null, return true.
4. NOTE: This step is replaced in section B.3.6.2.
5. If x is a Number and y is a String, return ! IsLooselyEqual(x, ! ToNumber(y)).
6. If x is a String and y is a Number, return ! IsLooselyEqual(! ToNumber(x), y).
7. If x is a BigInt and y is a String, then
    - Let n be StringToBigInt(y).
    - If n is undefined, return false.
    - Return ! IsLooselyEqual(x, n).
8. If x is a String and y is a BigInt, return ! IsLooselyEqual(y, x).
9. If x is a Boolean, return ! IsLooselyEqual(! ToNumber(x), y).
10. If y is a Boolean, return ! IsLooselyEqual(x, ! ToNumber(y)).
11. If x is either a String, a Number, a BigInt, or a Symbol and y is an Object, return ! IsLooselyEqual(x, ? ToPrimitive(y)).
12. If x is an Object and y is either a String, a Number, a BigInt, or a Symbol, return ! IsLooselyEqual(? ToPrimitive(x), y).
13. If x is a BigInt and y is a Number, or if x is a Number and y is a BigInt, then
    - If x is not finite or y is not finite, return false.
    - If â„(x) = â„(y), return true; otherwise return false.
14. Return false.

### 7.2.15 Strict Equality Comparison

æ¯”è¾ƒx===yï¼Œå…¶ä¸­xå’Œyæ˜¯å€¼ï¼Œäº§ç”Ÿtrueæˆ–falseã€‚è¿™æ ·çš„æ¯”è¾ƒå¦‚ä¸‹ï¼š

1. If Type(x) is different from Type(y), return false.
2. If x is a Number, then
    - Return Number::equal(x, y).
3. Return SameValueNonNumber(x, y).

>NOTE è¯¥ç®—æ³•ä¸SameValueï¼ˆåŒå€¼ç®—æ³•ï¼‰çš„åŒºåˆ«åœ¨äºå¯¹æœ‰ç¬¦å·é›¶å’ŒNaNçš„å¤„ç†ã€‚
