### 7.3.1 MakeBasicObjectï¼ˆinternalSlotsListï¼‰

æŠ½è±¡æ“ä½œMakeBasicObjectæ¥å—å‚æ•°internalSlotsListã€‚å®ƒæ˜¯ç®—æ³•åˆ›å»ºçš„æ‰€æœ‰ECMAScriptå¯¹è±¡çš„æºï¼ŒåŒ…æ‹¬æ™®é€šå¯¹è±¡å’Œå¤–æ¥å¯¹è±¡ã€‚å®ƒå°†åˆ›å»ºæ‰€æœ‰å¯¹è±¡æ—¶ä½¿ç”¨çš„å¸¸è§æ­¥éª¤åˆ†è§£å‡ºæ¥ï¼Œå¹¶é›†ä¸­åˆ›å»ºå¯¹è±¡ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let obj be a newly created object with an internal slot for each name in internalSlotsList.
2. Set obj's essential internal methods to the default ordinary object definitions specified in 10.1.
3. Assert: If the caller will not be overriding both obj's [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then internalSlotsList contains [[Prototype]].
4. Assert: If the caller will not be overriding all of obj's [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then internalSlotsList contains [[Extensible]].
5. If internalSlotsList contains [[Extensible]], set obj.[[Extensible]] to true.
6. Return obj.

    åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡objï¼ŒinternalSlotsListä¸­çš„æ¯ä¸ªåç§°éƒ½æœ‰ä¸€ä¸ªå†…éƒ¨æ§½ã€‚

    å°†objçš„åŸºæœ¬å†…éƒ¨æ–¹æ³•è®¾ç½®ä¸º10.1ä¸­æŒ‡å®šçš„é»˜è®¤æ™®é€šå¯¹è±¡å®šä¹‰ã€‚

    æ–­è¨€ï¼šå¦‚æœè°ƒç”¨æ–¹ä¸ä¼šåŒæ—¶é‡å†™objçš„[[GetPrototypeOf]]å’Œ[[SetPrototypeOf]]åŸºæœ¬å†…éƒ¨æ–¹æ³•ï¼Œé‚£ä¹ˆinternalSlotsListåŒ…å«[[Prototype]]ã€‚

    æ–­è¨€ï¼šå¦‚æœè°ƒç”¨æ–¹ä¸ä¼šé‡å†™objçš„æ‰€æœ‰[[SetPrototypeOf]]ã€[[IsExtensible]]å’Œ[[PreventExtensions]]åŸºæœ¬å†…éƒ¨æ–¹æ³•ï¼Œåˆ™internalSlotsListåŒ…å«[[Extensible]]ã€‚

    å¦‚æœinternalSlotsListåŒ…å«[[Extensible]]ï¼Œè¯·å°†obj.[[Extensible]]è®¾ç½®ä¸ºtrueã€‚

    è¿”å› objã€‚

>NOTE åœ¨è¿™ä¸ªè§„èŒƒä¸­ï¼Œé€šè¿‡é¦–å…ˆè°ƒç”¨MakeBasicObjectè·å–åŸºæœ¬çš„åŸºç¡€å¯¹è±¡ï¼Œç„¶åé‡å†™è¯¥å¯¹è±¡çš„éƒ¨åˆ†æˆ–å…¨éƒ¨å†…éƒ¨æ–¹æ³•ï¼Œä»¥æŠ½è±¡æ“ä½œï¼ˆä¾‹å¦‚ArrayCreateå’ŒBoundFunctionCreateï¼‰åˆ›å»ºå¼‚ç±»å¯¹è±¡ã€‚ ä¸ºäº†å°è£…Yå¼‚è´¨å¯¹è±¡çš„åˆ›å»ºï¼Œæ°¸è¿œä¸è¦åœ¨è¿™äº›æ“ä½œä¹‹å¤–ä¿®æ”¹å¯¹è±¡çš„åŸºæœ¬å†…éƒ¨æ–¹æ³•ã€‚

### 7.3.2 Get ( O, P )

æŠ½è±¡æ“ä½œGetæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰å’ŒPï¼ˆå±æ€§é”®ï¼‰ï¼Œå¹¶è¿”å›åŒ…å«ECMAScriptè¯­è¨€å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚å®ƒç”¨äºæ£€ç´¢å¯¹è±¡çš„ç‰¹å®šå±æ€§çš„å€¼ã€‚è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Return ? O.[[Get]](P, O).

### 7.3.3 GetV ( V, P )

æŠ½è±¡æ“ä½œGetVæ¥å—å‚æ•°Vï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’ŒPï¼ˆå±æ€§é”®ï¼‰ï¼Œå¹¶è¿”å›åŒ…å«ECMAScriptè¯­è¨€å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚å®ƒç”¨äºæ£€ç´¢ECMAScriptè¯­è¨€å€¼çš„ç‰¹å®šå±æ€§çš„å€¼ã€‚å¦‚æœå€¼ä¸æ˜¯å¯¹è±¡ï¼Œåˆ™ä½¿ç”¨é€‚åˆäºå€¼ç±»å‹çš„åŒ…è£…å™¨å¯¹è±¡æ‰§è¡Œå±æ€§æŸ¥æ‰¾ã€‚è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let O be ? ToObject(V).
2. Return ? O.[[Get]](P, V).

### 7.3.4 Set ( O, P, V, Throw )

æŠ½è±¡æ“ä½œSetæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰ï¼ŒPï¼ˆå±æ€§é”®ï¼‰ï¼ŒVï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’ŒThrowï¼ˆå¸ƒå°”å€¼ï¼‰ã€‚ å®ƒç”¨äºè®¾ç½®å¯¹è±¡çš„ç‰¹å®šå±æ€§çš„å€¼ã€‚ Væ˜¯è¯¥å±æ€§çš„æ–°å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let success be ? O.[[Set]](P, V, O).
2. If success is false and Throw is true, throw a TypeError exception.
3. Return unused.

### 7.3.5 CreateDataProperty ( O, P, V )

æŠ½è±¡æ“ä½œCreateDataPropertyæ¥å—å‚æ•°Oï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰ï¼ŒPï¼ˆä¸€ä¸ªå±æ€§é”®ï¼‰å’ŒVï¼ˆä¸€ä¸ªECMAScriptè¯­è¨€å€¼ï¼‰ã€‚ å®ƒç”¨äºåˆ›å»ºå¯¹è±¡çš„æ–°çš„è‡ªå·±çš„å±æ€§ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let newDesc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
2. Return ? O.[[DefineOwnProperty]](P, newDesc).

>NOTE æ­¤æŠ½è±¡æ“ä½œåˆ›å»ºä¸€ä¸ªå±æ€§ï¼Œè¯¥å±æ€§çš„å±æ€§è®¾ç½®ä¸ºä¸ECMAScriptè¯­è¨€èµ‹å€¼è¿ç®—ç¬¦åˆ›å»ºçš„å±æ€§ç›¸åŒçš„é»˜è®¤å€¼ã€‚é€šå¸¸ï¼Œè¯¥å±æ€§å°†ä¸å­˜åœ¨ã€‚å¦‚æœå®ƒç¡®å®å­˜åœ¨å¹¶ä¸”ä¸å¯é…ç½®ï¼Œæˆ–è€…Oä¸å¯æ‰©å±•ï¼Œ[[DefineOwnProperty]]å°†è¿”å›falseã€‚

### 7.3.6 CreateMethodProperty ( O, P, V )

æŠ½è±¡æ“ä½œCreateMethodPropertyæ¥å—å‚æ•°Oï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰ï¼ŒPï¼ˆä¸€ä¸ªå±æ€§é”®ï¼‰å’ŒVï¼ˆä¸€ä¸ªECMAScriptè¯­è¨€å€¼ï¼‰ã€‚ å®ƒç”¨äºåˆ›å»ºå¯¹è±¡çš„æ–°çš„è‡ªå·±çš„å±æ€§ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Assert: O is an ordinary, extensible object with no non-configurable properties.
2. Let newDesc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
3. Perform ! DefinePropertyOrThrow(O, P, newDesc).
4. Return unused.

>NOTE æ­¤æŠ½è±¡æ“ä½œå°†åˆ›å»ºä¸€ä¸ªå±æ€§ï¼Œè¯¥å±æ€§çš„å±æ€§è®¾ç½®ä¸ºä¸å†…ç½®æ–¹æ³•å’Œä½¿ç”¨ç±»å£°æ˜è¯­æ³•å®šä¹‰çš„æ–¹æ³•ç›¸åŒçš„é»˜è®¤å€¼ã€‚ é€šå¸¸ï¼Œè¯¥å±æ€§å°†ä¸å­˜åœ¨ã€‚ å¦‚æœå®ƒç¡®å®å­˜åœ¨å¹¶ä¸”ä¸å¯é…ç½®ï¼Œæˆ–è€…Oä¸å¯æ‰©å±•ï¼Œåˆ™[[DefineOwnProperty]]å°†è¿”å›falseã€‚

### 7.3.7 CreateDataPropertyOrThrow ( O, P, V )

æŠ½è±¡æ“ä½œCreateDataPropertyOrThrowä½¿ç”¨å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰ï¼ŒPï¼ˆå±æ€§é”®ï¼‰å’ŒVï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ã€‚ å®ƒç”¨äºåˆ›å»ºå¯¹è±¡çš„æ–°çš„è‡ªå·±çš„å±æ€§ã€‚ å¦‚æœæ— æ³•æ‰§è¡Œè¯·æ±‚çš„å±æ€§æ›´æ–°ï¼Œåˆ™ä¼šå¼•å‘TypeErrorå¼‚å¸¸ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let success be ? CreateDataProperty(O, P, V).
2. If success is false, throw a TypeError exception.
3. Return unused.

>NOTE æ­¤æŠ½è±¡æ“ä½œå°†åˆ›å»ºä¸€ä¸ªå±æ€§ï¼Œè¯¥å±æ€§çš„å±æ€§è®¾ç½®ä¸ºä¸ECMAScriptè¯­è¨€åˆ†é…è¿ç®—ç¬¦åˆ›å»ºçš„å±æ€§æ‰€ä½¿ç”¨çš„é»˜è®¤å€¼ç›¸åŒçš„é»˜è®¤å€¼ã€‚ é€šå¸¸ï¼Œè¯¥å±æ€§å°†ä¸å­˜åœ¨ã€‚ å¦‚æœå®ƒç¡®å®å­˜åœ¨å¹¶ä¸”ä¸å¯é…ç½®ï¼Œæˆ–è€…Oæ˜¯ä¸å¯æ‰©å±•çš„ï¼Œåˆ™[[DefineOwnProperty]]å°†è¿”å›falseï¼Œå¯¼è‡´æ­¤æ“ä½œå¼•å‘TypeErrorå¼‚å¸¸ã€‚


### 7.3.8 åˆ›å»ºéæšä¸¾æ•°æ®å±æ€§æˆ–æŠ›å‡º CreateNonEnumerableDataPropertyOrThrow ( O, P, V )

æŠ½è±¡æ“ä½œ CreateNonEnumerableDataPropertyOrThrow æ¥å—å‚æ•° Oï¼ˆå¯¹è±¡ï¼‰ã€Pï¼ˆå±æ€§é”®ï¼‰å’Œ Vï¼ˆECMAScript è¯­è¨€å€¼ï¼‰ã€‚ å®ƒç”¨äºåˆ›å»ºå¯¹è±¡çš„æ–°çš„ä¸å¯æšä¸¾çš„è‡ªå·±çš„å±æ€§ã€‚ å¦‚æœæ— æ³•æ‰§è¡Œè¯·æ±‚çš„å±æ€§æ›´æ–°ï¼Œåˆ™ä¼šå¼•å‘ TypeError å¼‚å¸¸ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Assert: O is an ordinary, extensible object with no non-configurable properties.
2. Let newDesc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
3. Perform ! DefinePropertyOrThrow(O, P, newDesc).
4. Return unused.

```
// Aggregateã€Errotå’ŒNativeErrorä½¿ç”¨äº†æ­¤æ“ä½œ
let a = new Error('123')
Object.getOwnPropertyDescriptors(a)
```

>NOTE æ­¤æŠ½è±¡æ“ä½œåˆ›å»ºä¸€ä¸ªå±æ€§ï¼Œè¯¥å±æ€§çš„å±æ€§è®¾ç½®ä¸ºä¸ECMAScriptè¯­è¨€èµ‹å€¼è¿ç®—ç¬¦åˆ›å»ºçš„å±æ€§ç›¸åŒçš„é»˜è®¤å€¼ï¼Œä½†ä¸å¯æšä¸¾ã€‚é€šå¸¸ï¼Œè¯¥å±æ€§å°†ä¸å­˜åœ¨ã€‚å¦‚æœDefinePropertyOrThrowç¡®å®å­˜åœ¨ï¼Œåˆ™ä¿è¯å…¶æ­£å¸¸å®Œæˆã€‚

### 7.3.9 DefinePropertyOrThrow ( O, P, desc )

æŠ½è±¡æ“ä½œDefinePropertyOrThrowæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰ï¼ŒPï¼ˆå±æ€§é”®ï¼‰å’Œdescï¼ˆå±æ€§æè¿°ç¬¦ï¼‰ã€‚ å®ƒç”¨äºä»¥æŸç§æ–¹å¼è°ƒç”¨å¯¹è±¡çš„[[DefineOwnProperty]]å†…éƒ¨æ–¹æ³•ï¼Œå¦‚æœæ— æ³•æ‰§è¡Œè¯·æ±‚çš„å±æ€§æ›´æ–°ï¼Œè¯¥æ–¹æ³•å°†å¼•å‘TypeErrorå¼‚å¸¸ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let success be ? O.[[DefineOwnProperty]](P, desc).
2. If success is false, throw a TypeError exception.
3. Return unused.

### 7.3.10 DeletePropertyOrThrow ( O, P )

æŠ½è±¡æ“ä½œDeletePropertyOrThrowå¸¦æœ‰å‚æ•°Oï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰å’ŒPï¼ˆä¸€ä¸ªå±æ€§é”®ï¼‰ã€‚ å®ƒç”¨äºåˆ é™¤å¯¹è±¡çš„ç‰¹å®šè‡ªèº«å±æ€§ã€‚ å¦‚æœè¯¥å±æ€§ä¸å¯é…ç½®ï¼Œå®ƒå°†å¼•å‘å¼‚å¸¸ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let success be ? O.[[Delete]](P).
2. If success is false, throw a TypeError exception.
3. Return unused.

### 7.3.11 GetMethod ( V, P )

æŠ½è±¡æ“ä½œGetMethodæ¥å—å‚æ•°Vï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’ŒPï¼ˆå±æ€§é”®ï¼‰ã€‚ å½“è¯¥å±æ€§çš„å€¼åº”ä¸ºå‡½æ•°æ—¶ï¼Œå¯ç”¨äºè·å–ECMAScriptè¯­è¨€å€¼çš„ç‰¹å®šå±æ€§çš„å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let func be ? GetV(V, P).
2. If func is either undefined or null, return undefined.
3. If IsCallable(func) is false, throw a TypeError exception.
4. Return func.

### 7.3.12 HasProperty ( O, P )

æŠ½è±¡æ“ä½œHasPropertyæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰å’ŒPï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›å®Œæˆè®°å½•ï¼Œå¦‚æœè®°å½•çš„[[Type]]æ­£å¸¸ï¼Œåˆ™è¯¥è®°å½•å…·æœ‰å¸ƒå°”å€¼[[Value]]ã€‚ å®ƒç”¨äºç¡®å®šå¯¹è±¡æ˜¯å¦å…·æœ‰å¸¦æœ‰æŒ‡å®šå±æ€§é”®çš„å±æ€§ã€‚ è¯¥å±æ€§å¯ä»¥æ˜¯è‡ªå·±çš„æˆ–ç»§æ‰¿çš„ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Return ? O.[[HasProperty]](P).

### 7.3.13 HasOwnProperty ( O, P )

æŠ½è±¡æ“ä½œHasOwnPropertyæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰å’ŒPï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›å®Œæˆè®°å½•ï¼Œå¦‚æœè®°å½•çš„[[Type]]æ­£å¸¸ï¼Œåˆ™è¯¥è®°å½•å…·æœ‰å¸ƒå°”å€¼[[Value]]ã€‚ å®ƒç”¨äºç¡®å®šå¯¹è±¡æ˜¯å¦å…·æœ‰å¸¦æœ‰æŒ‡å®šå±æ€§é”®çš„è‡ªå·±çš„å±æ€§ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let desc be ? O.[[GetOwnProperty]](P).
2. If desc is undefined, return false.
3. Return true.

### 7.3.14 Call ( F, V [ , argumentsList ] )

æŠ½è±¡æ“ä½œCallæ¥å—å‚æ•°Fï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’ŒVï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ä»¥åŠå¯é€‰å‚æ•°argumentsListï¼ˆECMAScriptè¯­è¨€å€¼åˆ—è¡¨ï¼‰ã€‚ å®ƒç”¨äºè°ƒç”¨å‡½æ•°å¯¹è±¡çš„[[Call]]å†…éƒ¨æ–¹æ³•ã€‚ Fæ˜¯å‡½æ•°å¯¹è±¡ï¼ŒVæ˜¯ECMAScriptè¯­è¨€å€¼ï¼Œå®ƒæ˜¯[[Call]]çš„thiså€¼ï¼ŒargumentsListæ˜¯ä¼ é€’ç»™å†…éƒ¨æ–¹æ³•çš„ç›¸åº”å‚æ•°çš„å€¼ã€‚ å¦‚æœargumentsListä¸å­˜åœ¨ï¼Œåˆ™å°†æ–°çš„ç©ºListç”¨ä½œå…¶å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If argumentsList is not present, set argumentsList to a new empty List.
2. If IsCallable(F) is false, throw a TypeError exception.
3. Return ? F.[[Call]](V, argumentsList).

### 7.3.15 Construct ( F [ , argumentsList [ , newTarget ] ] )

æŠ½è±¡æ“ä½œConstructæ¥å—å‚æ•°Fï¼ˆå‡½æ•°å¯¹è±¡ï¼‰ä»¥åŠå¯é€‰å‚æ•°argumentsListå’ŒnewTargetã€‚ å®ƒç”¨äºè°ƒç”¨åŠŸèƒ½å¯¹è±¡çš„[[Construct]]å†…éƒ¨æ–¹æ³•ã€‚ argumentsListå’ŒnewTargetæ˜¯è¦ä½œä¸ºå†…éƒ¨æ–¹æ³•çš„ç›¸åº”å‚æ•°ä¼ é€’çš„å€¼ã€‚ å¦‚æœargumentsListä¸å­˜åœ¨ï¼Œåˆ™å°†æ–°çš„ç©ºListç”¨ä½œå…¶å€¼ã€‚ å¦‚æœnewTargetä¸å­˜åœ¨ï¼Œåˆ™Fç”¨ä½œå…¶å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If newTarget is not present, set newTarget to F.
2. If argumentsList is not present, set argumentsList to a new empty List.
3. Return ? F.[[Construct]](argumentsList, newTarget).

>NOTE å¦‚æœä¸å­˜åœ¨newTargetï¼Œåˆ™æ­¤æ“ä½œç­‰æ•ˆäºï¼šnew Fï¼ˆ... argumentsListï¼‰

### 7.3.16 SetIntegrityLevel ( O, level )

æŠ½è±¡æ“ä½œSetIntegrityLevelæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰å’Œçº§åˆ«ï¼ˆå¯†å°æˆ–å†»ç»“ï¼‰ï¼Œå¹¶è¿”å›åŒ…å«å¸ƒå°”å€¼çš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚å®ƒç”¨äºä¿®å¤å¯¹è±¡è‡ªèº«çš„å±æ€§é›†ã€‚è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let status be ? O.[[PreventExtensions]]().
2. If status is false, return false.
3. Let keys be ? O.[[OwnPropertyKeys]]().
4. If level is sealed, then
    - For each element k of keys, do
        - Perform ? DefinePropertyOrThrow(O, k, PropertyDescriptor { [[Configurable]]: false }).
5. Else,
    - Assert: level is frozen.
    - For each element k of keys, do
        1. Let currentDesc be ? O.[[GetOwnProperty]](k).
        2. If currentDesc is not undefined, then
            - If IsAccessorDescriptor(currentDesc) is true, then
                - Let desc be the PropertyDescriptor { [[Configurable]]: false }.
            - Else,
                - Let desc be the PropertyDescriptor { [[Configurable]]: false, [[Writable]]: false }.
            - Perform ? DefinePropertyOrThrow(O, k, desc).
6. Return true.

### 7.3.17 TestIntegrityLevel ( O, level )

æŠ½è±¡æ“ä½œtestintegritelevelæ¥å—å‚æ•°Oå’Œlevelã€‚å®ƒç”¨äºç¡®å®šå¯¹è±¡çš„è‡ªèº«å±æ€§é›†æ˜¯å¦å›ºå®šã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let extensible be ? IsExtensible(O).
2. If extensible is true, return false.
3. NOTE: If the object is extensible, none of its properties are examined.
4. Let keys be ? O.[[OwnPropertyKeys]]().
5. For each element k of keys, do
    - Let currentDesc be ? O.[[GetOwnProperty]](k).
    - If currentDesc is not undefined, then
        - If currentDesc.[[Configurable]] is true, return false.
        - If level is frozen and IsDataDescriptor(currentDesc) is true, then
            - If currentDesc.[[Writable]] is true, return false.
6. Return true.

### 7.3.18 CreateArrayFromList ( elements )

æŠ½è±¡æ“ä½œCreateArrayFromListæ¥å—å‚æ•°å…ƒç´ ï¼ˆä¸€ä¸ªåˆ—è¡¨ï¼‰ã€‚å®ƒç”¨äºåˆ›å»ºå…ƒç´ ç”±å…ƒç´ æä¾›çš„æ•°ç»„å¯¹è±¡ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let array be ! ArrayCreate(0).
2. Let n be 0.
3. For each element e of elements, do
    - Perform ! CreateDataPropertyOrThrow(array, ! ToString(ğ”½(n)), e).
    - Set n to n + 1.
4. Return array.

### 7.3.19 LengthOfArrayLike ( obj )

æŠ½è±¡æ“ä½œLengthOfArrayLikeä½¿ç”¨å‚æ•°objã€‚ å®ƒè¿”å›ç±»ä¼¼æ•°ç»„çš„å¯¹è±¡çš„â€œ lengthâ€å±æ€§çš„å€¼ï¼ˆä½œä¸ºéè´Ÿæ•´æ•°ï¼‰ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Return â„(? ToLength(? Get(obj, "length"))).

ç±»æ•°ç»„å¯¹è±¡æ˜¯è¯¥æ“ä½œä¸ºå…¶è¿”å›æ•´æ•°è€Œä¸æ˜¯çªç„¶å®Œæˆçš„ä»»ä½•å¯¹è±¡ã€‚

>NOTE1 é€šå¸¸ï¼Œç±»ä¼¼æ•°ç»„çš„å¯¹è±¡è¿˜å°†å…·æœ‰ä¸€äº›å¸¦æœ‰æ•´æ•°ç´¢å¼•åç§°çš„å±æ€§ã€‚ ä½†æ˜¯ï¼Œè¿™ä¸æ˜¯æ­¤å®šä¹‰çš„è¦æ±‚ã€‚

>NOTE2 æ•°ç»„å¯¹è±¡å’ŒStringå¯¹è±¡æ˜¯ç±»æ•°ç»„å¯¹è±¡çš„ç¤ºä¾‹ã€‚

### 7.3.20 CreateListFromArrayLike ( obj [ , elementTypes ] )

æŠ½è±¡æ“ä½œCreateListFromArrayLikeæ¥å—å‚æ•°objå’Œå¯é€‰å‚æ•°elementTypesï¼ˆECMAScriptè¯­è¨€ç±»å‹çš„åç§°åˆ—è¡¨ï¼‰ã€‚å®ƒç”¨äºåˆ›å»ºä¸€ä¸ªåˆ—è¡¨å€¼ï¼Œå…¶å…ƒç´ ç”±objçš„ç´¢å¼•å±æ€§æä¾›ã€‚elementTypesåŒ…å«åˆ›å»ºçš„åˆ—è¡¨çš„å…ƒç´ å€¼å…è®¸ä½¿ç”¨çš„ECMAScriptè¯­è¨€ç±»å‹çš„åç§°ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If elementTypes is not present, set elementTypes to Â« Undefined, Null, Boolean, String, Symbol, Number, BigInt, Object Â».
2. If obj is not an Object, throw a TypeError exception.
3. Let len be ? LengthOfArrayLike(obj).
4. Let list be a new empty List.
5. Let index be 0.
6. Repeat, while index < len,
    - Let indexName be ! ToString(ğ”½(index)).
    - Let next be ? Get(obj, indexName).
    - If Type(next) is not an element of elementTypes, throw a TypeError exception.
    - Append next to list.
    - Set index to index + 1.
7. Return list.

### 7.3.21 Invoke ( V, P [ , argumentsList ] )

æŠ½è±¡æ“ä½œInvokeæ¥å—å‚æ•°Vï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’ŒPï¼ˆå±æ€§é”®ï¼‰ä»¥åŠå¯é€‰å‚æ•°argumentsListï¼ˆECMAScriptè¯­è¨€å€¼çš„åˆ—è¡¨ï¼‰ã€‚å®ƒç”¨äºè°ƒç”¨ECMAScriptè¯­è¨€å€¼çš„æ–¹æ³•å±æ€§ã€‚VåŒæ—¶å……å½“å±æ€§å’Œè°ƒç”¨çš„thiså€¼çš„æŸ¥æ‰¾ç‚¹ã€‚argumentsListæ˜¯ä¼ é€’ç»™æ–¹æ³•çš„å‚æ•°å€¼çš„åˆ—è¡¨ã€‚å¦‚æœargumentsListä¸å­˜åœ¨ï¼Œåˆ™ä½¿ç”¨æ–°çš„ç©ºåˆ—è¡¨ä½œä¸ºå…¶å€¼ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If argumentsList is not present, set argumentsList to a new empty List.
2. Let func be ? GetV(V, P).
3. Return ? Call(func, V, argumentsList).

### 7.3.22 OrdinaryHasInstance ( C, O )

æŠ½è±¡æ“ä½œOrdinaryHasInstanceé‡‡ç”¨å‚æ•°Cï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’ŒOã€‚å®ƒå®ç°ç”¨äºç¡®å®šOæ˜¯å¦ä»Cæä¾›çš„å®ä¾‹å¯¹è±¡ç»§æ‰¿è·¯å¾„ç»§æ‰¿çš„é»˜è®¤ç®—æ³•ã€‚åœ¨è°ƒç”¨æ—¶ï¼Œå®ƒæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If IsCallable(C) is false, return false.
2. If C has a [[BoundTargetFunction]] internal slot, then
    - Let BC be C.[[BoundTargetFunction]].
    - Return ? InstanceofOperator(O, BC).
3. If O is not an Object, return false.
4. Let P be ? Get(C, "prototype").
5. If P is not an Object, throw a TypeError exception.
6. Repeat,
    - Set O to ? O.[[GetPrototypeOf]]().
    - If O is null, return false.
    - If SameValue(P, O) is true, return true.

### 7.3.23 SpeciesConstructor ( O, defaultConstructor )

æŠ½è±¡æ“ä½œSpeciesConstructoræ¥å—å‚æ•°Oï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰å’ŒdefaultConstructorï¼ˆä¸€ä¸ªæ„é€ å‡½æ•°ï¼‰ã€‚ å®ƒç”¨äºæ£€ç´¢åº”ç”¨äºåˆ›å»ºä»Oæ´¾ç”Ÿçš„æ–°å¯¹è±¡çš„æ„é€ å‡½æ•°ã€‚defaultConstructoræ˜¯åœ¨æ— æ³•ä»Oå¼€å§‹æ‰¾åˆ°æ„é€ å‡½æ•°@@ specieså±æ€§çš„æƒ…å†µä¸‹ä½¿ç”¨çš„æ„é€ å‡½æ•°ã€‚è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let C be ? Get(O, "constructor").
2. If C is undefined, return defaultConstructor.
3. If C is not an Object, throw a TypeError exception.
4. Let S be ? Get(C, @@species).
5. If S is either undefined or null, return defaultConstructor.
6. If IsConstructor(S) is true, return S.
7. Throw a TypeError exception.

//å¦‚æœOçš„constructoræ²¡æœ‰å®šä¹‰å°±ä½¿ç”¨defaultConstructorï¼Œå¦åˆ™ä½¿ç”¨Get(C, @@species)å½“Get(C, @@species)è¿”å›ç»“æœä¸æ˜¯nullæˆ–è€…undefined

### 7.3.24 EnumerableOwnPropertyNames ( O, kind )
æŠ½è±¡æ“ä½œEnumerableOwnPropertyNamesæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰å’Œkindï¼ˆkeyã€valueæˆ–key+valueä¹‹ä¸€ï¼‰ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Assert: Type(O) is Object.
    Let ownKeys be ? O.[[OwnPropertyKeys]]().
    Let properties be a new empty List.
    For each element key of ownKeys, do
        If Type(key) is String, then
            Let desc be ? O.[[GetOwnProperty]](key).
            If desc is not undefined and desc.[[Enumerable]] is true, then
                If kind is key, append key to properties.
                Else,
                    Let value be ? Get(O, key).
                    If kind is value, append value to properties.
                    Else,
                        Assert: kind is key+value.
                        Let entry be ! CreateArrayFromList(Â« key, value Â»).
                        Append entry to properties.
    Return properties.

### 7.3.25 GetFunctionRealm ( obj )

æŠ½è±¡æ“ä½œGetFunctionRealmä½¿ç”¨å‚æ•°objã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If obj has a [[Realm]] internal slot, then
    - Return obj.[[Realm]].
2. If obj is a bound function exotic object, then
    - Let target be obj.[[BoundTargetFunction]].
    - Return ? GetFunctionRealm(target).
3. If obj is a Proxy exotic object, then
    - If obj.[[ProxyHandler]] is null, throw a TypeError exception.
    - Let proxyTarget be obj.[[ProxyTarget]].
    - Return ? GetFunctionRealm(proxyTarget).
4. Return the current Realm Record.

>NOTE åªæœ‰å½“objæ˜¯ä¸€ä¸ªæ²¡æœ‰[[Realm]]å†…éƒ¨æ§½çš„éæ ‡å‡†å‡½æ•°å¤–æ¥å¯¹è±¡æ—¶ï¼Œæ‰èƒ½æ‰§è¡Œç¬¬4æ­¥ã€‚

### 7.3.26 CopyDataProperties ( target, source, excludedItems )

æŠ½è±¡æ“ä½œCopyDataPropertiesä½¿ç”¨å‚æ•°targetï¼Œsourceå’ŒexcludeItemsã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If source is undefined or null, return unused.
2. Let from be ! ToObject(source).
3. Let keys be ? from.[[OwnPropertyKeys]]().
4. For each element nextKey of keys, do
    - Let excluded be false.
    - For each element e of excludedItems, do
        - If SameValue(e, nextKey) is true, then
            - Set excluded to true.
    - If excluded is false, then
        - Let desc be ? from.[[GetOwnProperty]](nextKey).
        - If desc is not undefined and desc.[[Enumerable]] is true, then
            - Let propValue be ? Get(from, nextKey).
            - Perform ! CreateDataPropertyOrThrow(target, nextKey, propValue).
5. Return unused.

>NOTE è¿™é‡Œä¼ é€’çš„ç›®æ ‡æ€»æ˜¯ä¸€ä¸ªæ–°åˆ›å»ºçš„å¯¹è±¡ï¼Œåœ¨å‘ç”Ÿé”™è¯¯æ—¶ä¸èƒ½ç›´æ¥è®¿é—®è¯¥å¯¹è±¡ã€‚


### 7.3.27 PrivateElementFind ( O, P )

æŠ½è±¡æ“ä½œ PrivateElementFind æ¥å—å‚æ•° Oï¼ˆan Objectï¼‰å’Œ Pï¼ˆa Private Nameï¼‰ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If O.[[PrivateElements]] contains a PrivateElement whose [[Key]] is P, then
    - Let entry be that PrivateElement.
    - Return entry.
2. Return empty.

    å¦‚æœO.[[PrivateElements]]åŒ…å«ä¸€ä¸ªç§æœ‰å±æ€§[[Key]](P),ç„¶åä»¤å…¶ä¸ºentryï¼Œå¹¶è¿”å›ï¼Œå¦åˆ™è¿”å›empty


### 7.3.28 PrivateFieldAdd ( O, P, value )

æŠ½è±¡æ“ä½œ PrivateFieldAdd æ¥å—å‚æ•° Oï¼ˆan Objectï¼‰ã€Pï¼ˆa Private Nameï¼‰å’Œå€¼ï¼ˆ(an ECMAScript language valueï¼‰ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. If the host is a web browser, then
    - Perform ? HostEnsureCanAddPrivateElement(O).
2. Let entry be PrivateElementFind(O, P).
3. If entry is not empty, throw a TypeError exception.
4. Append PrivateElement { [[Key]]: P, [[Kind]]: field, [[Value]]: value } to O.[[PrivateElements]].
5. Return unused.

    ä»¤entryä¸º!PrivateElementFind(O, P),å¦‚æœentryä¸æ˜¯ç©ºthrowä¸€ä¸ªTypeErrorï¼Œè¿½åŠ  PrivateElement

    class Point {
        #x;
        #y;
        #x;

        constructor(x, y) {
            this.#x = x;
            this.#y = y;
        }

        equals(point) {
            return this.#x === point.#x && this.#y === point.#y;
        }
    }

### 7.3.29 PrivateMethodOrAccessorAdd ( O, method )

æŠ½è±¡æ“ä½œ PrivateMethodOrAccessorAdd æ¥å—å‚æ•° Oï¼ˆan Objectï¼‰å’Œæ–¹æ³•ï¼ˆa PrivateElementï¼‰ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Assert: method.[[Kind]] is either method or accessor.
2. If the host is a web browser, then
    - Perform ? HostEnsureCanAddPrivateElement(O).
3. Let entry be PrivateElementFind(O, method.[[Key]]).
4. If entry is not empty, throw a TypeError exception.
5. Append method to O.[[PrivateElements]].
6. Return unused.

    æ–­è¨€ï¼š method.[[Kind]]æ˜¯methodæˆ–è€…accessor
    ä»¤entryä¸ºPrivateElementFind(O, method.[[Key]])
    å¦‚æœentryä¸æ˜¯ç©ºï¼ŒæŠ›å‡ºä¸€ä¸ªTypeError 
    è¿½åŠ methodåˆ°O.[[PrivateElements]].
    æ³¨æ„ï¼šç§æœ‰æ–¹æ³•å’Œè®¿é—®å™¨çš„å€¼åœ¨å®ä¾‹ä¹‹é—´å…±äº«ã€‚ æ­¤æ­¥éª¤ä¸ä¼šåˆ›å»ºæ–¹æ³•æˆ–è®¿é—®å™¨çš„æ–°å‰¯æœ¬ã€‚


### 7.3.30 HostEnsureCanAddPrivateElement ( O )

ä¸»æœºå®šä¹‰çš„æŠ½è±¡æ“ä½œHostEnsureCanAddPrivateElementæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰ï¼Œå¹¶è¿”å›åŒ…å«unusedçš„æ­£å¸¸å®Œæˆæˆ–æŠ›å‡ºå®Œæˆã€‚å®ƒå…è®¸ä¸»æœºç¯å¢ƒé˜²æ­¢å‘ç‰¹å®šä¸»æœºå®šä¹‰çš„å¼‚è´¨å¯¹è±¡æ·»åŠ ç§æœ‰å…ƒç´ ã€‚

HostEnsureCanAddPrivateElementçš„å®ç°å¿…é¡»ç¬¦åˆä»¥ä¸‹è¦æ±‚ï¼š

- å¦‚æœOä¸æ˜¯ä¸»æœºå®šä¹‰çš„å¤–æ¥å¯¹è±¡ï¼Œåˆ™æ­¤æŠ½è±¡æ“ä½œå¿…é¡»è¿”å›NormalCompletionï¼ˆunusedï¼‰ï¼Œå¹¶ä¸”ä¸æ‰§è¡Œå…¶ä»–æ­¥éª¤ã€‚
- ä½¿ç”¨åŒä¸€å‚æ•°çš„ä»»ä½•ä¸¤ä¸ªæŠ½è±¡æ“ä½œè°ƒç”¨éƒ½å¿…é¡»è¿”å›ç›¸åŒç±»å‹çš„å®Œæˆè®°å½•ã€‚

HostEnsureCanAddPrivateElementçš„é»˜è®¤å®ç°æ˜¯è¿”å›NormalCompletionï¼ˆunusedï¼‰ã€‚

æ­¤æŠ½è±¡æ“ä½œä»…ç”±ä½œä¸ºwebæµè§ˆå™¨çš„ECMAScriptä¸»æœºè°ƒç”¨ã€‚

### 7.3.31PrivateGet ( O, P )

æŠ½è±¡æ“ä½œ PrivateGet æ¥å—å‚æ•° Oï¼ˆan Objectï¼‰å’Œ Pï¼ˆa PrivateElementï¼‰ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let entry be PrivateElementFind(O, P).
2. If entry is empty, throw a TypeError exception.
3. If entry.[[Kind]] is field or method, then
    - Return entry.[[Value]].
4. Assert: entry.[[Kind]] is accessor.
5. If entry.[[Get]] is undefined, throw a TypeError exception.
6. Let getter be entry.[[Get]].
7. Return ? Call(getter, O).

    ä»¤entryä¸º!PrivateElementFind(O, P)
    å¦‚æœentryä¸ºç©ºæŠ›å‡ºTypeError
    å¦‚æœentry.[[Kind]]æ˜¯fieldæˆ–æ–¹æ³•methodï¼Œè¿”å›entry.[[Value]]
    æ–­è¨€entry.[[Kind]]æ˜¯accessor
    å¦‚æœentry.[[Get]]æ˜¯ndefinedï¼ŒæŠ›å‡ºTypeError
    ä»¤getterä¸ºentry.[[Get]]
    è¿”å›?Call(getter, O)

### 7.3.32 PrivateSet ( O, P, value )

æŠ½è±¡æ“ä½œ PrivateSet æ¥å—å‚æ•° Oï¼ˆan Objectï¼‰ã€Pï¼ˆa Private Nameï¼‰å’Œå€¼ï¼ˆan ECMAScript language valueï¼‰ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let entry be PrivateElementFind(O, P).
2. If entry is empty, throw a TypeError exception.
3. If entry.[[Kind]] is field, then
    - Set entry.[[Value]] to value.
4. Else if entry.[[Kind]] is method, then
    - Throw a TypeError exception.
5. Else,
    - Assert: entry.[[Kind]] is accessor.
    - If entry.[[Set]] is undefined, throw a TypeError exception.
    - Let setter be entry.[[Set]].
    - Perform ? Call(setter, O, Â« value Â»).
6. Return unused.

    ä»¤entryä¸º!PrivateElementFind(O, P)
    å¦‚æœentryä¸ºç©º,æŠ›å‡ºTypeError
    ä»¤entry.[[Kind]]ä¸ºfield
        è®¾ç½®valueä¸ºentry.[[Value]]
    å¦‚æœentry.[[Kind]]æ˜¯method
        æŠ›å‡ºTypeError
    å¦åˆ™
        æ–­è¨€entry.[[Kind]]æ˜¯accessor
        å¦‚æœentry.[[Set]]æ˜¯undefined,æŠ›å‡ºTypeError
        ä»¤setterä¸ºentry.[[Set]]
        æ‰§è¡Œ?Call(setter, O, Â« value Â»)

### 7.3.33 DefineField ( receiver, fieldRecord )

æŠ½è±¡æ“ä½œ DefineField æ¥å—å‚æ•°æ¥æ”¶å™¨ï¼ˆan Objectï¼‰å’Œ fieldRecordï¼ˆa ClassFieldDefinition Recordï¼‰ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let fieldName be fieldRecord.[[Name]].
2. Let initializer be fieldRecord.[[Initializer]].
3. If initializer is not empty, then
    - Let initValue be ? Call(initializer, receiver).
4. Else, let initValue be undefined.
5. If fieldName is a Private Name, then
    - Perform ? PrivateFieldAdd(receiver, fieldName, initValue).
6. Else,
    - Assert: IsPropertyKey(fieldName) is true.
    - Perform ? CreateDataPropertyOrThrow(receiver, fieldName, initValue).
7. Return unused.

    ä»¤fieldNameä¸ºfieldRecord.[[Name]]
    ä»¤initializerä¸ºfieldRecord.[[Initializer]]
    å¦‚æœinitializerä¸æ˜¯ç©ºï¼Œ
        ä»¤initValueä¸º?Call(initializer, receiver)
    å¦åˆ™ä»¤initializerä¸ºundefined
    å¦‚æœfieldNameæ˜¯ä¸€ä¸ªç§æœ‰åå­—ï¼Œ
        æ‰§è¡Œ?PrivateFieldAdd(receiver, fieldName, initValue)
    å¦åˆ™
        æ–­è¨€:!IsPropertyKey(fieldName)ä¸ºçœŸ
        æ‰§è¡Œ?CreateDataPropertyOrThrow(receiver, fieldName, initValue)

### 7.3.34 InitializeInstanceElements ( O, constructor )

æŠ½è±¡æ“ä½œ InitializeInstance Elements æ¥å—å‚æ•° OFï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰å’Œæ„é€ å‡½æ•°ï¼ˆan ECMAScript function objectï¼‰ã€‚ å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

1. Let methods be the value of constructor.[[PrivateMethods]].
2. For each PrivateElement method of methods, do
    - Perform ? PrivateMethodOrAccessorAdd(O, method).
3. Let fields be the value of constructor.[[Fields]].
4. For each element fieldRecord of fields, do
    - Perform ? DefineField(O, fieldRecord).
5. Return unused.


    ä»¤methodsä¸ºconstructor.[[PrivateMethods]]çš„å€¼
    å¾ªç¯methodsçš„PrivateElement methodï¼Œ
        æ‰§è¡Œ?PrivateMethodOrAccessorAdd(O, method)
    ä»¤fieldsä¸ºconstructor.[[Fields]]çš„å€¼
    å¾ªç¯fieldsä¸­çš„fieldRecordå…ƒç´ 
        æ‰§è¡Œ?DefineField(O, fieldRecord)