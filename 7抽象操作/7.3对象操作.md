### 7.3.1 MakeBasicObjectï¼ˆinternalSlotsListï¼‰

æŠ½è±¡æ“ä½œMakeBasicObjectæ¥å—å‚æ•°internalSlotsListã€‚å®ƒæ˜¯ç®—æ³•åˆ›å»ºçš„æ‰€æœ‰ECMAScriptå¯¹è±¡çš„æºï¼ŒåŒ…æ‹¬æ™®é€šå¯¹è±¡å’Œå¤–æ¥å¯¹è±¡ã€‚å®ƒå°†åˆ›å»ºæ‰€æœ‰å¯¹è±¡æ—¶ä½¿ç”¨çš„å¸¸è§æ­¥éª¤åˆ†è§£å‡ºæ¥ï¼Œå¹¶é›†ä¸­åˆ›å»ºå¯¹è±¡ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: internalSlotsList is a List of internal slot names.
    2.Let obj be a newly created object with an internal slot for each name in internalSlotsList.
    3.Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.
    4.Assert: If the caller will not be overriding both obj's [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then internalSlotsList contains [[Prototype]].
    5.Assert: If the caller will not be overriding all of obj's [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then internalSlotsList contains [[Extensible]].
    6.If internalSlotsList contains [[Extensible]], set obj.[[Extensible]] to true.
    7.Return obj.

    Assert:internalSlotsListæ˜¯å†…éƒ¨æ’æ§½åç§°çš„åˆ—è¡¨ã€‚

    åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡objï¼ŒinternalSlotsListä¸­çš„æ¯ä¸ªåç§°éƒ½æœ‰ä¸€ä¸ªå†…éƒ¨æ§½ã€‚

    å°†objçš„åŸºæœ¬å†…éƒ¨æ–¹æ³•è®¾ç½®ä¸º9.1ä¸­æŒ‡å®šçš„é»˜è®¤æ™®é€šå¯¹è±¡å®šä¹‰ã€‚

    Assertï¼šå¦‚æœè°ƒç”¨æ–¹ä¸ä¼šåŒæ—¶é‡å†™objçš„[[GetPrototypeOf]]å’Œ[[SetPrototypeOf]]åŸºæœ¬å†…éƒ¨æ–¹æ³•ï¼Œé‚£ä¹ˆinternalSlotsListåŒ…å«[[Prototype]]ã€‚

    æ–­è¨€ï¼šå¦‚æœè°ƒç”¨æ–¹ä¸ä¼šé‡å†™objçš„æ‰€æœ‰[[SetPrototypeOf]]ã€[[IsExtensible]]å’Œ[[PreventExtensions]]åŸºæœ¬å†…éƒ¨æ–¹æ³•ï¼Œåˆ™internalSlotsListåŒ…å«[[Extensible]]ã€‚

    å¦‚æœinternalSlotsListåŒ…å«[[Extensible]]ï¼Œè¯·å°†obj.[[Extensible]]è®¾ç½®ä¸ºtrueã€‚

    è¿”å› objã€‚

æ³¨æ„

åœ¨è¿™ä¸ªè§„èŒƒä¸­ï¼Œé€šè¿‡é¦–å…ˆè°ƒç”¨MakeBasicObjectè·å–åŸºæœ¬çš„åŸºç¡€å¯¹è±¡ï¼Œç„¶åé‡å†™è¯¥å¯¹è±¡çš„éƒ¨åˆ†æˆ–å…¨éƒ¨å†…éƒ¨æ–¹æ³•ï¼Œä»¥æŠ½è±¡æ“ä½œï¼ˆä¾‹å¦‚ArrayCreateå’ŒBoundFunctionCreateï¼‰åˆ›å»ºå¼‚ç±»å¯¹è±¡ã€‚ ä¸ºäº†å°è£…ç‰¹æ®Šå¯¹è±¡çš„åˆ›å»ºï¼Œæ°¸è¿œä¸è¦åœ¨è¿™äº›æ“ä½œä¹‹å¤–ä¿®æ”¹å¯¹è±¡çš„åŸºæœ¬å†…éƒ¨æ–¹æ³•ã€‚

### 7.3.2 Get ( O, P )

æŠ½è±¡æ“ä½œGetæ¥å—å‚æ•°OFï¼ˆan Objecï¼‰å’ŒPï¼ˆa property keyï¼‰ã€‚ å®ƒç”¨äºæ£€ç´¢å¯¹è±¡çš„ç‰¹å®šå±æ€§çš„å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Assert: IsPropertyKey(P) is true.
    Let O be ? ToObject(V).
    Return ? O.[[Get]](P, V).

### 7.3.3 GetV ( V, P )

æŠ½è±¡æ“ä½œGetVæ¥å—å‚æ•°Vï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’ŒPï¼ˆå±æ€§é”®ï¼‰ã€‚å®ƒç”¨äºæ£€ç´¢ECMAScriptè¯­è¨€å€¼çš„ç‰¹å®šå±æ€§çš„å€¼ã€‚å¦‚æœå€¼ä¸æ˜¯å¯¹è±¡ï¼Œåˆ™ä½¿ç”¨é€‚åˆè¯¥å€¼ç±»å‹çš„åŒ…è£…å¯¹è±¡æ‰§è¡Œå±æ€§æŸ¥æ‰¾ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Assert: IsPropertyKey(P) is true.
    Let O be ? ToObject(V).
    Return ? O.[[Get]](P, V).

### 7.3.4 Set ( O, P, V, Throw )

æŠ½è±¡æ“ä½œSetæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰ï¼ŒPï¼ˆå±æ€§é”®ï¼‰ï¼ŒVï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’ŒThrowï¼ˆå¸ƒå°”å€¼ï¼‰ã€‚ å®ƒç”¨äºè®¾ç½®å¯¹è±¡çš„ç‰¹å®šå±æ€§çš„å€¼ã€‚ Væ˜¯è¯¥å±æ€§çš„æ–°å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: Type(O) is Object.
    2.Assert: IsPropertyKey(P) is true.
    3.Assert: Type(Throw) is Boolean.
    4.Let success be ? O.[[Set]](P, V, O).
    5.If success is false and Throw is true, throw a TypeError exception.
    6.Return success.

### 7.3.5 CreateDataProperty ( O, P, V )

æŠ½è±¡æ“ä½œCreateDataPropertyæ¥å—å‚æ•°Oï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰ï¼ŒPï¼ˆä¸€ä¸ªå±æ€§é”®ï¼‰å’ŒVï¼ˆä¸€ä¸ªECMAScriptè¯­è¨€å€¼ï¼‰ã€‚ å®ƒç”¨äºåˆ›å»ºå¯¹è±¡çš„æ–°çš„è‡ªå·±çš„å±æ€§ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: Type(O) is Object.
    2.Assert: IsPropertyKey(P) is true.
    3.Let newDesc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
    4.Return ? O.[[DefineOwnProperty]](P, newDesc).
æ³¨æ„

æ­¤æŠ½è±¡æ“ä½œåˆ›å»ºä¸€ä¸ªå±æ€§ï¼Œè¯¥å±æ€§çš„å±æ€§è®¾ç½®ä¸ºä¸ECMAScriptè¯­è¨€èµ‹å€¼è¿ç®—ç¬¦åˆ›å»ºçš„å±æ€§ç›¸åŒçš„é»˜è®¤å€¼ã€‚é€šå¸¸ï¼Œè¯¥å±æ€§å°†ä¸å­˜åœ¨ã€‚å¦‚æœå®ƒç¡®å®å­˜åœ¨å¹¶ä¸”ä¸å¯é…ç½®ï¼Œæˆ–è€…Oä¸å¯æ‰©å±•ï¼Œ[[DefineOwnProperty]]å°†è¿”å›falseã€‚

### 7.3.6 CreateMethodProperty ( O, P, V )

æŠ½è±¡æ“ä½œCreateMethodPropertyæ¥å—å‚æ•°Oï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰ï¼ŒPï¼ˆä¸€ä¸ªå±æ€§é”®ï¼‰å’ŒVï¼ˆä¸€ä¸ªECMAScriptè¯­è¨€å€¼ï¼‰ã€‚ å®ƒç”¨äºåˆ›å»ºå¯¹è±¡çš„æ–°çš„è‡ªå·±çš„å±æ€§ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: Type(O) is Object.
    2.Assert: IsPropertyKey(P) is true.
    3.Let newDesc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
    4.Return ? O.[[DefineOwnProperty]](P, newDesc).

æ³¨æ„
æ­¤æŠ½è±¡æ“ä½œå°†åˆ›å»ºä¸€ä¸ªå±æ€§ï¼Œè¯¥å±æ€§çš„å±æ€§è®¾ç½®ä¸ºä¸å†…ç½®æ–¹æ³•å’Œä½¿ç”¨ç±»å£°æ˜è¯­æ³•å®šä¹‰çš„æ–¹æ³•ç›¸åŒçš„é»˜è®¤å€¼ã€‚ é€šå¸¸ï¼Œè¯¥å±æ€§å°†ä¸å­˜åœ¨ã€‚ å¦‚æœå®ƒç¡®å®å­˜åœ¨å¹¶ä¸”ä¸å¯é…ç½®ï¼Œæˆ–è€…Oä¸å¯æ‰©å±•ï¼Œåˆ™[[DefineOwnProperty]]å°†è¿”å›falseã€‚

### 7.3.7 CreateDataPropertyOrThrow ( O, P, V )

æŠ½è±¡æ“ä½œCreateDataPropertyOrThrowä½¿ç”¨å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰ï¼ŒPï¼ˆå±æ€§é”®ï¼‰å’ŒVï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ã€‚ å®ƒç”¨äºåˆ›å»ºå¯¹è±¡çš„æ–°çš„è‡ªå·±çš„å±æ€§ã€‚ å¦‚æœæ— æ³•æ‰§è¡Œè¯·æ±‚çš„å±æ€§æ›´æ–°ï¼Œåˆ™ä¼šå¼•å‘TypeErrorå¼‚å¸¸ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: Type(O) is Object.
    2.Assert: IsPropertyKey(P) is true.
    3.Let success be ? CreateDataProperty(O, P, V).
    4.If success is false, throw a TypeError exception.
    5.Return success.

æ³¨æ„
æ­¤æŠ½è±¡æ“ä½œå°†åˆ›å»ºä¸€ä¸ªå±æ€§ï¼Œè¯¥å±æ€§çš„å±æ€§è®¾ç½®ä¸ºä¸ECMAScriptè¯­è¨€åˆ†é…è¿ç®—ç¬¦åˆ›å»ºçš„å±æ€§æ‰€ä½¿ç”¨çš„é»˜è®¤å€¼ç›¸åŒçš„é»˜è®¤å€¼ã€‚ é€šå¸¸ï¼Œè¯¥å±æ€§å°†ä¸å­˜åœ¨ã€‚ å¦‚æœå®ƒç¡®å®å­˜åœ¨å¹¶ä¸”ä¸å¯é…ç½®ï¼Œæˆ–è€…Oæ˜¯ä¸å¯æ‰©å±•çš„ï¼Œåˆ™[[DefineOwnProperty]]å°†è¿”å›falseï¼Œå¯¼è‡´æ­¤æ“ä½œå¼•å‘TypeErrorå¼‚å¸¸ã€‚

### 7.3.8 DefinePropertyOrThrow ( O, P, desc )

æŠ½è±¡æ“ä½œDefinePropertyOrThrowæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰ï¼ŒPï¼ˆå±æ€§é”®ï¼‰å’Œdescï¼ˆå±æ€§æè¿°ç¬¦ï¼‰ã€‚ å®ƒç”¨äºä»¥æŸç§æ–¹å¼è°ƒç”¨å¯¹è±¡çš„[[DefineOwnProperty]]å†…éƒ¨æ–¹æ³•ï¼Œå¦‚æœæ— æ³•æ‰§è¡Œè¯·æ±‚çš„å±æ€§æ›´æ–°ï¼Œè¯¥æ–¹æ³•å°†å¼•å‘TypeErrorå¼‚å¸¸ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: Type(O) is Object.
    2.Assert: IsPropertyKey(P) is true.
    3.Let success be ? O.[[DefineOwnProperty]](P, desc).
    4.If success is false, throw a TypeError exception.
    5.Return success.

### 7.3.9 DeletePropertyOrThrow ( O, P )

æŠ½è±¡æ“ä½œDeletePropertyOrThrowå¸¦æœ‰å‚æ•°Oï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰å’ŒPï¼ˆä¸€ä¸ªå±æ€§é”®ï¼‰ã€‚ å®ƒç”¨äºåˆ é™¤å¯¹è±¡çš„ç‰¹å®šè‡ªèº«å±æ€§ã€‚ å¦‚æœè¯¥å±æ€§ä¸å¯é…ç½®ï¼Œå®ƒå°†å¼•å‘å¼‚å¸¸ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: Type(O) is Object.
    2.Assert: IsPropertyKey(P) is true.
    3.Let success be ? O.[[Delete]](P).
    4.If success is false, throw a TypeError exception.
    5.Return success.

### 7.3.10 GetMethod ( V, P )

æŠ½è±¡æ“ä½œGetMethodæ¥å—å‚æ•°Vï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’ŒPï¼ˆå±æ€§é”®ï¼‰ã€‚ å½“è¯¥å±æ€§çš„å€¼åº”ä¸ºå‡½æ•°æ—¶ï¼Œå¯ç”¨äºè·å–ECMAScriptè¯­è¨€å€¼çš„ç‰¹å®šå±æ€§çš„å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: IsPropertyKey(P) is true.
    2.Let func be ? GetV(V, P).
    3.If func is either undefined or null, return undefined.
    4.If IsCallable(func) is false, throw a TypeError exception.
    5.Return func.

### 7.3.11 HasProperty ( O, P )

æŠ½è±¡æ“ä½œHasPropertyæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰å’ŒPï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›å®Œæˆè®°å½•ï¼Œå¦‚æœè®°å½•çš„[[Type]]æ­£å¸¸ï¼Œåˆ™è¯¥è®°å½•å…·æœ‰å¸ƒå°”å€¼[[Value]]ã€‚ å®ƒç”¨äºç¡®å®šå¯¹è±¡æ˜¯å¦å…·æœ‰å¸¦æœ‰æŒ‡å®šå±æ€§é”®çš„å±æ€§ã€‚ è¯¥å±æ€§å¯ä»¥æ˜¯è‡ªå·±çš„æˆ–ç»§æ‰¿çš„ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: Type(O) is Object.
    2.Assert: IsPropertyKey(P) is true.
    3.Return ? O.[[HasProperty]](P).

### 7.3.12 HasOwnProperty ( O, P )

æŠ½è±¡æ“ä½œHasOwnPropertyæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰å’ŒPï¼ˆå±æ€§é”®ï¼‰å¹¶è¿”å›å®Œæˆè®°å½•ï¼Œå¦‚æœè®°å½•çš„[[Type]]æ­£å¸¸ï¼Œåˆ™è¯¥è®°å½•å…·æœ‰å¸ƒå°”å€¼[[Value]]ã€‚ å®ƒç”¨äºç¡®å®šå¯¹è±¡æ˜¯å¦å…·æœ‰å¸¦æœ‰æŒ‡å®šå±æ€§é”®çš„è‡ªå·±çš„å±æ€§ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: Type(O) is Object.
    2.Assert: IsPropertyKey(P) is true.
    3.Let desc be ? O.[[GetOwnProperty]](P).
    4.If desc is undefined, return false.
    5.Return true.

### 7.3.13 Call ( F, V [ , argumentsList ] )

æŠ½è±¡æ“ä½œCallæ¥å—å‚æ•°Fï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’ŒVï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰ä»¥åŠå¯é€‰å‚æ•°argumentsListï¼ˆECMAScriptè¯­è¨€å€¼åˆ—è¡¨ï¼‰ã€‚ å®ƒç”¨äºè°ƒç”¨å‡½æ•°å¯¹è±¡çš„[[Call]]å†…éƒ¨æ–¹æ³•ã€‚ Fæ˜¯å‡½æ•°å¯¹è±¡ï¼ŒVæ˜¯ECMAScriptè¯­è¨€å€¼ï¼Œå®ƒæ˜¯[[Call]]çš„thiså€¼ï¼ŒargumentsListæ˜¯ä¼ é€’ç»™å†…éƒ¨æ–¹æ³•çš„ç›¸åº”å‚æ•°çš„å€¼ã€‚ å¦‚æœargumentsListä¸å­˜åœ¨ï¼Œåˆ™å°†æ–°çš„ç©ºListç”¨ä½œå…¶å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    If argumentsList is not present, set argumentsList to a new empty List.
    If IsCallable(F) is false, throw a TypeError exception.
    Return ? F.[[Call]](V, argumentsList).

### 7.3.14 Construct ( F [ , argumentsList [ , newTarget ] ] )

æŠ½è±¡æ“ä½œConstructæ¥å—å‚æ•°Fï¼ˆå‡½æ•°å¯¹è±¡ï¼‰ä»¥åŠå¯é€‰å‚æ•°argumentsListå’ŒnewTargetã€‚ å®ƒç”¨äºè°ƒç”¨åŠŸèƒ½å¯¹è±¡çš„[[Construct]]å†…éƒ¨æ–¹æ³•ã€‚ argumentsListå’ŒnewTargetæ˜¯è¦ä½œä¸ºå†…éƒ¨æ–¹æ³•çš„ç›¸åº”å‚æ•°ä¼ é€’çš„å€¼ã€‚ å¦‚æœargumentsListä¸å­˜åœ¨ï¼Œåˆ™å°†æ–°çš„ç©ºListç”¨ä½œå…¶å€¼ã€‚ å¦‚æœnewTargetä¸å­˜åœ¨ï¼Œåˆ™Fç”¨ä½œå…¶å€¼ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    If newTarget is not present, set newTarget to F.
    If aumentsList is not present, set argumentsList to a new empty List.
    Assert: IsConstructor(F) is true.
    Assert: IsConstructor(newTarget) is true.
    Return ? F.[[Construct]](argumentsList, newTarget).

æ³¨æ„
å¦‚æœä¸å­˜åœ¨newTargetï¼Œåˆ™æ­¤æ“ä½œç­‰æ•ˆäºï¼šnew Fï¼ˆ... argumentsListï¼‰

### 7.3.15 SetIntegrityLevel ( O, level )

æŠ½è±¡æ“ä½œSetIntegrityLevelæ¥å—å‚æ•°Oå’Œlevelã€‚ å®ƒç”¨äºä¿®å¤å¯¹è±¡è‡ªå·±çš„å±æ€§é›†ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Assert: Type(O) is Object.
    Assert: level is either sealed or frozen.
    Let status be ? O.[[PreventExtensions]]().
    If status is false, return false.
    Let keys be ? O.[[OwnPropertyKeys]]().
    If level is sealed, then
    For each element k of keys, do
    Perform ? DefinePropertyOrThrow(O, k, PropertyDescriptor { [[Configurable]]: false }).
    Else,
    Assert: level is frozen.
    For each element k of keys, do
    Let currentDesc be ? O.[[GetOwnProperty]](k).
    If currentDesc is not undefined, then
    If IsAccessorDescriptor(currentDesc) is true, then
    Let desc be the PropertyDescriptor { [[Configurable]]: false }.
    Else,
    Let desc be the PropertyDescriptor { [[Configurable]]: false, [[Writable]]: false }.
    Perform ? DefinePropertyOrThrow(O, k, desc).
    Return true.

### 7.3.16 TestIntegrityLevel ( O, level )

æŠ½è±¡æ“ä½œtestintegritelevelæ¥å—å‚æ•°Oå’Œlevelã€‚å®ƒç”¨äºç¡®å®šå¯¹è±¡çš„è‡ªèº«å±æ€§é›†æ˜¯å¦å›ºå®šã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: Type(O) is Object.
    2.Assert: level is either sealed or frozen.
    3.Let extensible be ? IsExtensible(O).
    4.If extensible is true, return false.
    5.NOTE: If the object is extensible, none of its properties are examined.
    6.Let keys be ? O.[[OwnPropertyKeys]]().
    7.For each element k of keys, do
        Let currentDesc be ? O.[[GetOwnProperty]](k).
        If currentDesc is not undefined, then
            If currentDesc.[[Configurable]] is true, return false.
            If level is frozen and IsDataDescriptor(currentDesc) is true, then
                If currentDesc.[[Writable]] is true, return false.
    Return true.

### 7.3.17 CreateArrayFromList ( elements )

æŠ½è±¡æ“ä½œCreateArrayFromListæ¥å—å‚æ•°å…ƒç´ ï¼ˆä¸€ä¸ªåˆ—è¡¨ï¼‰ã€‚å®ƒç”¨äºåˆ›å»ºå…ƒç´ ç”±å…ƒç´ æä¾›çš„æ•°ç»„å¯¹è±¡ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: elements is a List whose elements are all ECMAScript language values.
    2.Let array be ! ArrayCreate(0).
    3.Let n be 0.
    4.For each element e of elements, do
        Perform ! CreateDataPropertyOrThrow(array, ! ToString(ğ”½(n)), e).
        Set n to n + 1.
    5.Return array.

### 7.3.18 LengthOfArrayLike ( obj )

æŠ½è±¡æ“ä½œLengthOfArrayLikeä½¿ç”¨å‚æ•°objã€‚ å®ƒè¿”å›ç±»ä¼¼æ•°ç»„çš„å¯¹è±¡çš„â€œ lengthâ€å±æ€§çš„å€¼ï¼ˆä½œä¸ºéè´Ÿæ•´æ•°ï¼‰ã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    1.Assert: Type(obj) is Object.
    2.Return â„(? ToLength(? Get(obj, "length"))).

ç±»æ•°ç»„å¯¹è±¡æ˜¯è¯¥æ“ä½œä¸ºå…¶è¿”å›æ•´æ•°è€Œä¸æ˜¯çªç„¶å®Œæˆçš„ä»»ä½•å¯¹è±¡ã€‚

æ³¨1
é€šå¸¸ï¼Œç±»ä¼¼æ•°ç»„çš„å¯¹è±¡è¿˜å°†å…·æœ‰ä¸€äº›å¸¦æœ‰æ•´æ•°ç´¢å¼•åç§°çš„å±æ€§ã€‚ ä½†æ˜¯ï¼Œè¿™ä¸æ˜¯æ­¤å®šä¹‰çš„è¦æ±‚ã€‚
æ³¨2
æ•°ç»„å¯¹è±¡å’ŒStringå¯¹è±¡æ˜¯ç±»æ•°ç»„å¯¹è±¡çš„ç¤ºä¾‹ã€‚

### 7.3.19 CreateListFromArrayLike ( obj [ , elementTypes ] )

æŠ½è±¡æ“ä½œCreateListFromArrayLikeæ¥å—å‚æ•°objå’Œå¯é€‰å‚æ•°elementTypesï¼ˆECMAScriptè¯­è¨€ç±»å‹çš„åç§°åˆ—è¡¨ï¼‰ã€‚å®ƒç”¨äºåˆ›å»ºä¸€ä¸ªåˆ—è¡¨å€¼ï¼Œå…¶å…ƒç´ ç”±objçš„ç´¢å¼•å±æ€§æä¾›ã€‚elementTypesåŒ…å«åˆ›å»ºçš„åˆ—è¡¨çš„å…ƒç´ å€¼å…è®¸ä½¿ç”¨çš„ECMAScriptè¯­è¨€ç±»å‹çš„åç§°ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    If elementTypes is not present, set elementTypes to Â« Undefined, Null, Boolean, String, Symbol, Number, BigInt, Object Â».
    If Type(obj) is not Object, throw a TypeError exception.
    Let len be ? LengthOfArrayLike(obj).
    Let list be a new empty List.
    Let index be 0.
    Repeat, while index < len,
        Let indexName be ! ToString(ğ”½(index)).
        Let next be ? Get(obj, indexName).
        If Type(next) is not an element of elementTypes, throw a TypeError exception.
        Append next as the last element of list.
        Set index to index + 1.
    Return list.

### 7.3.20 Invoke ( V, P [ , argumentsList ] )

æŠ½è±¡æ“ä½œInvokeæ¥å—å‚æ•°Vï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’ŒPï¼ˆå±æ€§é”®ï¼‰ä»¥åŠå¯é€‰å‚æ•°argumentsListï¼ˆECMAScriptè¯­è¨€å€¼çš„åˆ—è¡¨ï¼‰ã€‚å®ƒç”¨äºè°ƒç”¨ECMAScriptè¯­è¨€å€¼çš„æ–¹æ³•å±æ€§ã€‚VåŒæ—¶å……å½“å±æ€§å’Œè°ƒç”¨çš„thiså€¼çš„æŸ¥æ‰¾ç‚¹ã€‚argumentsListæ˜¯ä¼ é€’ç»™æ–¹æ³•çš„å‚æ•°å€¼çš„åˆ—è¡¨ã€‚å¦‚æœargumentsListä¸å­˜åœ¨ï¼Œåˆ™ä½¿ç”¨æ–°çš„ç©ºåˆ—è¡¨ä½œä¸ºå…¶å€¼ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Assert: IsPropertyKey(P) is true.
    If argumentsList is not present, set argumentsList to a new empty List.
    Let func be ? GetV(V, P).
    Return ? Call(func, V, argumentsList).

### 7.3.21 OrdinaryHasInstance ( C, O )

æŠ½è±¡æ“ä½œOrdinaryHasInstanceé‡‡ç”¨å‚æ•°Cï¼ˆECMAScriptè¯­è¨€å€¼ï¼‰å’ŒOã€‚å®ƒå®ç°ç”¨äºç¡®å®šOæ˜¯å¦ä»Cæä¾›çš„å®ä¾‹å¯¹è±¡ç»§æ‰¿è·¯å¾„ç»§æ‰¿çš„é»˜è®¤ç®—æ³•ã€‚åœ¨è°ƒç”¨æ—¶ï¼Œå®ƒæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    If IsCallable(C) is false, return false.
    If C has a [[BoundTargetFunction]] internal slot, then
        Let BC be C.[[BoundTargetFunction]].
        Return ? InstanceofOperator(O, BC).
    If Type(O) is not Object, return false.
    Let P be ? Get(C, "prototype").
    If Type(P) is not Object, throw a TypeError exception.
    Repeat,
        Set O to ? O.[[GetPrototypeOf]]().
        If O is null, return false.
        If SameValue(P, O) is true, return true.

### 7.3.22 SpeciesConstructor ( O, defaultConstructor )

æŠ½è±¡æ“ä½œSpeciesConstructoræ¥å—å‚æ•°Oï¼ˆä¸€ä¸ªå¯¹è±¡ï¼‰å’ŒdefaultConstructorï¼ˆä¸€ä¸ªæ„é€ å‡½æ•°ï¼‰ã€‚ å®ƒç”¨äºæ£€ç´¢åº”ç”¨äºåˆ›å»ºä»Oæ´¾ç”Ÿçš„æ–°å¯¹è±¡çš„æ„é€ å‡½æ•°ã€‚defaultConstructoræ˜¯åœ¨æ— æ³•ä»Oå¼€å§‹æ‰¾åˆ°æ„é€ å‡½æ•°@@ specieså±æ€§çš„æƒ…å†µä¸‹ä½¿ç”¨çš„æ„é€ å‡½æ•°ã€‚è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Assert: Type(O) is Object.
    Let C be ? Get(O, "constructor").
    If C is undefined, return defaultConstructor.
    If Type(C) is not Object, throw a TypeError exception.
    Let S be ? Get(C, @@species).
    If S is either undefined or null, return defaultConstructor.
    If IsConstructor(S) is true, return S.
    Throw a TypeError exception.

### 7.3.23 EnumerableOwnPropertyNames ( O, kind )
æŠ½è±¡æ“ä½œEnumerableOwnPropertyNamesæ¥å—å‚æ•°Oï¼ˆå¯¹è±¡ï¼‰å’Œkindï¼ˆkeyã€valueæˆ–key+valueä¹‹ä¸€ï¼‰ã€‚å®ƒåœ¨è°ƒç”¨æ—¶æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Assert: Type(O) is Object.
    Let ownKeys be ? O.[[OwnPropertyKeys]]().
    Let properties be a new empty List.
    For each element key of ownKeys, do
        If Type(key) is String, then
            Let desc be ? O.[[GetOwnProperty]](key).
            If desc is not undefined and desc.[[Enumerable]] is true, then
                If kind is key, append key to properties.
                Else,
                    Let value be ? Get(O, key).
                    If kind is value, append value to properties.
                    Else,
                        Assert: kind is key+value.
                        Let entry be ! CreateArrayFromList(Â« key, value Â»).
                        Append entry to properties.
    Return properties.

### 7.3.24 GetFunctionRealm ( obj )

æŠ½è±¡æ“ä½œGetFunctionRealmä½¿ç”¨å‚æ•°objã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Assert: ! IsCallable(obj) is true.
    If obj has a [[Realm]] internal slot, then
        Return obj.[[Realm]].
    If obj is a bound function exotic object, then
        Let target be obj.[[BoundTargetFunction]].
        Return ? GetFunctionRealm(target).
    If obj is a Proxy exotic object, then
        If obj.[[ProxyHandler]] is null, throw a TypeError exception.
        Let proxyTarget be obj.[[ProxyTarget]].
        Return ? GetFunctionRealm(proxyTarget).
    Return the current Realm Record.

æ³¨æ„

åªæœ‰å½“objæ˜¯ä¸€ä¸ªæ²¡æœ‰[[Realm]]å†…éƒ¨æ§½çš„éæ ‡å‡†å‡½æ•°å¤–æ¥å¯¹è±¡æ—¶ï¼Œæ‰èƒ½æ‰§è¡Œç¬¬5æ­¥ã€‚

### 7.3.25 CopyDataProperties ( target, source, excludedItems )

æŠ½è±¡æ“ä½œCopyDataPropertiesä½¿ç”¨å‚æ•°targetï¼Œsourceå’ŒexcludeItemsã€‚ è°ƒç”¨æ—¶ï¼Œå®ƒå°†æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

    Assert: Type(target) is Object.
    Assert: excludedItems is a List of property keys.
    If source is undefined or null, return target.
    Let from be ! ToObject(source).
    Let keys be ? from.[[OwnPropertyKeys]]().
    For each element nextKey of keys, do
        Let excluded be false.
        For each element e of excludedItems, do
            If SameValue(e, nextKey) is true, then
                Set excluded to true.
        If excluded is false, then
            Let desc be ? from.[[GetOwnProperty]](nextKey).
            If desc is not undefined and desc.[[Enumerable]] is true, then
                Let propValue be ? Get(from, nextKey).
                Perform ! CreateDataPropertyOrThrow(target, nextKey, propValue).
    Return target.
æ³¨æ„

è¿™é‡Œä¼ é€’çš„ç›®æ ‡æ€»æ˜¯ä¸€ä¸ªæ–°åˆ›å»ºçš„å¯¹è±¡ï¼Œåœ¨å‘ç”Ÿé”™è¯¯æ—¶ä¸èƒ½ç›´æ¥è®¿é—®è¯¥å¯¹è±¡ã€‚