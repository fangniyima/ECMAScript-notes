
## 8.3 Labels

### 8.2.1 Static Semantics: ContainsDuplicateLabels(ÂåÖÂê´‰∏§‰∏™Ê†áÁ≠æ)

ËØ≠Ê≥ïÂà∂ÂØºÁöÑÊìç‰Ωú ContainsDuplicateLabels ÈááÁî®ÂèÇÊï∞ labelSet„ÄÇ ÂÆÉÂú®‰ª•‰∏ã‰∫ßÁîüÂºè‰∏äÂàÜÊÆµÂÆö‰πâÔºö

Statement :
VariableStatement
EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement
Block :
{ }
StatementListItem :
Declaration
1. Return false.
StatementList : StatementList StatementListItem
1. Let hasDuplicates be ContainsDuplicateLabels of StatementList with argument labelSet.
2. If hasDuplicates is true, return true.
3. Return ContainsDuplicateLabels of StatementListItem with argument labelSet.
IfStatement : if ( Expression ) Statement else Statement
1. Let hasDuplicate be ContainsDuplicateLabels of the first Statement with argument labelSet.
2. If hasDuplicate is true, return true.
3. Return ContainsDuplicateLabels of the second Statement with argument labelSet.
IfStatement : if ( Expression ) Statement
1. Return ContainsDuplicateLabels of Statement with argument labelSet.
DoWhileStatement : do Statement while ( Expression ) ;
1. Return ContainsDuplicateLabels of Statement with argument labelSet.
WhileStatement : while ( Expression ) Statement
1. Return ContainsDuplicateLabels of Statement with argument labelSet.
ForStatement :
for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement
for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement
for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement
1. Return ContainsDuplicateLabels of Statement with argument labelSet.
ForInOfStatement :
for ( LeftHandSideExpression in Expression ) Statement
for ( var ForBinding in Expression ) Statement
for ( ForDeclaration in Expression ) Statement
for ( LeftHandSideExpression of AssignmentExpression ) Statement
for ( var ForBinding of AssignmentExpression ) Statement
for ( ForDeclaration of AssignmentExpression ) Statement
for await ( LeftHandSideExpression of AssignmentExpression ) Statement
for await ( var ForBinding of AssignmentExpression ) Statement
for await ( ForDeclaration of AssignmentExpression ) Statement
1. Return ContainsDuplicateLabels of Statement with argument labelSet.

>NOTE Êú¨ËäÇÁî±ÈôÑÂΩïB.3.5Êâ©Â±ï„ÄÇ

WithStatement : with ( Expression ) Statement
1. Return ContainsDuplicateLabels of Statement with argument labelSet.
SwitchStatement : switch ( Expression ) CaseBlock
1. Return ContainsDuplicateLabels of CaseBlock with argument labelSet.
CaseBlock : { }
1. Return false.
CaseBlock : { CaseClausesopt DefaultClause CaseClausesopt }
1. If the first CaseClauses is present, then
a. If ContainsDuplicateLabels of the first CaseClauses with argument labelSet is true, return true.
2. If ContainsDuplicateLabels of DefaultClause with argument labelSet is true, return true.
3. If the second CaseClauses is not present, return false.
4. Return ContainsDuplicateLabels of the second CaseClauses with argument labelSet.
CaseClauses : CaseClauses CaseClause
1. Let hasDuplicates be ContainsDuplicateLabels of CaseClauses with argument labelSet.
2. If hasDuplicates is true, return true.
3. Return ContainsDuplicateLabels of CaseClause with argument labelSet.
CaseClause : case Expression : StatementListopt
1. If the StatementList is present, return ContainsDuplicateLabels of StatementList with argument labelSet.
2. Return false.
DefaultClause : default : StatementListopt
1. If the StatementList is present, return ContainsDuplicateLabels of StatementList with argument labelSet.
2. Return false.
LabelledStatement : LabelIdentifier : LabelledItem
1. Let label be the StringValue of LabelIdentifier.
2. If label is an element of labelSet, return true.
3. Let newLabelSet be the list-concatenation of labelSet and ¬´ label ¬ª.
4. Return ContainsDuplicateLabels of LabelledItem with argument newLabelSet.
LabelledItem : FunctionDeclaration
1. Return false.
TryStatement : try Block Catch
1. Let hasDuplicates be ContainsDuplicateLabels of Block with argument labelSet.
2. If hasDuplicates is true, return true.
3. Return ContainsDuplicateLabels of Catch with argument labelSet.
TryStatement : try Block Finally
1. Let hasDuplicates be ContainsDuplicateLabels of Block with argument labelSet.
2. If hasDuplicates is true, return true.
3. Return ContainsDuplicateLabels of Finally with argument labelSet.
TryStatement : try Block Catch Finally
1. If ContainsDuplicateLabels of Block with argument labelSet is true, return true.
2. If ContainsDuplicateLabels of Catch with argument labelSet is true, return true.
3. Return ContainsDuplicateLabels of Finally with argument labelSet.
Catch : catch ( CatchParameter ) Block
1. Return ContainsDuplicateLabels of Block with argument labelSet.
FunctionStatementList : [empty]
1. Return false.
ClassStaticBlockStatementList : [empty]
1. Return false.
ModuleItemList : ModuleItemList ModuleItem
1. Let hasDuplicates be ContainsDuplicateLabels of ModuleItemList with argument labelSet.
2. If hasDuplicates is true, return true.
3. Return ContainsDuplicateLabels of ModuleItem with argument labelSet.
ModuleItem :
ImportDeclaration
ExportDeclaratio
1. Return false.

### 8.2.2 Static Semantics: ContainsUndefinedBreakTarget

ËØ≠Ê≥ïÂà∂ÂØºÁöÑÊìç‰Ωú ContainsUndefinedBreakTarget ÈááÁî®ÂèÇÊï∞ labelSet„ÄÇ ÂÆÉÂú®‰ª•‰∏ã‰∫ßÁîüÂºè‰∏äÂàÜÊÆµÂÆö‰πâÔºö

Statement :
VariableStatement
EmptyStatement
ExpressionStatement
ContinueStatement
ReturnStatement
ThrowStatement
DebuggerStatement
Block :
{ }
StatementListItem :
Declaration
1. Return false.
StatementList : StatementList StatementListItem
1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of StatementList with argument labelSet.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedBreakTarget of StatementListItem with argument labelSet.
IfStatement : if ( Expression ) Statement else Statement
1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of the first Statement with argument labelSet.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedBreakTarget of the second Statement with argument labelSet.
IfStatement : if ( Expression ) Statement
1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
DoWhileStatement : do Statement while ( Expression ) ;
1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
WhileStatement : while ( Expression ) Statement
1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
ForStatement :
for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement
for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement
for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement
1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
ForInOfStatement :
for ( LeftHandSideExpression in Expression ) Statement
for ( var ForBinding in Expression ) Statement
for ( ForDeclaration in Expression ) Statement
for ( LeftHandSideExpression of AssignmentExpression ) Statement
for ( var ForBinding of AssignmentExpression ) Statement
for ( ForDeclaration of AssignmentExpression ) Statement
for await ( LeftHandSideExpression of AssignmentExpression ) Statement
for await ( var ForBinding of AssignmentExpression ) Statement
for await ( ForDeclaration of AssignmentExpression ) Statement
1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.

>NOTE Êú¨ËäÇÁî±ÈôÑÂΩïB.3.5Êâ©Â±ï„ÄÇ

BreakStatement : break ;
1. Return false.
BreakStatement : break LabelIdentifier ;
1. If the StringValue of LabelIdentifier is not an element of labelSet, return true.
2. Return false.
WithStatement : with ( Expression ) Statement
1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
SwitchStatement : switch ( Expression ) CaseBlock
1. Return ContainsUndefinedBreakTarget of CaseBlock with argument labelSet.
CaseBlock : { }
1. Return false.
CaseBlock : { CaseClausesopt DefaultClause CaseClausesopt }
1. If the first CaseClauses is present, then
a. If ContainsUndefinedBreakTarget of the first CaseClauses with argument labelSet is true, return true.
2. If ContainsUndefinedBreakTarget of DefaultClause with argument labelSet is true, return true.
3. If the second CaseClauses is not present, return false.
4. Return ContainsUndefinedBreakTarget of the second CaseClauses with argument labelSet.
CaseClauses : CaseClauses CaseClause
1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of CaseClauses with argument labelSet.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedBreakTarget of CaseClause with argument labelSet.
CaseClause : case Expression : StatementListopt
1. If the StatementList is present, return ContainsUndefinedBreakTarget of StatementList with argument labelSet.
2. Return false.
DefaultClause : default : StatementListopt
1. If the StatementList is present, return ContainsUndefinedBreakTarget of StatementList with argument labelSet.
2. Return false.
LabelledStatement : LabelIdentifier : LabelledItem
1. Let label be the StringValue of LabelIdentifier.
2. Let newLabelSet be the list-concatenation of labelSet and ¬´ label ¬ª.
3. Return ContainsUndefinedBreakTarget of LabelledItem with argument newLabelSet.
LabelledItem : FunctionDeclaration
1. Return false.
TryStatement : try Block Catch
1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of Block with argument labelSet.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedBreakTarget of Catch with argument labelSet.
TryStatement : try Block Finally
1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of Block with argument labelSet.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedBreakTarget of Finally with argument labelSet.
TryStatement : try Block Catch Finally
1. If ContainsUndefinedBreakTarget of Block with argument labelSet is true, return true.
2. If ContainsUndefinedBreakTarget of Catch with argument labelSet is true, return true.
3. Return ContainsUndefinedBreakTarget of Finally with argument labelSet.
Catch : catch ( CatchParameter ) Block
1. Return ContainsUndefinedBreakTarget of Block with argument labelSet.
FunctionStatementList : [empty]
1. Return false.
ClassStaticBlockStatementList : [empty]
1. Return false.
ModuleItemList : ModuleItemList ModuleItem
1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of ModuleItemList with argument labelSet.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedBreakTarget of ModuleItem with argument labelSet.
ModuleItem :
ImportDeclaration
ExportDeclaration
1. Return false.

### 8.2.3 Static Semantics: ContainsUndefinedContinueTarget

ËØ≠Ê≥ïÂà∂ÂØºÁöÑÊìç‰Ωú ContainsUndefinedContinueTarget ÈááÁî®ÂèÇÊï∞Ëø≠‰ª£ÈõÜÂíåÊ†áÁ≠æÈõÜ„ÄÇ ÂÆÉÂú®‰ª•‰∏ã‰∫ßÁîüÂºè‰∏äÂàÜÊÆµÂÆö‰πâÔºö

Statement :
VariableStatement
EmptyStatement
ExpressionStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement
Block :
{ }
StatementListItem :
Declaration
1. Return false.
Statement : BlockStatement
1. Return ContainsUndefinedContinueTarget of BlockStatement with arguments iterationSet and ¬´ ¬ª.
BreakableStatement : IterationStatement
1. Let newIterationSet be the list-concatenation of iterationSet and labelSet.
2. Return ContainsUndefinedContinueTarget of IterationStatement with arguments newIterationSet and ¬´ ¬ª.
StatementList : StatementList StatementListItem
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of StatementList with arguments iterationSet and ¬´ ¬ª.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedContinueTarget of StatementListItem with arguments iterationSet and ¬´ ¬ª.
IfStatement : if ( Expression ) Statement else Statement
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of the first Statement with arguments iterationSet and ¬´ ¬ª.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedContinueTarget of the second Statement with arguments iterationSet and ¬´ ¬ª.
IfStatement : if ( Expression ) Statement
1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and ¬´ ¬ª.
DoWhileStatement : do Statement while ( Expression ) ;
1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and ¬´ ¬ª.
WhileStatement : while ( Expression ) Statement
1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and ¬´ ¬ª.
ForStatement :
for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement
for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement
for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement
1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and ¬´ ¬ª.
ForInOfStatement :
for ( LeftHandSideExpression in Expression ) Statement
for ( var ForBinding in Expression ) Statement
for ( ForDeclaration in Expression ) Statement
for ( LeftHandSideExpression of AssignmentExpression ) Statement
for ( var ForBinding of AssignmentExpression ) Statement
for ( ForDeclaration of AssignmentExpression ) Statement
for await ( LeftHandSideExpression of AssignmentExpression ) Statement
for await ( var ForBinding of AssignmentExpression ) Statement
for await ( ForDeclaration of AssignmentExpression ) Statement
1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and ¬´ ¬ª.

>NOTE Êú¨ËäÇÁî±ÈôÑÂΩïB.3.5Êâ©Â±ï„ÄÇ

ContinueStatement : continue ;
1. Return false.
ContinueStatement : continue LabelIdentifier ;
1. If the StringValue of LabelIdentifier is not an element of iterationSet, return true.
2. Return false.
WithStatement : with ( Expression ) Statement
1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and ¬´ ¬ª.
SwitchStatement : switch ( Expression ) CaseBlock
1. Return ContainsUndefinedContinueTarget of CaseBlock with arguments iterationSet and ¬´ ¬ª.
CaseBlock : { }
1. Return false.
CaseBlock : { CaseClausesopt DefaultClause CaseClausesopt }
1. If the first CaseClauses is present, then
a. If ContainsUndefinedContinueTarget of the first CaseClauses with arguments iterationSet and ¬´ ¬ª is true, return true.
2. If ContainsUndefinedContinueTarget of DefaultClause with arguments iterationSet and ¬´ ¬ª is true, return true.
3. If the second CaseClauses is not present, return false.
4. Return ContainsUndefinedContinueTarget of the second CaseClauses with arguments iterationSet and ¬´ ¬ª.
CaseClauses : CaseClauses CaseClause
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of CaseClauses with arguments iterationSet and ¬´ ¬ª.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedContinueTarget of CaseClause with arguments iterationSet and ¬´ ¬ª.
CaseClause : case Expression : StatementListopt
1. If the StatementList is present, return ContainsUndefinedContinueTarget of StatementList with arguments iterationSet and ¬´ ¬ª.
2. Return false.
DefaultClause : default : StatementListopt
1. If the StatementList is present, return ContainsUndefinedContinueTarget of StatementList with arguments iterationSet and ¬´ ¬ª.
2. Return false.
LabelledStatement : LabelIdentifier : LabelledItem
1. Let label be the StringValue of LabelIdentifier.
2. Let newLabelSet be the list-concatenation of labelSet and ¬´ label ¬ª.
3. Return ContainsUndefinedContinueTarget of LabelledItem with arguments iterationSet and newLabelSet.
LabelledItem : FunctionDeclaration
1. Return false.
TryStatement : try Block Catch
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of Block with arguments iterationSet and ¬´ ¬ª.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedContinueTarget of Catch with arguments iterationSet and ¬´ ¬ª.
TryStatement : try Block Finally
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of Block with arguments iterationSet and ¬´ ¬ª.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedContinueTarget of Finally with arguments iterationSet and ¬´ ¬ª.
TryStatement : try Block Catch Finally
1. If ContainsUndefinedContinueTarget of Block with arguments iterationSet and ¬´ ¬ª is true, return true.
2. If ContainsUndefinedContinueTarget of Catch with arguments iterationSet and ¬´ ¬ª is true, return true.
3. Return ContainsUndefinedContinueTarget of Finally with arguments iterationSet and ¬´ ¬ª.
Catch : catch ( CatchParameter ) Block
1. Return ContainsUndefinedContinueTarget of Block with arguments iterationSet and ¬´ ¬ª.
FunctionStatementList : [empty]
1. Return false.
ClassStaticBlockStatementList : [empty]
1. Return false.
ModuleItemList : ModuleItemList ModuleItem
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of ModuleItemList with arguments iterationSet and ¬´ ¬ª.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedContinueTarget of ModuleItem with arguments iterationSet and ¬´ ¬ª.
ModuleItem :
ImportDeclaration
ExportDeclaration
1. Return false.

## 8.4 Function Name Inference(ÂáΩÊï∞ÂêçÊé®Êñ≠)

### 8.3.1 Static Semantics: HasName

ËØ≠Ê≥ïÂà∂ÂØºÁöÑÊìç‰Ωú HasName Ê≤°ÊúâÂèÇÊï∞„ÄÇ ÂÆÉÂú®‰ª•‰∏ã‰∫ßÁîüÂºè‰∏äÂàÜÊÆµÂÆö‰πâÔºö

```
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. Let expr be the ParenthesizedExpression that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. If IsFunctionDefinition of expr is false, return false.
3. Return HasName of expr.

FunctionExpression :
    function ( FormalParameters ) { FunctionBody }
GeneratorExpression :
    function * ( FormalParameters ) { GeneratorBody }
AsyncGeneratorExpression :
    async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionExpression :
    async function ( FormalParameters ) { AsyncFunctionBody }
ArrowFunction :
    ArrowParameters => ConciseBody
AsyncArrowFunction :
    async AsyncArrowBindingIdentifier => AsyncConciseBody
    CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
ClassExpression :
    class ClassTail
1. Return false.

FunctionExpression :
    function BindingIdentifier ( FormalParameters ) { FunctionBody }
GeneratorExpression :
    function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
AsyncGeneratorExpression :
    async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionExpression :
    async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
ClassExpression :
    class BindingIdentifier ClassTail
1. Return true.
```

### 8.3.2 Static Semantics: IsFunctionDefinition

ËØ≠Ê≥ïÂà∂ÂØºÁöÑÊìç‰Ωú IsFunctionDefinition ‰∏çÂ∏¶‰ªª‰ΩïÂèÇÊï∞„ÄÇ ÂÆÉÂú®‰ª•‰∏ã‰∫ßÁîüÂºè‰∏äÂàÜÊÆµÂÆö‰πâÔºö

```
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. Let expr be the ParenthesizedExpression that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. Return IsFunctionDefinition of expr.
PrimaryExpression :
this
IdentifierReference
Literal
ArrayLiteral
ObjectLiteral
RegularExpressionLiteral
TemplateLiteral
MemberExpression :
MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression TemplateLiteral
SuperProperty
MetaProperty
new MemberExpression Arguments
MemberExpression . PrivateIdentifier
NewExpression :
new NewExpression
LeftHandSideExpression :
CallExpression
OptionalExpression
UpdateExpression :
LeftHandSideExpression ++
LeftHandSideExpression --
++ UnaryExpression
-- UnaryExpression
UnaryExpression :
delete UnaryExpression
void UnaryExpression
typeof UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression
AwaitExpression
ExponentiationExpression :
UpdateExpression ** ExponentiationExpression
MultiplicativeExpression :
MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
AdditiveExpression :
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression
ShiftExpression :
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression
RelationalExpression :
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression instanceof ShiftExpression
RelationalExpression in ShiftExpression
PrivateIdentifier in ShiftExpression
EqualityExpression :
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression
BitwiseANDExpression :
BitwiseANDExpression & EqualityExpression
BitwiseXORExpression :
BitwiseXORExpression ^ BitwiseANDExpression
BitwiseORExpression :
BitwiseORExpression | BitwiseXORExpression
LogicalANDExpression :
LogicalANDExpression && BitwiseORExpression
LogicalORExpression :
LogicalORExpression || LogicalANDExpression
CoalesceExpression :
CoalesceExpressionHead ?? BitwiseORExpression
ConditionalExpression :
ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
AssignmentExpression :
YieldExpression
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression
LeftHandSideExpression &&= AssignmentExpression
LeftHandSideExpression ||= AssignmentExpression
LeftHandSideExpression ??= AssignmentExpression
Expression :
Expression , AssignmentExpression
1. Return false.
AssignmentExpression :
ArrowFunction
AsyncArrowFunction
FunctionExpression :
function BindingIdentifieropt ( FormalParameters ) { FunctionBody }
GeneratorExpression :
function * BindingIdentifieropt ( FormalParameters ) { GeneratorBody }
AsyncGeneratorExpression :
async function * BindingIdentifieropt ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionExpression :
async function BindingIdentifieropt ( FormalParameters ) { AsyncFunctionBody }
ClassExpression :
class BindingIdentifieropt ClassTail
1. Return true.
```

### 8.3.3 Static Semantics: IsAnonymousFunctionDefinition ( expr )

ÊäΩË±°Êìç‰Ωú IsAnonymousFunctionDefinition ÈááÁî®ÂèÇÊï∞ exprÔºàAssignmentExpression Parse Node Êàñ Initializer Parse NodeÔºâ„ÄÇ ÂÆÉÁ°ÆÂÆöÂÖ∂ÂèÇÊï∞ÊòØÂê¶ÊòØ‰∏çÁªëÂÆöÂêçÁß∞ÁöÑÂáΩÊï∞ÂÆö‰πâ„ÄÇ ÂÆÉÂú®Ë∞ÉÁî®Êó∂ÊâßË°å‰ª•‰∏ãÊ≠•È™§Ôºö

1. If IsFunctionDefinition of expr is false, return false.
2. Let hasName be HasName of expr.
3. If hasName is true, return false.
4. Return true.


### 8.3.4 Static Semantics: IsIdentifierRef

ËØ≠Ê≥ïÂà∂ÂØºÁöÑÊìç‰Ωú IsIdentifierRef ‰∏çÊé•Âèó‰ªª‰ΩïÂèÇÊï∞„ÄÇ ÂÆÉÂú®‰ª•‰∏ã‰∫ßÁîüÂºè‰∏äÂàÜÊÆµÂÆö‰πâÔºö

```
PrimaryExpression : IdentifierReference
1. Return true.
PrimaryExpression :
this
Literal
ArrayLiteral
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
AsyncFunctionExpression
AsyncGeneratorExpression
RegularExpressionLiteral
TemplateLiteral
CoverParenthesizedExpressionAndArrowParameterList
MemberExpression :
MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression TemplateLiteral
SuperProperty
MetaProperty
new MemberExpression Arguments
MemberExpression . PrivateIdentifier
NewExpression :
new NewExpression
LeftHandSideExpression :
CallExpression
OptionalExpression
1. Return false.
```

### 8.3.5 Runtime Semantics: NamedEvaluation

ËØ≠Ê≥ïÂØºÂêëÁöÑÊìç‰ΩúnameDeverationÈááÁî®ÂèÇÊï∞name„ÄÇÂÆÉÊòØÂú®‰ª•‰∏ã‰∫ßÂìÅ‰∏äÂàÜÊÆµÂÆö‰πâÁöÑÔºö

PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. Let expr be the ParenthesizedExpression that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. Return the result of performing NamedEvaluation of expr with argument name.
ParenthesizedExpression : ( Expression )
1. Assert: IsAnonymousFunctionDefinition(Expression) is true.
2. Return the result of performing NamedEvaluation of Expression with argument name.
FunctionExpression : function ( FormalParameters ) { FunctionBody }
1. Return InstantiateOrdinaryFunctionExpression of FunctionExpression with argument name.
GeneratorExpression : function * ( FormalParameters ) { GeneratorBody }
1. Return InstantiateGeneratorFunctionExpression of GeneratorExpression with argument name.
AsyncGeneratorExpression : async function * ( FormalParameters ) { AsyncGeneratorBody }
1. Return InstantiateAsyncGeneratorFunctionExpression of AsyncGeneratorExpression with argument name.
AsyncFunctionExpression : async function ( FormalParameters ) { AsyncFunctionBody }
1. Return InstantiateAsyncFunctionExpression of AsyncFunctionExpression with argument name.
ArrowFunction : ArrowParameters => ConciseBody
1. Return InstantiateArrowFunctionExpression of ArrowFunction with argument name.
AsyncArrowFunction :
async AsyncArrowBindingIdentifier => AsyncConciseBody
CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
1. Return InstantiateAsyncArrowFunctionExpression of AsyncArrowFunction with argument name.
ClassExpression : class ClassTail
1. Let value be the result of ClassDefinitionEvaluation of ClassTail with arguments undefined and name.
2. ReturnIfAbrupt(value).
3. Set value.[[SourceText]] to the source text matched by ClassExpression.
4. Return value.

## 8.4 Contains

### 8.4.1 Static Semantics: Contains

ËØ≠Ê≥ïÂà∂ÂØºÁöÑÊìç‰ΩúÂåÖÂê´takesÂèÇÊï∞Á¨¶Âè∑„ÄÇ

Êú¨ËßÑËåÉ‰∏≠Êú™Âú®‰∏ãÈù¢ÂàóÂá∫ÁöÑÊØè‰∏Ä‰∏™ËØ≠Ê≥ïÁîüÊàêÈÄâÈ°πÈÉΩÈöêÂê´ÁùÄ‰ª•‰∏ãÂåÖÂê´ÁöÑÈªòËÆ§ÂÆö‰πâÔºö

1. For each child node child of this Parse Node, do
    - If child is an instance of symbol, return true.
    - If child is an instance of a nonterminal, then
        - Let contained be the result of child Contains symbol.
        - If contained is true, return true.
2. Return false.

FunctionDeclaration :
function BindingIdentifier ( FormalParameters ) { FunctionBody }
function ( FormalParameters ) { FunctionBody }
FunctionExpression :
function BindingIdentifieropt ( FormalParameters ) { FunctionBody }
GeneratorDeclaration :
function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
function * ( FormalParameters ) { GeneratorBody }
GeneratorExpression :
function * BindingIdentifieropt ( FormalParameters ) { GeneratorBody }
AsyncGeneratorDeclaration :
async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncGeneratorExpression :
async function * BindingIdentifieropt ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionDeclaration :
async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
async function ( FormalParameters ) { AsyncFunctionBody }
AsyncFunctionExpression :
async function BindingIdentifieropt ( FormalParameters ) { AsyncFunctionBody }
1. Return false.

>NOTE1 ‰æùËµñ‰∫éÂ≠êÁªìÊûÑÁöÑÈùôÊÄÅËØ≠‰πâËßÑÂàôÈÄöÂ∏∏‰∏çÁ†îÁ©∂ÂáΩÊï∞ÂÆö‰πâ„ÄÇ

ClassTail : ClassHeritageopt { ClassBody }
1. If symbol is ClassBody, return true.
2. If symbol is ClassHeritage, then
    - If ClassHeritage is present, return true; otherwise return false.
3. If ClassHeritage is present, then
    - If ClassHeritage Contains symbol is true, return true.
4. Return the result of ComputedPropertyContains of ClassBody with argument symbol.

>NOTE2 ‰æùËµñ‰∫éÂ≠êÁªìÊûÑÁöÑÈùôÊÄÅËØ≠‰πâËßÑÂàôÈÄöÂ∏∏‰∏çÁ†îÁ©∂Á±ª‰∏ª‰ΩìÔºå‰ΩÜPropertyNamesÈô§Â§ñ„ÄÇ

ClassStaticBlock : static { ClassStaticBlockBody }
1. Return false.

>NOTE3 ‰æùËµñ‰∫éÂ≠êÁªìÊûÑÁöÑÈùôÊÄÅËØ≠‰πâËßÑÂàôÈÄöÂ∏∏‰∏ç‰ºöÊü•ÁúãÈùôÊÄÅÂàùÂßãÂåñÂùó„ÄÇ

ArrowFunction : ArrowParameters => ConciseBody
1. If symbol is not one of NewTarget, SuperProperty, SuperCall, super or this, return false.
2. If ArrowParameters Contains symbol is true, return true.
3. Return ConciseBody Contains symbol.

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. Let formals be the ArrowFormalParameters that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. Return formals Contains symbol.

AsyncArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody
1. If symbol is not one of NewTarget, SuperProperty, SuperCall, super, or this, return false.
2. Return AsyncConciseBody Contains symbol.

AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
1. If symbol is not one of NewTarget, SuperProperty, SuperCall, super, or this, return false.
2. Let head be the AsyncArrowHead that is covered by CoverCallExpressionAndAsyncArrowHead.
3. If head Contains symbol is true, return true.
4. Return AsyncConciseBody Contains symbol.

>NOTE4 Contains Áî®‰∫éÊ£ÄÊµã ArrowFunction Êàñ AsyncArrowFunction ‰∏≠ÁöÑ new.target„ÄÅthis Âíå super ‰ΩøÁî®ÊÉÖÂÜµ„ÄÇ

PropertyDefinition : MethodDefinition
1. If symbol is MethodDefinition, return true.
2. Return the result of ComputedPropertyContains of MethodDefinition with argument symbol.

LiteralPropertyName : IdentifierName
1. Return false.

MemberExpression : MemberExpression . IdentifierName
1. If MemberExpression Contains symbol is true, return true.
2. Return false.

SuperProperty : super . IdentifierName
1. If symbol is the ReservedWord super, return true.
2. Return false.

CallExpression : CallExpression . IdentifierName
1. If CallExpression Contains symbol is true, return true.
2. Return false.

OptionalChain : ?. IdentifierName
1. Return false.

OptionalChain : OptionalChain . IdentifierName
1. If OptionalChain Contains symbol is true, return true.
2. Return false.

### 8.4.2 Static Semantics: ComputedPropertyContains

ËØ≠Ê≥ïÂà∂ÂØºÁöÑÊìç‰ΩúComputedPropertyContainsÊé•ÂèóÂèÇÊï∞symbol„ÄÇÂÆÉÊòØÂú®‰ª•‰∏ã‰∫ßÂìÅ‰∏äÂàÜÊÆµÂÆö‰πâÁöÑÔºö

ClassElementName : PrivateIdentifier
PropertyName : LiteralPropertyName
1. Return false.
PropertyName : ComputedPropertyName
1. Return the result of ComputedPropertyName Contains symbol.
MethodDefinition :
ClassElementName ( UniqueFormalParameters ) { FunctionBody }
get ClassElementName ( ) { FunctionBody }
set ClassElementName ( PropertySetParameterList ) { FunctionBody }
1. Return the result of ComputedPropertyContains of ClassElementName with argument symbol.
GeneratorMethod : * ClassElementName ( UniqueFormalParameters ) { GeneratorBody }
1. Return the result of ComputedPropertyContains of ClassElementName with argument symbol.
AsyncGeneratorMethod : async * ClassElementName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. Return the result of ComputedPropertyContains of ClassElementName with argument symbol.
ClassElementList : ClassElementList ClassElement
1. Let inList be ComputedPropertyContains of ClassElementList with argument symbol.
2. If inList is true, return true.
3. Return the result of ComputedPropertyContains of ClassElement with argument symbol.
ClassElement : ClassStaticBlock
1. Return false.
ClassElement : ;
1. Return false.
AsyncMethod : async ClassElementName ( UniqueFormalParameters ) { AsyncFunctionBody }
1. Return the result of ComputedPropertyContains of ClassElementName with argument symbol.
FieldDefinition : ClassElementName Initializeropt
1. Return the result of ComputedPropertyContains of ClassElementName with argument symbol.

## 8.5 Miscellaneous(ÊùÇÈ°π)

Ëøô‰∫õÊìç‰ΩúÂú®Êï¥‰∏™ËßÑËåÉ‰∏≠ÁöÑÂ§ö‰∏™Âú∞Êñπ‰ΩøÁî®„ÄÇ

### 8.5.1 Runtime Semantics: InstantiateFunctionObject(ÂÆû‰æãÂåñÂáΩÊï∞ÂØπË±°)

ËØ≠Ê≥ïÂØºÂêëÁöÑÊìç‰Ωú InstantiateFunctionObject Êé•ÂèóÂèÇÊï∞ env Âíå privateEnv„ÄÇ ÂÆÉÂú®‰ª•‰∏ã‰∫ßÁîüÂºè‰∏äÂàÜÊÆµÂÆö‰πâÔºö

FunctionDeclaration :
function BindingIdentifier ( FormalParameters ) { FunctionBody }
function ( FormalParameters ) { FunctionBody }
1. Return ? InstantiateOrdinaryFunctionObject of FunctionDeclaration with arguments env and privateEnv.
GeneratorDeclaration :
function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
function * ( FormalParameters ) { GeneratorBody }
1. Return ? InstantiateGeneratorFunctionObject of GeneratorDeclaration with arguments env and privateEnv.
AsyncGeneratorDeclaration :
async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
async function * ( FormalParameters ) { AsyncGeneratorBody }
1. Return ? InstantiateAsyncGeneratorFunctionObject of AsyncGeneratorDeclaration with arguments env and privateEnv.
AsyncFunctionDeclaration :
async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
async function ( FormalParameters ) { AsyncFunctionBody }
1. Return ? InstantiateAsyncFunctionObject of AsyncFunctionDeclaration with arguments env and privateEnv.

### 8.5.2 Runtime Semantics: BindingInitialization(ÁªëÂÆöÂàùÂßãÂåñ)

ËØ≠Ê≥ïÂà∂ÂØºÁöÑÊìç‰ΩúBindingInitializationÊé•ÂèóvalueÂíåenvironment„ÄÇ

>NOTE ‰∏∫ÁéØÂ¢É‰º†ÈÄí undefined ‰ª•ÊåáÁ§∫Â∫îËØ•‰ΩøÁî® PutValue Êìç‰ΩúÊù•ÂàÜÈÖçÂàùÂßãÂåñÂÄº„ÄÇ var ËØ≠Âè•Âíå‰∏Ä‰∫õÈùû‰∏•Ê†ºÂáΩÊï∞ÁöÑÂΩ¢ÂºèÂèÇÊï∞ÂàóË°®Â∞±ÊòØËøôÁßçÊÉÖÂÜµÔºàÂèÇËßÅ 10.2.11Ôºâ„ÄÇ Âú®Ëøô‰∫õÊÉÖÂÜµ‰∏ãÔºåÂú®ËØÑ‰º∞ÂÖ∂ÂàùÂßãÂåñÁ®ãÂ∫è‰πãÂâçÔºå‰ºöÊèêÂçáÂíåÈ¢ÑÂàùÂßãÂåñËØçÊ≥ïÁªëÂÆö„ÄÇ

ÂÆÉÂú®‰ª•‰∏ã‰∫ßÁîüÂºè‰∏äÂàÜÊÆµÂÆö‰πâÔºö

BindingIdentifier : Identifier
1. Let name be StringValue of Identifier.
2. Return ? InitializeBoundName(name, value, environment).
BindingIdentifier : yield
1. Return ? InitializeBoundName("yield", value, environment).
BindingIdentifier : await
1. Return ? InitializeBoundName("await", value, environment).
BindingPattern : ObjectBindingPattern
1. Perform ? RequireObjectCoercible(value).
2. Return the result of performing BindingInitialization of ObjectBindingPattern with arguments value and environment.
BindingPattern : ArrayBindingPattern
1. Let iteratorRecord be ? GetIterator(value).
2. Let result be IteratorBindingInitialization of ArrayBindingPattern with arguments iteratorRecord and environment.
3. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, result).
4. Return result.

ObjectBindingPattern : { }
1. Return NormalCompletion(empty).
ObjectBindingPattern :
{ BindingPropertyList }
{ BindingPropertyList , }
1. Perform ? PropertyBindingInitialization of BindingPropertyList with arguments value and environment.
2. Return NormalCompletion(empty).
ObjectBindingPattern : { BindingRestProperty }
1. Let excludedNames be a new empty List.
2. Return the result of performing RestBindingInitialization of BindingRestProperty with arguments value, environment, and excludedNames.
ObjectBindingPattern : { BindingPropertyList , BindingRestProperty }
1. Let excludedNames be ? PropertyBindingInitialization of BindingPropertyList with arguments value and environment.
2. Return the result of performing RestBindingInitialization of BindingRestProperty with arguments value, environment, and excludedNames.

#### 8.5.2.1 InitializeBoundName ( name, value, environment )

ÊäΩË±°Êìç‰Ωú InitializeBoundName ÈááÁî®ÂèÇÊï∞nameÔºàa StringÔºâ„ÄÅvalueÂíåenvironment„ÄÇ ÂÆÉÂú®Ë∞ÉÁî®Êó∂ÊâßË°å‰ª•‰∏ãÊ≠•È™§Ôºö

1. If environment is not undefined, then
    - Perform environment.InitializeBinding(name, value).
    - Return NormalCompletion(undefined).
2. Else,
    - Let lhs be ResolveBinding(name).
    - Return ? PutValue(lhs, value).

### 8.5.3 Runtime Semantics: IteratorBindingInitialization

ËØ≠Ê≥ïÊåáÂØºÁöÑÊìç‰Ωú IteratorBindingInitialization Êé•ÂèóÂèÇÊï∞ iteratorRecord Âíåenvironment„ÄÇ

>NOTE ÂΩì‰∏∫environment‰º†ÈÄíundefinedÊó∂ÔºåÂÆÉË°®Á§∫Â∫îËØ•‰ΩøÁî®PutValueÊìç‰ΩúÊù•ÂàÜÈÖçÂàùÂßãÂåñÂÄº„ÄÇÈùû‰∏•Ê†ºÂáΩÊï∞ÁöÑÂΩ¢ÂºèÂèÇÊï∞ÂàóË°®Â∞±ÊòØËøôÁßçÊÉÖÂÜµ„ÄÇÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåÂΩ¢ÂºèÂèÇÊï∞ÁªëÂÆö‰ºöÈ¢ÑÂÖàÂàùÂßãÂåñÔºå‰ª•‰æøÂ§ÑÁêÜÂ§ö‰∏™ÂèÇÊï∞ÂêåÂêçÁöÑÂèØËÉΩÊÄß„ÄÇ

It is defined piecewise over the following productions:

ArrayBindingPattern : [ ]
1. Return NormalCompletion(empty).
ArrayBindingPattern : [ Elision ]
1. Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord.
ArrayBindingPattern : [ Elisionopt BindingRestElement ]
1. If Elision is present, then
a. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord.
2. Return the result of performing IteratorBindingInitialization of BindingRestElement with arguments iteratorRecord and environment.
ArrayBindingPattern : [ BindingElementList , Elision ]
1. Perform ? IteratorBindingInitialization of BindingElementList with arguments iteratorRecord and environment.
2. Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord.
ArrayBindingPattern : [ BindingElementList , Elisionopt BindingRestElement ]
1. Perform ? IteratorBindingInitialization of BindingElementList with arguments iteratorRecord and environment.
2. If Elision is present, then
a. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord.
3. Return the result of performing IteratorBindingInitialization of BindingRestElement with arguments iteratorRecord and environment.
BindingElementList : BindingElementList , BindingElisionElement
1. Perform ? IteratorBindingInitialization of BindingElementList with arguments iteratorRecord and environment.
2. Return the result of performing IteratorBindingInitialization of BindingElisionElement with arguments iteratorRecord and environment.
BindingElisionElement : Elision BindingElement
1. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord.
2. Return the result of performing IteratorBindingInitialization of BindingElement with arguments iteratorRecord and environment.
SingleNameBinding : BindingIdentifier Initializeropt
1. Let bindingId be StringValue of BindingIdentifier.
2. Let lhs be ? ResolveBinding(bindingId, environment).
3. Let v be undefined.
4. If iteratorRecord.[[Done]] is false, then
a. Let next be IteratorStep(iteratorRecord).
b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
c. ReturnIfAbrupt(next).
d. If next is false, set iteratorRecord.[[Done]] to true.
e. Else,
i. Set v to IteratorValue(next).
ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
iii. ReturnIfAbrupt(v).
5. If Initializer is present and v is undefined, then
a. If IsAnonymousFunctionDefinition(Initializer) is true, then
i. Set v to the result of performing NamedEvaluation of Initializer with argument bindingId.
b. Else,
i. Let defaultValue be the result of evaluating Initializer.
ii. Set v to ? GetValue(defaultValue).
6. If environment is undefined, return ? PutValue(lhs, v).
7. Return InitializeReferencedBinding(lhs, v).
BindingElement : BindingPattern Initializeropt
1. Let v be undefined.
2. If iteratorRecord.[[Done]] is false, then
a. Let next be IteratorStep(iteratorRecord).
b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
c. ReturnIfAbrupt(next).
d. If next is false, set iteratorRecord.[[Done]] to true.
e. Else,
i. Set v to IteratorValue(next).
ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
iii. ReturnIfAbrupt(v).
3. If Initializer is present and v is undefined, then
a. Let defaultValue be the result of evaluating Initializer.
b. Set v to ? GetValue(defaultValue).
4. Return the result of performing BindingInitialization of BindingPattern with arguments v and environment.
BindingRestElement : ... BindingIdentifier
1. Let lhs be ? ResolveBinding(StringValue of BindingIdentifier, environment).
2. Let A be ! ArrayCreate(0).
3. Let n be 0.
4. Repeat,
a. If iteratorRecord.[[Done]] is false, then
i. Let next be IteratorStep(iteratorRecord).
ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
iii. ReturnIfAbrupt(next).
iv. If next is false, set iteratorRecord.[[Done]] to true.
b. If iteratorRecord.[[Done]] is true, then
i. If environment is undefined, return ? PutValue(lhs, A).
ii. Return InitializeReferencedBinding(lhs, A).
c. Let nextValue be IteratorValue(next).
d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
e. ReturnIfAbrupt(nextValue).
f. Perform ! CreateDataPropertyOrThrow(A, ! ToString(ùîΩ(n)), nextValue).
g. Set n to n + 1.
BindingRestElement : ... BindingPattern
1. Let A be ! ArrayCreate(0).
2. Let n be 0.
3. Repeat,
a. If iteratorRecord.[[Done]] is false, then
i. Let next be IteratorStep(iteratorRecord).
ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
iii. ReturnIfAbrupt(next).
iv. If next is false, set iteratorRecord.[[Done]] to true.
b. If iteratorRecord.[[Done]] is true, then
i. Return the result of performing BindingInitialization of BindingPattern with arguments A and environment.
c. Let nextValue be IteratorValue(next).
d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
e. ReturnIfAbrupt(nextValue).
f. Perform ! CreateDataPropertyOrThrow(A, ! ToString(ùîΩ(n)), nextValue).
g. Set n to n + 1.
FormalParameters : [empty]
1. Return NormalCompletion(empty).
FormalParameters : FormalParameterList , FunctionRestParameter
1. Perform ? IteratorBindingInitialization of FormalParameterList with arguments iteratorRecord and environment.
2. Return the result of performing IteratorBindingInitialization of FunctionRestParameter with arguments iteratorRecord and environment.
FormalParameterList : FormalParameterList , FormalParameter
1. Perform ? IteratorBindingInitialization of FormalParameterList with arguments iteratorRecord and environment.
2. Return the result of performing IteratorBindingInitialization of FormalParameter with arguments iteratorRecord and environment.
ArrowParameters : BindingIdentifier
1. Let v be undefined.
2. Assert: iteratorRecord.[[Done]] is false.
3. Let next be IteratorStep(iteratorRecord).
4. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
5. ReturnIfAbrupt(next).
6. If next is false, set iteratorRecord.[[Done]] to true.
7. Else,
a. Set v to IteratorValue(next).
b. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
c. ReturnIfAbrupt(v).
8. Return the result of performing BindingInitialization of BindingIdentifier with arguments v and environment.
ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. Let formals be the ArrowFormalParameters that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. Return IteratorBindingInitialization of formals with arguments iteratorRecord and environment.
AsyncArrowBindingIdentifier : BindingIdentifier
1. Let v be undefined.
2. Assert: iteratorRecord.[[Done]] is false.
3. Let next be IteratorStep(iteratorRecord).
4. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
5. ReturnIfAbrupt(next).
6. If next is false, set iteratorRecord.[[Done]] to true.
7. Else,
a. Set v to IteratorValue(next).
b. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
c. ReturnIfAbrupt(v).
8. Return the result of performing BindingInitialization of BindingIdentifier with arguments v and environment.


### 8.5.4 Static Semantics: AssignmentTargetType

ËØ≠Ê≥ïÂà∂ÂØºÁöÑÊìç‰Ωú AssignmentTargetType ‰∏çÊé•Âèó‰ªª‰ΩïÂèÇÊï∞„ÄÇ ÂÆÉÂú®‰ª•‰∏ã‰∫ßÁîüÂºè‰∏äÂàÜÊÆµÂÆö‰πâÔºö

IdentifierReference : Identifier
1. If this IdentifierReference is contained in strict mode code and StringValue of Identifier is "eval" or "arguments", return invalid.
2. Return simple.
IdentifierReference :
yield
await
CallExpression :
CallExpression [ Expression ]
CallExpression . IdentifierName
CallExpression . PrivateIdentifier
MemberExpression :
MemberExpression [ Expression ]
MemberExpression . IdentifierName
SuperProperty
MemberExpression . PrivateIdentifier
1. Return simple.
PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList
1. Let expr be the ParenthesizedExpression that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. Return AssignmentTargetType of expr.
PrimaryExpression :
this
Literal
ArrayLiteral
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
AsyncFunctionExpression
AsyncGeneratorExpression
RegularExpressionLiteral
TemplateLiteral
CallExpression :
CoverCallExpressionAndAsyncArrowHead
SuperCall
ImportCall
CallExpression Arguments
CallExpression TemplateLiteral
NewExpression :
new NewExpression
MemberExpression :
MemberExpression TemplateLiteral
new MemberExpression Arguments
NewTarget :
new . target
ImportMeta :
import . meta
LeftHandSideExpression :
OptionalExpression
UpdateExpression :
LeftHandSideExpression ++
LeftHandSideExpression --
++ UnaryExpression
-- UnaryExpression
UnaryExpression :
delete UnaryExpression
void UnaryExpression
typeof UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression
AwaitExpression
ExponentiationExpression :
UpdateExpression ** ExponentiationExpression
MultiplicativeExpression :
MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
AdditiveExpression :
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression
ShiftExpression :
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression
RelationalExpression :
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression instanceof ShiftExpression
RelationalExpression in ShiftExpression
PrivateIdentifier in ShiftExpression
EqualityExpression :
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression
BitwiseANDExpression :
BitwiseANDExpression & EqualityExpression
BitwiseXORExpression :
BitwiseXORExpression ^ BitwiseANDExpression
BitwiseORExpression :
BitwiseORExpression | BitwiseXORExpression
LogicalANDExpression :
LogicalANDExpression && BitwiseORExpression
LogicalORExpression :
LogicalORExpression || LogicalANDExpression
CoalesceExpression :
CoalesceExpressionHead ?? BitwiseORExpression
ConditionalExpression :
ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
AssignmentExpression :
YieldExpression
ArrowFunction
AsyncArrowFunction
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression
LeftHandSideExpression &&= AssignmentExpression
LeftHandSideExpression ||= AssignmentExpression
LeftHandSideExpression ??= AssignmentExpression
Expression :
Expression , AssignmentExpression
1. Return invalid.

### 8.5.5 Static Semantics: PropName

ËØ≠Ê≥ïÂà∂ÂØºÁöÑÊìç‰Ωú PropName ‰∏çÂ∏¶‰ªª‰ΩïÂèÇÊï∞„ÄÇ ÂÆÉÂú®‰ª•‰∏ã‰∫ßÁîüÂºè‰∏äÂàÜÊÆµÂÆö‰πâÔºö

PropertyDefinition : IdentifierReference
1. Return StringValue of IdentifierReference.
PropertyDefinition : ... AssignmentExpression
1. Return empty.
PropertyDefinition : PropertyName : AssignmentExpression
1. Return PropName of PropertyName.
LiteralPropertyName : IdentifierName
1. Return StringValue of IdentifierName.
LiteralPropertyName : StringLiteral
1. Return the SV of StringLiteral.
LiteralPropertyName : NumericLiteral
1. Let nbr be the NumericValue of NumericLiteral.
2. Return ! ToString(nbr).
ComputedPropertyName : [ AssignmentExpression ]
1. Return empty.
MethodDefinition :
ClassElementName ( UniqueFormalParameters ) { FunctionBody }
get ClassElementName ( ) { FunctionBody }
set ClassElementName ( PropertySetParameterList ) { FunctionBody }
1. Return PropName of ClassElementName.
GeneratorMethod : * ClassElementName ( UniqueFormalParameters ) { GeneratorBody }
1. Return PropName of ClassElementName.
AsyncGeneratorMethod : async * ClassElementName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. Return PropName of ClassElementName.
ClassElement : ClassStaticBlock
1. Return empty.
ClassElement : ;
1. Return empty.
AsyncMethod : async ClassElementName ( UniqueFormalParameters ) { AsyncFunctionBody }
1. Return PropName of ClassElementName.
FieldDefinition : ClassElementName Initializeropt
1. Return PropName of ClassElementName.
ClassElementName : PrivateIdentifier
1. Return empty.